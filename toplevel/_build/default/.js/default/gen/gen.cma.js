// Generated by js_of_ocaml
//# buildInfo:effects=disabled, kind=cma, use-js-string=true, version=6.2.0

//# unitInfo: Provides: Gen_intf
//# shape: Gen_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Gen_intf = [0];
   runtime.caml_register_global(0, Gen_intf, "Gen_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: GenShims_
//# shape: GenShims_:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, GenShims = [0];
   runtime.caml_register_global(0, GenShims, "GenShims_");
   return;
  }
  (globalThis));

//# unitInfo: Provides: GenM_intf
//# shape: GenM_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, GenM_intf = [0];
   runtime.caml_register_global(0, GenM_intf, "GenM_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: GenMList
//# unitInfo: Requires: CamlinternalOO, Stdlib, Stdlib__Array
//# shape: GenMList:[F(1),F(3),F(1)*->F(1),F(1)*->F(1),F(1)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_clone = "clone",
    cst_gen = "gen",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    shared = [0, cst_clone, cst_gen],
    CamlinternalOO = global_data.CamlinternalOO,
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    c = [0, "src/genMList.ml", 76, 19];
   function make(max_chunk_size, gen){
    return [0, [0, [2, gen]], 8, max_chunk_size];
   }
   function read_chunk(mlist, gen){
    var match = caml_call1(gen, 0);
    if(! match) return 0;
    var x = match[1];
    if(1 === mlist[3]){
     var tail = [0, [2, gen]], node = [1, x, tail];
     return node;
    }
    var
     r = [0, 1],
     a = runtime.caml_array_make(mlist[2], x),
     tail$0 = [0, [2, gen]],
     stop = [0, 0],
     node$0 = [0, a, r, tail$0];
    for(;;){
     if(! stop[1] && r[1] < mlist[2]){
      var match$0 = caml_call1(gen, 0);
      if(match$0){
       var x$0 = match$0[1], b = r[1];
       caml_check_bound(a, b)[b + 1] = x$0;
       r[1]++;
       continue;
      }
      tail$0[1] = 0;
      stop[1] = 1;
      continue;
     }
     if(mlist[2] < mlist[3]) mlist[2] = 2 * mlist[2] | 0;
     return node$0;
    }
   }
   function of_gen(gen){
    var mlist = make(4096, gen), prev$2 = mlist[1], prev = prev$2;
    for(;;){
     var node = read_chunk(mlist, gen);
     if(typeof node === "number"){prev[1] = 0; return mlist;}
     switch(node[0]){
       case 0:
        var prev$0 = node[3]; prev[1] = node; prev = prev$0; break;
       case 1:
        var prev$1 = node[2]; prev[1] = node; prev = prev$1; break;
       default: throw caml_maybe_attach_backtrace([0, Assert_failure, c], 1);
     }
    }
   }
   function of_gen_lazy(a, opt, gen){
    var max_chunk_size = a ? a[1] : 2048, caching = opt ? opt[1] : 1;
    if(! caching) return [0, [0, [2, gen]], 1, 1];
    var max_chunk_size$0 = caml_call2(Stdlib[17], max_chunk_size, 2);
    return make(max_chunk_size$0, gen);
   }
   function to_gen(l){
    var cur = [0, l[1]], i = [0, 0];
    function next(param){
     for(;;){
      var match = cur[1][1];
      if(typeof match === "number") return 0;
      switch(match[0]){
        case 0:
         var l$0 = match[3], n = match[2], a = match[1];
         if(i[1] !== n[1]){
          var b = i[1], y = caml_check_bound(a, b)[b + 1];
          i[1]++;
          return [0, y];
         }
         cur[1] = l$0;
         i[1] = 0;
         break;
        case 1:
         var l$1 = match[2], x = match[1]; cur[1] = l$1; return [0, x];
        default:
         var gen = match[1], node = read_chunk(l, gen); cur[1][1] = node;
      }
     }
    }
    return next;
   }
   function to_seq(l0){
    function next(l$2, i$0, param){
     a:
     {
      var l = l$2, i = i$0;
      b:
      for(;;){
       var match = l[1];
       if(typeof match === "number") return 0;
       switch(match[0]){
         case 0:
          var l$0 = match[3], n = match[2], a = match[1];
          if(i !== n[1]) break a;
          l = l$0;
          i = 0;
          break;
         case 1:
          break b;
         default: var gen = match[1], node = read_chunk(l0, gen); l[1] = node;
       }
      }
      var l$1 = match[2], x = match[1];
      return [0, x, function(a){return next(l$1, i, a);}];
     }
     var y = caml_check_bound(a, i)[i + 1], b = i + 1 | 0;
     return [0, y, function(a){return next(l, b, a);}];
    }
    var a = 0, b = l0[1];
    return function(c){return next(b, a, c);};
   }
   var a = [0, 0], b = [0, cst_gen, cst_clone];
   function to_clonable(l){
    function make(node, i){
     var cur = [0, node], i$0 = [0, i];
     function next(param){
      for(;;){
       var match = cur[1][1];
       if(typeof match === "number") return 0;
       switch(match[0]){
         case 0:
          var l$0 = match[3], n = match[2], a = match[1];
          if(i$0[1] !== n[1]){
           var b = i$0[1], y = caml_check_bound(a, b)[b + 1];
           i$0[1] = i$0[1] + 1 | 0;
           return [0, y];
          }
          cur[1] = l$0;
          i$0[1] = 0;
          break;
         case 1:
          var l$1 = match[2], x = match[1]; cur[1] = l$1; return [0, x];
         default:
          var gen = match[1], node = read_chunk(l, gen); cur[1][1] = node;
       }
      }
     }
     if(! a[1]){
      var
       c = caml_call1(CamlinternalOO[16], shared),
       d = caml_call2(CamlinternalOO[3], c, cst),
       e = caml_call2(CamlinternalOO[8], c, b);
      caml_call2
       (CamlinternalOO[11],
        c,
        [0,
         e[1],
         function(self_1){var env = self_1[d + 1]; return env[4];},
         e[2],
         function(self_1){
          var env = self_1[d + 1];
          return caml_call2(env[1], env[2][1], env[3][1]);
         }]);
      caml_call1(CamlinternalOO[17], c);
      a[1] =
       function(b){
        var a = caml_call2(CamlinternalOO[24], 0, c);
        a[d + 1] = b;
        return a;
       };
     }
     return caml_call1(a[1], [0, make, cur, i$0, next]);
    }
    return make(l[1], 0);
   }
   var GenMList = [0, of_gen, of_gen_lazy, to_gen, to_seq, to_clonable];
   runtime.caml_register_global(7, GenMList, "GenMList");
   return;
  }
  (globalThis));

//# unitInfo: Provides: GenM
//# shape: GenM:[F(1)*]
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    GenM =
      [0,
       function(M){
        var a = M[2], b = M[3];
        function return$(x){
         var first = [0, 1];
         return function(param){
          return first[1]
                  ? (first[1] = 0, caml_call1(M[1], [0, x]))
                  : caml_call1(M[1], 0);};
        }
        function sequence_m(g, param){
         var match = caml_call1(g, 0);
         if(! match) return caml_call1(M[1], 0);
         var act = match[1];
         return caml_call2(b, act, function(x){return [0, x];});
        }
        function map(f, g, param){
         return caml_call2
                 (b,
                  caml_call1(g, 0),
                  function(param){
                   if(! param) return 0;
                   var x = param[1];
                   return [0, caml_call1(f, x)];
                  });
        }
        function flat_map(f, g){
         function next(f, g, param){
          return caml_call2
                  (a,
                   caml_call1(g, 0),
                   function(param){
                    if(! param) return caml_call1(M[1], 0);
                    var x = param[1], cur = caml_call1(f, x);
                    return map_from(f, g, cur, 0);
                   });
         }
         function map_from(f, g, cur, param){
          var res = caml_call1(cur, 0);
          return caml_call2
                  (a,
                   res,
                   function(param){return param ? res : next(f, g, 0);});
         }
         return function(a){return next(f, g, a);};
        }
        function fold(f, acc, g){
         return caml_call2
                 (a,
                  caml_call1(g, 0),
                  function(param){
                   if(! param) return caml_call1(M[1], acc);
                   var x = param[1], acc$0 = caml_call2(f, acc, x);
                   return fold(f, acc$0, g);
                  });
        }
        function fold_m(f, acc, g){
         return caml_call2
                 (a,
                  caml_call1(g, 0),
                  function(param){
                   if(! param) return caml_call1(M[1], acc);
                   var x = param[1];
                   return caml_call2
                           (a,
                            caml_call2(f, acc, x),
                            function(acc){return fold_m(f, acc, g);});
                  });
        }
        function iter(f, g){
         return caml_call2
                 (a,
                  caml_call1(g, 0),
                  function(param){
                   if(! param) return caml_call1(M[1], 0);
                   var x = param[1];
                   caml_call1(f, x);
                   return iter(f, g);
                  });
        }
        function iter_s(f, g){
         return caml_call2
                 (a,
                  caml_call1(g, 0),
                  function(param){
                   if(! param) return caml_call1(M[1], 0);
                   var x = param[1];
                   return caml_call2
                           (a, caml_call1(f, x), function(param){return iter_s(f, g);});
                  });
        }
        function iter_p(f, g){
         return caml_call2
                 (a,
                  caml_call1(g, 0),
                  function(param){
                   if(! param) return caml_call1(M[1], 0);
                   var x = param[1];
                   caml_call1(f, x);
                   return iter_p(f, g);
                  });
        }
        function symbol(x, f){return function(a){return map(f, x, a);};}
        function symbol_bind(x, f){return flat_map(f, x);}
        return [0,
                M,
                return$,
                sequence_m,
                map,
                flat_map,
                fold,
                fold_m,
                iter,
                iter_s,
                iter_p,
                [0, symbol_bind, symbol],
                symbol_bind,
                symbol];
       }];
   runtime.caml_register_global(0, GenM, "GenM");
   return;
  }
  (globalThis));

//# unitInfo: Provides: GenLabels_intf
//# shape: GenLabels_intf:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, GenLabels_intf = [0];
   runtime.caml_register_global(0, GenLabels_intf, "GenLabels_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Gen
//# unitInfo: Requires: GenMList, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Format, Stdlib__List, Stdlib__Queue, Stdlib__Random
//# shape: Gen:[F(1),F(1),F(1),F(1),F(2),F(1)*,F(1)*->F(1),F(1)*->F(1),F(2)*,F(2)*->F(1),F(2)*->F(1),F(2)*->F(1),F(1),F(3),F(2),F(3)*->F(1),F(3)*->F(1),F(2),F(2),F(1),F(2)*->F(1),F(1)*->F(1)*,F(3)*,F(2)*->F(1),F(1)*->F(1),F(2)*->F(1),F(3),F(2)->F(1),F(2)->F(1),F(2),F(2)->F(1),F(2)*->F(1),F(2)*->F(1),F(3),F(2)*->F(1),F(2)*->F(1),F(1)*->F(1),F(1),F(2),F(2),F(2),F(2),F(2),F(3),F(3),F(3),F(2),F(1),F(3)*->F(1),F(3),F(4),F(3),F(3),F(3)*->F(1),F(2)*,F(1)->F(1),F(3)->F(1),F(3)->F(1),F(2)->F(1),F(2),F(2),F(2)*->F(1),F(2)*->F(1),F(2)*->F(1),F(2)->F(1),F(2)*->F(1),F(2)->F(1),F(2),F(2)*->F(1),F(1)->F(1),F(1)->F(1),F(2)->F(1),F(1)->F(1),F(1)*->F(1),F(1),F(1),F(1),F(3)->F(1),F(3)->F(1),F(1),F(2),F(1)*->F(1),F(3)->F(1),F(1)->F(1),F(1)*->F(1),[F(2),F(2)*,F(2)*,F(2)*],F(2),F(2)*,F(2)*,F(2)*,F(7),F(1)*->F(1),F(2),N,F(1)->F(1)*,F(3)->F(1)*,F(1),F(3),F(1)*->F(1),F(2)->F(1),F(1),N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$3 = "",
    cst_src_gen_ml = "src/gen.ml",
    caml_array_make = runtime.caml_array_make,
    caml_check_bound = runtime.caml_check_bound,
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    cst$2 = cst$3,
    cst$1 = cst$3,
    cst$0 = cst$3,
    cst = ",",
    step = [0, 1],
    Stdlib = global_data.Stdlib,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Assert_failure = global_data.Assert_failure,
    GenMList = global_data.GenMList,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Array = global_data.Stdlib__Array,
    cst_Gen_get_exn = "Gen.get_exn",
    cst_reduce = "reduce",
    a = [0, cst_src_gen_ml, 226, 14],
    b = [0, cst_src_gen_ml, 366, 2],
    c = [0, cst_src_gen_ml, 388, 2],
    d = [0, cst_src_gen_ml, 407, 2],
    e = [0, cst_src_gen_ml, 423, 2],
    cst_min = "min",
    cst_max = "max",
    f = [0, cst_src_gen_ml, 985, 10],
    g = [0, cst_src_gen_ml, 1318, 12],
    h = [0, 0],
    i = [0, cst_src_gen_ml, 1344, 15],
    j = [0, cst_src_gen_ml, 1407, 23],
    k = [0, cst_src_gen_ml, 1402, 26],
    l = [0, 0, 0],
    m = [0, 0],
    n = [0, cst_src_gen_ml, 1454, 2],
    o = [0, 0],
    p = [0, cst_src_gen_ml, 1567, 16],
    q = [0, cst_src_gen_ml, 1582, 16],
    cst_Gen_int_range = "Gen.int_range",
    r = [0, 10],
    s = [0, 10],
    t = [0, 1];
   function empty(param){return 0;}
   function singleton(x){
    var first = [0, 1];
    return function(param){return first[1] ? (first[1] = 0, [0, x]) : 0;};
   }
   function repeat(x, param){return [0, x];}
   function repeatedly(f, param){return [0, caml_call1(f, 0)];}
   function iterate(x, f){
    var cur = [0, x];
    return function(param){
     var x = cur[1];
     cur[1] = caml_call1(f, cur[1]);
     return [0, x];};
   }
   function next(gen){return caml_call1(gen, 0);}
   function get(gen){return caml_call1(gen, 0);}
   function get_exn(gen){
    var match = caml_call1(gen, 0);
    if(! match)
     throw caml_maybe_attach_backtrace([0, Stdlib[6], cst_Gen_get_exn], 1);
    var x = match[1];
    return x;
   }
   function junk(gen){caml_call1(gen, 0); return 0;}
   function fold(f, acc$1, gen){
    var acc = acc$1;
    for(;;){
     var match = caml_call1(gen, 0);
     if(! match) return acc;
     var x = match[1], acc$0 = caml_call2(f, acc, x);
     acc = acc$0;
    }
   }
   function reduce(f, g){
    var match = caml_call1(g, 0);
    if(! match)
     throw caml_maybe_attach_backtrace([0, Stdlib[6], cst_reduce], 1);
    var acc = match[1];
    return fold(f, acc, g);
   }
   function unfold(f, acc){
    var acc$0 = [0, acc];
    return function(param){
     var match = caml_call1(f, acc$0[1]);
     if(! match) return 0;
     var match$0 = match[1], acc = match$0[2], x = match$0[1];
     acc$0[1] = acc;
     return [0, x];};
   }
   function init(opt, f){
    var limit = opt ? opt[1] : Stdlib[19], r = [0, 0];
    return function(param){
     if(limit <= r[1]) return 0;
     var x = caml_call1(f, r[1]);
     r[1]++;
     return [0, x];};
   }
   function iter(f, gen){
    for(;;){
     var match = caml_call1(gen, 0);
     if(! match) return 0;
     var x = match[1];
     caml_call1(f, x);
    }
   }
   function iteri(f, gen){
    var i = 0;
    for(;;){
     var match = caml_call1(gen, 0);
     if(! match) return 0;
     var x = match[1];
     caml_call2(f, i, x);
     var i$0 = i + 1 | 0;
     i = i$0;
    }
   }
   function is_empty(gen){return caml_call1(gen, 0) ? 0 : 1;}
   function length(gen){
    var acc$0 = 0;
    for(;;){
     if(! caml_call1(gen, 0)) return acc$0;
     var acc = acc$0 + 1 | 0;
     acc$0 = acc;
    }
   }
   function scan(f, acc, g){
    var state = [0, 0];
    return function(param){
     var match = state[1];
     if(typeof match === "number")
      return match ? 0 : (state[1] = [0, acc], [0, acc]);
     var acc$0 = match[1], match$0 = caml_call1(g, 0);
     if(match$0){
      var x = match$0[1], acc$1 = caml_call2(f, acc$0, x);
      state[1] = [0, acc$1];
      return [0, acc$1];
     }
     state[1] = 1;
     return 0;};
   }
   function unfold_scan(f, acc, g){
    var state = [0, [0, acc]];
    return function(param){
     var match = state[1];
     if(typeof match === "number"){
      if(match) return 0;
      throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
     }
     var acc = match[1], match$0 = caml_call1(g, 0);
     if(match$0){
      var
       x = match$0[1],
       match$1 = caml_call2(f, acc, x),
       y = match$1[2],
       acc$0 = match$1[1];
      state[1] = [0, acc$0];
      return [0, y];
     }
     state[1] = 1;
     return 0;};
   }
   function map(f, gen){
    var stop = [0, 0];
    return function(param){
     if(stop[1]) return 0;
     var match = caml_call1(gen, 0);
     if(match){var x = match[1]; return [0, caml_call1(f, x)];}
     stop[1] = 1;
     return 0;};
   }
   function mapi(f){
    var cnt = [0, 0];
    function cnt_map(x){
     var i = cnt[1];
     cnt[1] = i + 1 | 0;
     return caml_call2(f, i, x);
    }
    return function(a){return map(cnt_map, a);};
   }
   function fold_map(f, s, gen){
    var state = [0, s];
    return map
            (function(x){
              state[1] = caml_call2(f, state[1], x);
              return state[1];
             },
             gen);
   }
   function append(gen1, gen2){
    var first = [0, 1];
    return function(param){
     if(! first[1]) return caml_call1(gen2, 0);
     var x = caml_call1(gen1, 0);
     return x ? x : (first[1] = 0, caml_call1(gen2, 0));};
   }
   function flatten(next_gen){
    var state = [0, 0];
    function next$0(counter, param){
     var match = state[1];
     if(typeof match === "number"){
      if(match) return 0;
      var a = 0;
      if(counter >= 50) return caml_trampoline_return(get_next_gen, [0, a]);
      var counter$0 = counter + 1 | 0;
      return get_next_gen(counter$0, a);
     }
     var gen = match[1], x = caml_call1(gen, 0);
     if(x) return x;
     var b = 0;
     if(counter >= 50) return caml_trampoline_return(get_next_gen, [0, b]);
     var counter$1 = counter + 1 | 0;
     return get_next_gen(counter$1, b);
    }
    function next(param){return caml_trampoline(next$0(0, param));}
    function get_next_gen(counter, param){
     var match = caml_call1(next_gen, 0);
     if(! match){state[1] = 1; return 0;}
     var gen = match[1];
     state[1] = [0, gen];
     var a = 0;
     if(counter >= 50) return caml_trampoline_return(next$0, [0, a]);
     var counter$0 = counter + 1 | 0;
     return next$0(counter$0, a);
    }
    return next;
   }
   function flat_map(f, next_elem){
    var state = [0, 0];
    function next$0(counter, param){
     var match = state[1];
     if(typeof match === "number"){
      if(match) return 0;
      var a = 0;
      if(counter >= 50) return caml_trampoline_return(get_next_gen, [0, a]);
      var counter$0 = counter + 1 | 0;
      return get_next_gen(counter$0, a);
     }
     var gen = match[1], x = caml_call1(gen, 0);
     if(x) return x;
     var b = 0;
     if(counter >= 50) return caml_trampoline_return(get_next_gen, [0, b]);
     var counter$1 = counter + 1 | 0;
     return get_next_gen(counter$1, b);
    }
    function next(param){return caml_trampoline(next$0(0, param));}
    function get_next_gen(counter, param){
     try{var val = caml_call1(next_elem, 0);}
     catch(e$0){
      var e = caml_wrap_exception(e$0);
      state[1] = 1;
      throw caml_maybe_attach_backtrace(e, 0);
     }
     if(! val){state[1] = 1; return 0;}
     var x = val[1];
     state[1] = [0, caml_call1(f, x)];
     var a = 0;
     if(counter >= 50) return caml_trampoline_return(next$0, [0, a]);
     var counter$0 = counter + 1 | 0;
     return next$0(counter$0, a);
    }
    return next;
   }
   function mem(opt, x, gen){
    var eq = opt ? opt[1] : caml_equal;
    for(;;){
     var match = caml_call1(gen, 0);
     if(! match) return 0;
     var y = match[1], a = caml_call2(eq, x, y);
     if(a) return a;
    }
   }
   function take(n, gen){
    if(0 > n) throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
    var count = [0, 0];
    return function(param){
     if(count[1] !== n && count[1] !== -1){
      var x = caml_call1(gen, 0);
      return x ? (count[1]++, x) : (count[1] = -1, 0);
     }
     return 0;};
   }
   function drop(n$1, gen){
    var n = n$1;
    for(;;){
     if(0 === n) return;
     if(! caml_call1(gen, 0)) return;
     var n$0 = n - 1 | 0;
     n = n$0;
    }
   }
   function drop$0(n, gen){
    if(0 > n) throw caml_maybe_attach_backtrace([0, Assert_failure, c], 1);
    var dropped = [0, 0];
    return function(param){
     return dropped[1]
             ? caml_call1(gen, 0)
             : (dropped[1] = 1, drop(n, gen), caml_call1(gen, 0));};
   }
   function nth(n, gen){
    if(0 > n) throw caml_maybe_attach_backtrace([0, Assert_failure, d], 1);
    drop(n, gen);
    var match = caml_call1(gen, 0);
    if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var x = match[1];
    return x;
   }
   function take_nth(n, gen){
    if(1 > n) throw caml_maybe_attach_backtrace([0, Assert_failure, e], 1);
    var i = [0, n];
    function next(param){
     for(;;){
      var res = caml_call1(gen, 0);
      if(! res) return 0;
      if(i[1] === n){i[1] = 1; return res;}
      i[1]++;
     }
    }
    return next;
   }
   function filter(p, gen){
    function next(param){
     for(;;){
      var res = caml_call1(gen, 0);
      if(! res) return 0;
      var x = res[1];
      if(caml_call1(p, x)) return res;
     }
    }
    return next;
   }
   function take_while(p, gen){
    var stop = [0, 0];
    return function(param){
     if(stop[1]) return 0;
     var res = caml_call1(gen, 0);
     if(res){
      var x = res[1];
      return caml_call1(p, x) ? res : (stop[1] = 1, 0);
     }
     stop[1] = 1;
     return 0;};
   }
   function fold_while(f, s, gen){
    var state = [0, s];
    for(;;){
     var match = caml_call1(gen, 0);
     if(match){
      var
       x = match[1],
       match$0 = caml_call2(f, state[1], x),
       cont = match$0[2],
       acc = match$0[1];
      state[1] = acc;
      if(926227490 > cont) continue;
     }
     return state[1];
    }
   }
   function drop_while(p, gen){
    var state = [0, 1];
    function next(param){
     for(;;)
      switch(state[1]){
        case 0:
         return 0;
        case 1:
         var res = caml_call1(gen, 0);
         if(! res){state[1] = 0; return 0;}
         var x = res[1];
         if(! caml_call1(p, x)){state[1] = 2; return res;}
         break;
        default:
         var res$0 = caml_call1(gen, 0);
         return res$0 ? res$0 : (state[1] = 0, 0);
      }
    }
    return next;
   }
   function filter_map(f, gen){
    function next(param){
     for(;;){
      var match = caml_call1(gen, 0);
      if(! match) return 0;
      var x = match[1], res = caml_call1(f, x);
      if(res) return res;
     }
    }
    return next;
   }
   function zip_index(gen){
    var r = [0, -1];
    return function(param){
     var match = caml_call1(gen, 0);
     if(! match) return 0;
     var x = match[1];
     r[1]++;
     return [0, [0, r[1], x]];};
   }
   function unzip(gen){
    var
     stop = [0, 0],
     q1 = caml_call1(Stdlib_Queue[2], 0),
     q2 = caml_call1(Stdlib_Queue[2], 0);
    function next_left(param){
     if(! caml_call1(Stdlib_Queue[14], q1))
      return [0, caml_call1(Stdlib_Queue[7], q1)];
     if(stop[1]) return 0;
     var match = caml_call1(gen, 0);
     if(match){
      var match$0 = match[1], y = match$0[2], x = match$0[1];
      caml_call2(Stdlib_Queue[4], y, q2);
      return [0, x];
     }
     stop[1] = 1;
     return 0;
    }
    function next_right(param){
     if(! caml_call1(Stdlib_Queue[14], q2))
      return [0, caml_call1(Stdlib_Queue[7], q2)];
     if(stop[1]) return 0;
     var match = caml_call1(gen, 0);
     if(match){
      var match$0 = match[1], y = match$0[2], x = match$0[1];
      caml_call2(Stdlib_Queue[4], x, q1);
      return [0, y];
     }
     stop[1] = 1;
     return 0;
    }
    return [0, next_left, next_right];
   }
   function partition(p, gen){
    var
     qtrue = caml_call1(Stdlib_Queue[2], 0),
     qfalse = caml_call1(Stdlib_Queue[2], 0),
     stop = [0, 0];
    function nexttrue(param){
     for(;;){
      if(! caml_call1(Stdlib_Queue[14], qtrue))
       return [0, caml_call1(Stdlib_Queue[7], qtrue)];
      if(stop[1]) return 0;
      var res = caml_call1(gen, 0);
      if(! res){stop[1] = 1; return 0;}
      var x = res[1];
      if(caml_call1(p, x)) return res;
      caml_call2(Stdlib_Queue[4], x, qfalse);
     }
    }
    function nextfalse(param){
     for(;;){
      if(! caml_call1(Stdlib_Queue[14], qfalse))
       return [0, caml_call1(Stdlib_Queue[7], qfalse)];
      if(stop[1]) return 0;
      var res = caml_call1(gen, 0);
      if(! res){stop[1] = 1; return 0;}
      var x = res[1];
      if(! caml_call1(p, x)) return res;
      caml_call2(Stdlib_Queue[4], x, qtrue);
     }
    }
    return [0, nexttrue, nextfalse];
   }
   function for_all(p, gen){
    for(;;){
     var match = caml_call1(gen, 0);
     if(! match) return 1;
     var x = match[1], a = caml_call1(p, x);
     if(! a) return a;
    }
   }
   function exists(p, gen){
    for(;;){
     var match = caml_call1(gen, 0);
     if(! match) return 0;
     var x = match[1], a = caml_call1(p, x);
     if(a) return a;
    }
   }
   function min(opt, gen){
    var lt = opt ? opt[1] : caml_lessthan, match = caml_call1(gen, 0);
    if(! match) throw caml_maybe_attach_backtrace([0, Stdlib[6], cst_min], 1);
    var first = match[1], acc = first;
    for(;;){
     var match$0 = caml_call1(gen, 0);
     if(! match$0) return acc;
     var x = match$0[1];
     if(caml_call2(lt, x, acc)) acc = x;
    }
   }
   function max(opt, gen){
    var lt = opt ? opt[1] : caml_lessthan, match = caml_call1(gen, 0);
    if(! match) throw caml_maybe_attach_backtrace([0, Stdlib[6], cst_max], 1);
    var first = match[1], acc = first;
    for(;;){
     var match$0 = caml_call1(gen, 0);
     if(! match$0) return acc;
     var x = match$0[1];
     if(caml_call2(lt, acc, x)) acc = x;
    }
   }
   function eq(opt, gen1, gen2){
    var eq = opt ? opt[1] : caml_equal;
    for(;;){
     var match = caml_call1(gen1, 0), match$0 = caml_call1(gen2, 0);
     if(match){
      if(match$0){
       var x2 = match$0[1], x1 = match[1];
       if(caml_call2(eq, x1, x2)) continue;
      }
     }
     else if(! match$0) return 1;
     return 0;
    }
   }
   function lexico(opt, gen1, gen2){
    var cmp = opt ? opt[1] : caml_compare;
    for(;;){
     var match = caml_call1(gen1, 0), match$0 = caml_call1(gen2, 0);
     if(! match) return match$0 ? -1 : 0;
     var x1 = match[1];
     if(! match$0) return 1;
     var x2 = match$0[1], c = caml_call2(cmp, x1, x2);
     if(0 !== c) return c;
    }
   }
   function compare(cmp, gen1, gen2){return lexico(cmp, gen1, gen2);}
   function find(p, e){
    for(;;){
     var match = caml_call1(e, 0);
     if(! match) return 0;
     var x = match[1];
     if(caml_call1(p, x)) return [0, x];
    }
   }
   function sum(e){
    var acc = 0;
    for(;;){
     var match = caml_call1(e, 0);
     if(! match) return acc;
     var x = match[1], acc$0 = x + acc | 0;
     acc = acc$0;
    }
   }
   function map2(f, e1, e2){
    return function(param){
     var match = caml_call1(e1, 0), match$0 = caml_call1(e2, 0);
     if(match && match$0){
      var y = match$0[1], x = match[1];
      return [0, caml_call2(f, x, y)];
     }
     return 0;};
   }
   function iter2(f, e1, e2){
    for(;;){
     var match = caml_call1(e1, 0), match$0 = caml_call1(e2, 0);
     if(match && match$0){
      var y = match$0[1], x = match[1];
      caml_call2(f, x, y);
      continue;
     }
     return 0;
    }
   }
   function fold2(f, acc$1, e1, e2){
    var acc = acc$1;
    for(;;){
     var match = caml_call1(e1, 0), match$0 = caml_call1(e2, 0);
     if(match && match$0){
      var y = match$0[1], x = match[1], acc$0 = caml_call3(f, acc, x, y);
      acc = acc$0;
      continue;
     }
     return acc;
    }
   }
   function for_all2(p, e1, e2){
    for(;;){
     var match = caml_call1(e1, 0), match$0 = caml_call1(e2, 0);
     if(match && match$0){
      var y = match$0[1], x = match[1], a = caml_call2(p, x, y);
      if(a) continue;
      return a;
     }
     return 1;
    }
   }
   function exists2(p, e1, e2){
    for(;;){
     var match = caml_call1(e1, 0), match$0 = caml_call1(e2, 0);
     if(match && match$0){
      var y = match$0[1], x = match[1], a = caml_call2(p, x, y);
      if(a) return a;
      continue;
     }
     return 0;
    }
   }
   function zip_with(f, a, b){
    var stop = [0, 0];
    return function(param){
     if(stop[1]) return 0;
     var match = caml_call1(a, 0), match$0 = caml_call1(b, 0);
     if(match && match$0){
      var xb = match$0[1], xa = match[1];
      return [0, caml_call2(f, xa, xb)];
     }
     stop[1] = 1;
     return 0;};
   }
   function zip(a, b){
    return zip_with(function(x, y){return [0, x, y];}, a, b);
   }
   function merge(next_gen){
    var state = [0, caml_call1(Stdlib_Queue[2], 0), 0];
    function next(param){
     for(;;)
      switch(state[2]){
        case 0:
         var match = caml_call1(next_gen, 0);
         if(match){
          var gen = match[1];
          caml_call2(Stdlib_Queue[4], gen, state[1]);
          state[2] = 1;
         }
         else
          state[2] = 2;
         break;
        case 1:
         if(caml_call1(Stdlib_Queue[14], state[1]))
          state[2] = 0;
         else{
          var
           gen$0 = caml_call1(Stdlib_Queue[7], state[1]),
           res = caml_call1(gen$0, 0);
          if(res){
           caml_call2(Stdlib_Queue[4], gen$0, state[1]);
           state[2] = 0;
           return res;
          }
          state[2] = 0;
         }
         break;
        case 2:
         if(caml_call1(Stdlib_Queue[14], state[1])){state[2] = 3; return 0;}
         var
          gen$1 = caml_call1(Stdlib_Queue[7], state[1]),
          res$0 = caml_call1(gen$1, 0);
         if(res$0){
          caml_call2(Stdlib_Queue[4], gen$1, state[1]);
          return res$0;
         }
         break;
        default: return 0;
      }
    }
    return next;
   }
   function intersection(opt, gen1, gen2){
    var
     cmp = opt ? opt[1] : caml_compare,
     x1 = [0, caml_call1(gen1, 0)],
     x2 = [0, caml_call1(gen2, 0)];
    function next(param){
     for(;;){
      var a = x1[1], match = x2[1];
      if(a && match){
       var y2 = match[1], y1 = a[1], c = caml_call2(cmp, y1, y2);
       if(0 === c){
        x1[1] = caml_call1(gen1, 0);
        x2[1] = caml_call1(gen2, 0);
        return [0, y1];
       }
       if(0 <= c){x2[1] = caml_call1(gen2, 0); continue;}
       x1[1] = caml_call1(gen1, 0);
       continue;
      }
      return 0;
     }
    }
    return next;
   }
   function sorted_merge(opt, gen1, gen2){
    var
     cmp = opt ? opt[1] : caml_compare,
     x1 = [0, caml_call1(gen1, 0)],
     x2 = [0, caml_call1(gen2, 0)];
    return function(param){
     var r = x1[1], match = x2[1];
     if(! r) return match ? (x2[1] = caml_call1(gen2, 0), match) : 0;
     var y1 = r[1];
     if(match){
      var y2 = match[1];
      return 0 < caml_call2(cmp, y1, y2)
              ? (x2[1] = caml_call1(gen2, 0), match)
              : (x1[1] = caml_call1(gen1, 0), r);
     }
     x1[1] = caml_call1(gen1, 0);
     return r;};
   }
   function empty$0(cmp){return [0, 0, cmp];}
   function is_empty$0(h){return h[1] ? 0 : 1;}
   function union(cmp, t1, t2){
    if(! t1) return t2;
    if(! t2) return t1;
    var
     r2 = t2[3],
     l2 = t2[2],
     x2 = t2[1],
     r1 = t1[3],
     l1 = t1[2],
     x1 = t1[1];
    return 0 < caml_call2(cmp, x1, x2)
            ? [0, x2, union(cmp, t1, r2), l2]
            : [0, x1, union(cmp, t2, r1), l1];
   }
   function insert(h, x){h[1] = union(h[2], [0, x, 0, 0], h[1]); return 0;}
   function pop(h){
    var match = h[1];
    if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var r = match[3], l = match[2], x = match[1];
    h[1] = union(h[2], l, r);
    return x;
   }
   function sorted_merge_n(opt, l){
    var cmp = opt ? opt[1] : caml_compare;
    function cmp$0(a, param){
     var v2 = param[1], v1 = a[1];
     return caml_call2(cmp, v1, v2);
    }
    var heap = empty$0(cmp$0);
    caml_call2
     (Stdlib_List[18],
      function(gen){
       var match = caml_call1(gen, 0);
       if(! match) return 0;
       var x = match[1];
       return insert(heap, [0, x, gen]);
      },
      l);
    return function(param){
     if(is_empty$0(heap)) return 0;
     var
      match = pop(heap),
      gen = match[2],
      x = match[1],
      match$0 = caml_call1(gen, 0);
     if(! match$0) return [0, x];
     var y = match$0[1];
     insert(heap, [0, y, gen]);
     return [0, x];};
   }
   function round_robin(opt, gen){
    var
     n = opt ? opt[1] : 2,
     qs =
       caml_call2
        (Stdlib_Array[1],
         n,
         function(param){return caml_call1(Stdlib_Queue[2], 0);}),
     cur = [0, 0],
     l =
       caml_call2
        (Stdlib_Array[16],
         function(i, param){
          return function(param){
           var q = caml_check_bound(qs, i)[i + 1];
           if(! caml_call1(Stdlib_Queue[14], q))
            return [0, caml_call1(Stdlib_Queue[7], q)];
           for(;;){
            var match = caml_call1(gen, 0);
            if(! match) return 0;
            var x = match[1], j = cur[1];
            cur[1] = runtime.caml_mod(j + 1 | 0, n);
            var q$0 = caml_check_bound(qs, j)[j + 1];
            if(j === i){
             if(caml_call1(Stdlib_Queue[14], q$0)) return [0, x];
             throw caml_maybe_attach_backtrace([0, Assert_failure, f], 1);
            }
            caml_call2(Stdlib_Queue[4], x, q$0);
           }};
         },
         qs);
    return caml_call1(Stdlib_Array[10], l);
   }
   function tee(opt, gen){
    var
     n = opt ? opt[1] : 2,
     qs =
       caml_call2
        (Stdlib_Array[1],
         n,
         function(param){return caml_call1(Stdlib_Queue[2], 0);}),
     finished = [0, 0],
     l =
       caml_call2
        (Stdlib_Array[16],
         function(i, param){
          return function(param){
           var b = caml_check_bound(qs, i)[i + 1];
           if(! caml_call1(Stdlib_Queue[14], b)){
            var c = caml_check_bound(qs, i)[i + 1];
            return caml_call1(Stdlib_Queue[7], c);
           }
           if(finished[1]) return 0;
           var res = caml_call1(gen, 0);
           if(! res){finished[1] = 1; return 0;}
           var a = n - 1 | 0, d = 0;
           if(a >= 0){
            var j = d;
            for(;;){
             if(j !== i){
              var e = caml_check_bound(qs, j)[j + 1];
              caml_call2(Stdlib_Queue[4], res, e);
             }
             var f = j + 1 | 0;
             if(a === j) break;
             j = f;
            }
           }
           return res;};
         },
         qs);
    return caml_call1(Stdlib_Array[10], l);
   }
   function interleave(gen_a, gen_b){
    var state = [0, [1, gen_a, gen_b, [0, 1]]];
    function next(param){
     for(;;){
      var match = state[1];
      if(typeof match === "number") return 0;
      if(0 === match[0]){
       var g = match[1], res = caml_call1(g, 0);
       return res ? res : (state[1] = 0, 0);
      }
      var
       r = match[3],
       g2 = match[2],
       g1 = match[1],
       res$0 = r[1] ? caml_call1(g1, 0) : caml_call1(g2, 0);
      if(res$0){r[1] = 1 - r[1]; return res$0;}
      var a = r[1] ? [0, g2] : [0, g1];
      state[1] = a;
     }
    }
    return next;
   }
   function intersperse(x, gen){
    var state = [0, 0];
    function next(param){
     for(;;){
      var match = state[1];
      if(typeof match !== "number"){
       if(0 !== match[0]){
        var res$2 = match[1];
        state[1] = [0, res$2];
        return [0, x];
       }
       var res$0 = match[1], res$1 = caml_call1(gen, 0);
       state[1] = res$1 ? [1, res$1] : 1;
       return res$0;
      }
      if(0 !== match) return 0;
      var res = caml_call1(gen, 0);
      if(! res){state[1] = 1; return 0;}
      state[1] = [0, res];
     }
    }
    return next;
   }
   function product(gena, genb){
    var all_a = [0, 0], all_b = [0, 0], cur = [0, -410787939];
    function next(param){
     for(;;){
      var match = cur[1];
      if(typeof match === "number")
       if(-410787939 === match){
        var match$0 = caml_call1(gena, 0);
        if(match$0){
         var a = match$0[1];
         all_a[1] = [0, a, all_a[1]];
         cur[1] = [0, 210423646, [0, a, all_b[1]]];
        }
        else
         cur[1] = -671547669;
       }
       else{
        if(926227490 <= match) return 0;
        var match$1 = caml_call1(genb, 0);
        if(match$1){
         var b = match$1[1];
         all_b[1] = [0, b, all_b[1]];
         cur[1] = [0, -470306651, [0, b, all_a[1]]];
        }
        else if(-671547669 === cur[1])
         cur[1] = 926227490;
        else
         cur[1] = -410787939;
       }
      else{
       var variant = match[1];
       if(210423646 <= variant){
        var c = match[2], match$2 = c[2], x = c[1];
        if(match$2){
         var l = match$2[2], y = match$2[1];
         cur[1] = [0, 210423646, [0, x, l]];
         return [0, [0, x, y]];
        }
        cur[1] = 585947014;
       }
       else{
        var d = match[2], match$3 = d[2], y$0 = d[1];
        if(match$3){
         var l$0 = match$3[2], x$0 = match$3[1];
         cur[1] = [0, -470306651, [0, y$0, l$0]];
         return [0, [0, x$0, y$0]];
        }
        cur[1] = -410787939;
       }
      }
     }
    }
    return next;
   }
   function group(opt, gen){
    var eq = opt ? opt[1] : caml_equal, match = caml_call1(gen, 0);
    if(! match) return function(param){return 0;};
    var x = match[1], cur = [0, [0, x, 0]];
    function next(param){
     for(;;){
      var next_x = 0 === cur[1] ? 0 : caml_call1(gen, 0), match = cur[1];
      if(! next_x) return match ? (cur[1] = 0, [0, match]) : 0;
      var x = next_x[1];
      if(match){
       var y = match[1];
       if(caml_call2(eq, x, y)){cur[1] = [0, x, cur[1]]; continue;}
      }
      cur[1] = [0, x, 0];
      return [0, match];
     }
    }
    return next;
   }
   function uniq(opt, gen){
    var eq = opt ? opt[1] : caml_equal, state = [0, 0];
    function next(param){
     for(;;){
      var match = state[1];
      if(typeof match === "number"){
       if(match) return 0;
       var res = caml_call1(gen, 0);
       if(res){var x = res[1]; state[1] = [0, x]; return res;}
       state[1] = 1;
       return 0;
      }
      var x$0 = match[1], res$0 = caml_call1(gen, 0);
      if(! res$0){state[1] = 1; return 0;}
      var y = res$0[1];
      if(! caml_call2(eq, x$0, y)){state[1] = [0, y]; return res$0;}
     }
    }
    return next;
   }
   function sort(opt, gen){
    var cmp = opt ? opt[1] : caml_compare, h = empty$0(cmp);
    for(;;){
     var match = caml_call1(gen, 0);
     if(! match) break;
     var x = match[1];
     insert(h, x);
    }
    return function(param){return is_empty$0(h) ? 0 : [0, pop(h)];};
   }
   function sort_uniq(opt, gen){
    var cmp = opt ? opt[1] : caml_compare;
    return uniq
            ([0, function(x, y){return 0 === caml_call2(cmp, x, y) ? 1 : 0;}],
             sort([0, cmp], gen));
   }
   function chunks(n, e){
    function next(param){
     var match = caml_call1(e, 0);
     if(! match) return 0;
     var x = match[1], a = caml_array_make(n, x), i = 1;
     for(;;){
      if(i === n) return [0, a];
      var match$0 = caml_call1(e, 0);
      if(! match$0) return [0, caml_call3(Stdlib_Array[6], a, 0, i)];
      var x$0 = match$0[1];
      caml_check_bound(a, i)[i + 1] = x$0;
      var i$0 = i + 1 | 0;
      i = i$0;
     }
    }
    return next;
   }
   function permutations(gen){
    function make_machine(n, l){
     if(! l){
      if(0 === n) return [0, 1];
      throw caml_maybe_attach_backtrace([0, Assert_failure, g], 1);
     }
     var
      tail = l[2],
      x = l[1],
      sub = make_machine(n - 1 | 0, tail),
      match = next(sub, 0);
     if(match)
      var l$0 = match[1], st = [0, [0, x, l$0, 0, n, sub]];
     else
      var st = 0;
     return [0, st];
    }
    function next(m, param){
     for(;;){
      var match = m[1];
      if(typeof match === "number") return match ? (m[1] = 0, h) : 0;
      var
       state = match[1],
       x = state[1],
       l = state[2],
       n = state[3],
       sub = state[5],
       len = state[4];
      if(n !== len){state[3] = state[3] + 1 | 0; return [0, insert(x, n, l)];}
      var match$0 = next(sub, 0);
      if(! match$0){m[1] = 0; return 0;}
      var l$0 = match$0[1];
      state[2] = l$0;
      state[3] = 0;
     }
    }
    function insert(x, n, l){
     if(0 === n) return [0, x, l];
     if(! l) throw caml_maybe_attach_backtrace([0, Assert_failure, i], 1);
     var tail = l[2], y = l[1];
     return [0, y, insert(x, n - 1 | 0, tail)];
    }
    var acc$0 = 0;
    for(;;){
     var match = caml_call1(gen, 0);
     if(! match) break;
     var x = match[1], acc = [0, x, acc$0];
     acc$0 = acc;
    }
    var a = make_machine(caml_call1(Stdlib_List[1], acc$0), acc$0);
    return function(b){return next(a, b);};
   }
   function permutations_heap(gen){
    var acc$0 = 0;
    for(;;){
     var match = caml_call1(gen, 0);
     if(! match) break;
     var x = match[1], acc = [0, x, acc$0];
     acc$0 = acc;
    }
    var a = caml_call1(Stdlib_Array[11], acc$0), n = a.length - 1;
    if(0 === n) return empty;
    var st = [0, a, n, l];
    return function(param){
     for(;;){
      var n = st[2];
      if(0 === n) break;
      var match$1 = st[3];
      if(! match$1) return 0;
      var i$0 = match$1[1], is$0 = match$1[2];
      if(i$0 === n){
       st[3] = is$0;
       st[2] = n + 1 | 0;
       var match$2 = st[3];
       if(! match$2) return 0;
       var
        is$1 = match$2[2],
        i$1 = match$2[1],
        j$0 = 1 === (st[2] % 2 | 0) ? 0 : i$1,
        tmp = caml_check_bound(st[1], j$0)[j$0 + 1],
        b = caml_check_bound(st[1], n)[n + 1];
       caml_check_bound(st[1], j$0)[j$0 + 1] = b;
       caml_check_bound(st[1], n)[n + 1] = tmp;
       st[3] = [0, i$1 + 1 | 0, is$1];
      }
      else{st[2] = n - 1 | 0; st[3] = [0, 0, st[3]];}
     }
     var match = st[3];
     if(match){
      if(0 === match[1]){
       var match$0 = match[2];
       if(match$0){
        var is = match$0[2], i = match$0[1];
        st[3] = [0, i + 1 | 0, is];
        st[2] = 1;
        return [0, caml_call1(Stdlib_Array[7], a)];
       }
      }
      if(match[2])
       throw caml_maybe_attach_backtrace([0, Assert_failure, j], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, k], 1);};
   }
   function combinations(n$0, gen){
    if(0 > n$0) throw caml_maybe_attach_backtrace([0, Assert_failure, n], 1);
    function make_state(n, l){
     if(0 === n) return [0, 1];
     if(! l) return [0, 0];
     var
      tail = l[2],
      x = l[1],
      m1 = make_state(n - 1 | 0, tail),
      m2 = make_state(n, tail);
     return [0, [0, x, m1, m2]];
    }
    function next(m$1, param){
     for(;;){
      var match = m$1[1];
      if(typeof match === "number") return 0 === match ? 0 : (m$1[1] = 0, m);
      if(0 !== match[0]){
       var m$0 = match[1], res = next(m$0, 0);
       return res ? res : (m$0[1] = 0, 0);
      }
      var m2 = match[3], m1 = match[2], x = match[1], match$0 = next(m1, 0);
      if(match$0){var l = match$0[1]; return [0, [0, x, l]];}
      m$1[1] = [1, m2];
     }
    }
    var acc$0 = 0;
    for(;;){
     var match = caml_call1(gen, 0);
     if(! match) break;
     var x = match[1], acc = [0, x, acc$0];
     acc$0 = acc;
    }
    var a = make_state(n$0, acc$0);
    return function(b){return next(a, b);};
   }
   function power_set(gen){
    function make_state(l){
     if(! l) return [0, 1];
     var tail = l[2], x = l[1], m = make_state(tail);
     return [0, [0, x, m]];
    }
    function next(m, param){
     var match = m[1];
     if(typeof match === "number") return 0 === match ? 0 : (m[1] = 0, o);
     if(0 !== match[0]){
      var m$1 = match[3], x$0 = match[2], l$0 = match[1];
      m[1] = [0, x$0, m$1];
      return [0, [0, x$0, l$0]];
     }
     var m$0 = match[2], x = match[1], res = next(m$0, 0);
     if(res){var l = res[1]; m[1] = [1, l, x, m$0]; return res;}
     m[1] = 0;
     return 0;
    }
    var acc$0 = 0;
    for(;;){
     var match = caml_call1(gen, 0);
     if(! match) break;
     var x = match[1], acc = [0, x, acc$0];
     acc$0 = acc;
    }
    var a = make_state(acc$0);
    return function(b){return next(a, b);};
   }
   function of_list(l){
    var l$0 = [0, l];
    return function(param){
     var match = l$0[1];
     if(! match) return 0;
     var l = match[2], x = match[1];
     l$0[1] = l;
     return [0, x];};
   }
   function to_rev_list(gen){
    var acc$0 = 0;
    for(;;){
     var match = caml_call1(gen, 0);
     if(! match) return acc$0;
     var x = match[1], acc = [0, x, acc$0];
     acc$0 = acc;
    }
   }
   function to_list(gen){
    var a = to_rev_list(gen);
    return caml_call1(Stdlib_List[10], a);
   }
   function to_array(gen){
    var l = to_rev_list(gen);
    if(! l) return [0];
    var
     a = caml_call1(Stdlib_Array[11], l),
     n = a.length - 1,
     b = (n - 1 | 0) / 2 | 0,
     e = 0;
    if(b >= 0){
     var i = e;
     for(;;){
      var tmp = caml_check_bound(a, i)[i + 1], c = (n - i | 0) - 1 | 0;
      a[i + 1] = caml_check_bound(a, c)[c + 1];
      var d = (n - i | 0) - 1 | 0;
      caml_check_bound(a, d)[d + 1] = tmp;
      var f = i + 1 | 0;
      if(b === i) break;
      i = f;
     }
    }
    return a;
   }
   function of_array(opt, len, a){
    var start = opt ? opt[1] : 0;
    if(len){
     var n = len[1];
     if((n + start | 0) >= a.length - 1)
      throw caml_maybe_attach_backtrace([0, Assert_failure, p], 1);
     var len$0 = n;
    }
    else
     var len$0 = a.length - 1 - start | 0;
    var i = [0, start];
    return function(param){
     if((start + len$0 | 0) <= i[1]) return 0;
     var b = i[1], x = caml_check_bound(a, b)[b + 1];
     i[1]++;
     return [0, x];};
   }
   function of_string(opt, len, s){
    var start = opt ? opt[1] : 0;
    if(len){
     var n = len[1];
     if((n + start | 0) >= caml_ml_string_length(s))
      throw caml_maybe_attach_backtrace([0, Assert_failure, q], 1);
     var len$0 = n;
    }
    else
     var len$0 = caml_ml_string_length(s) - start | 0;
    var i = [0, start];
    return function(param){
     if((start + len$0 | 0) <= i[1]) return 0;
     var x = caml_string_get(s, i[1]);
     i[1]++;
     return [0, x];};
   }
   function to_buffer(buf, g){
    return iter(caml_call1(Stdlib_Buffer[12], buf), g);
   }
   function to_string(s){
    var buf = caml_call1(Stdlib_Buffer[1], 16);
    to_buffer(buf, s);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function of_seq(seq){
    var seq$0 = [0, seq];
    return function(param){
     var match = caml_call1(seq$0[1], 0);
     if(! match) return 0;
     var tl = match[2], x = match[1];
     seq$0[1] = tl;
     return [0, x];};
   }
   function rand_int(i){
    return function(param){return [0, caml_call1(Stdlib_Random[5], i)];};
   }
   function int_range(opt, i, j){
    var step = opt ? opt[1] : 1;
    if(0 === step)
     throw caml_maybe_attach_backtrace([0, Stdlib[6], cst_Gen_int_range], 1);
    var
     symbol = 0 < step ? runtime.caml_greaterthan : caml_lessthan,
     r = [0, i];
    return function(param){
     var x = r[1];
     return symbol(x, j) ? 0 : (r[1] = r[1] + step | 0, [0, x]);};
   }
   function lines(g){
    var buf = caml_call1(Stdlib_Buffer[1], 32), stop = [0, 0];
    function next(param){
     for(;;){
      if(stop[1]) return 0;
      var match = caml_call1(g, 0);
      if(! match){
       stop[1] = 1;
       return 0 === caml_call1(Stdlib_Buffer[7], buf)
               ? 0
               : [0, caml_call1(Stdlib_Buffer[2], buf)];
      }
      var c = match[1];
      if(10 === c){
       var s = caml_call1(Stdlib_Buffer[2], buf);
       caml_call1(Stdlib_Buffer[8], buf);
       return [0, s];
      }
      caml_call2(Stdlib_Buffer[12], buf, c);
     }
    }
    return next;
   }
   function unlines(g){
    var st = [0, 870035731];
    return function(param){
     var match = st[1];
     if(typeof match === "number"){
      if(926227490 <= match) return 0;
      var match$0 = caml_call1(g, 0);
      if(match$0){
       var s$0 = match$0[1];
       return s$0 !== cst$3
               ? (st
                  [1]
                 = [0, -433348196, [0, s$0, 1]],
                 [0, caml_string_get(s$0, 0)])
               : r;
      }
      st[1] = 926227490;
      return 0;
     }
     var match$1 = match[2], s$1 = match$1[1], i = match$1[2];
     if(i === caml_ml_string_length(s$1)){st[1] = 870035731; return s;}
     var i$0 = match$1[2];
     st[1] = [0, -433348196, [0, s$1, i$0 + 1 | 0]];
     return [0, caml_string_get(s$1, i$0)];};
   }
   function pp(c, b, a, opt, pp_elem, formatter, gen){
    var
     start = c ? c[1] : cst$1,
     stop = b ? b[1] : cst$0,
     sep = a ? a[1] : cst,
     horizontal = opt ? opt[1] : 0;
    if(horizontal)
     caml_call2(Stdlib_Format[5], formatter, 0);
    else
     caml_call2(Stdlib_Format[9], formatter, 0);
    caml_call2(Stdlib_Format[13], formatter, start);
    var is_first = 1;
    for(;;){
     var match = caml_call1(gen, 0);
     if(! match){
      caml_call2(Stdlib_Format[13], formatter, stop);
      return caml_call2(Stdlib_Format[3], formatter, 0);
     }
     var x = match[1];
     if(is_first)
      caml_call2(pp_elem, formatter, x);
     else{
      caml_call2(Stdlib_Format[13], formatter, sep);
      caml_call2(Stdlib_Format[32], formatter, 0);
      caml_call2(pp_elem, formatter, x);
     }
     is_first = 0;
    }
   }
   function symbol(a, b){return int_range(t, a, b);}
   function symbol_bind(x, f){return flat_map(f, x);}
   function symbol_map(x, f){return map(f, x);}
   function symbol$0(x, f){return map(f, x);}
   var
    Infix = [0, symbol, symbol_bind, symbol_map, symbol$0],
    u = [0, cst_src_gen_ml, 1724, 4];
   function lift(f, e){return caml_call1(f, caml_call1(e, 0));}
   function lift2(f, e1, e2){
    var a = caml_call1(e2, 0);
    return caml_call2(f, caml_call1(e1, 0), a);
   }
   function empty$1(param){return empty;}
   function singleton$0(x, param){return singleton(x);}
   function iterate$0(x, f, param){return iterate(x, f);}
   function repeat$0(x, param){return function(param){return [0, x];};}
   function unfold$0(f, acc, param){return unfold(f, acc);}
   function init$0(limit, f, param){return init(limit, f);}
   function cycle(enum$){
    if(is_empty(caml_call1(enum$, 0)))
     throw caml_maybe_attach_backtrace([0, Assert_failure, u], 1);
    return function(param){
     var gen = [0, caml_call1(enum$, 0)];
     function next(param){
      for(;;){
       var res = caml_call1(gen[1], 0);
       if(res) return res;
       gen[1] = caml_call1(enum$, 0);
      }
     }
     return next;};
   }
   function is_empty$1(e){return is_empty(caml_call1(e, 0));}
   function fold$0(f, acc, e){return fold(f, acc, caml_call1(e, 0));}
   function reduce$0(f, e){return reduce(f, caml_call1(e, 0));}
   function scan$0(f, acc, e, param){return scan(f, acc, caml_call1(e, 0));}
   function unfold_scan$0(f, acc, e, param){
    return unfold_scan(f, acc, caml_call1(e, 0));
   }
   function iter$0(f, e){return iter(f, caml_call1(e, 0));}
   function iteri$0(f, e){return iteri(f, caml_call1(e, 0));}
   function length$0(e){return length(caml_call1(e, 0));}
   function map$0(f, e, param){return map(f, caml_call1(e, 0));}
   function mapi$0(f, e, param){var a = caml_call1(e, 0); return mapi(f)(a);}
   function fold_map$0(f, s, e, param){
    return fold_map(f, s, caml_call1(e, 0));
   }
   function append$0(e1, e2, param){
    var a = caml_call1(e2, 0);
    return append(caml_call1(e1, 0), a);
   }
   function flatten$0(e, param){return flatten(caml_call1(e, 0));}
   function flat_map$0(f, e, param){return flat_map(f, caml_call1(e, 0));}
   function mem$0(eq, x, e){return mem(eq, x, caml_call1(e, 0));}
   function take$0(n, e, param){return take(n, caml_call1(e, 0));}
   function drop$1(n, e, param){return drop$0(n, caml_call1(e, 0));}
   function nth$0(n, e){return nth(n, caml_call1(e, 0));}
   function take_nth$0(n, e, param){return take_nth(n, caml_call1(e, 0));}
   function filter$0(p, e, param){return filter(p, caml_call1(e, 0));}
   function take_while$0(p, e, param){return take_while(p, caml_call1(e, 0));}
   function fold_while$0(f, s, e){return fold_while(f, s, caml_call1(e, 0));}
   function drop_while$0(p, e, param){return drop_while(p, caml_call1(e, 0));}
   function filter_map$0(f, e, param){return filter_map(f, caml_call1(e, 0));}
   function zip_with$0(f, e1, e2, param){
    var a = caml_call1(e2, 0);
    return zip_with(f, caml_call1(e1, 0), a);
   }
   function zip$0(e1, e2, param){
    var a = caml_call1(e2, 0);
    return zip(caml_call1(e1, 0), a);
   }
   function zip_index$0(e, param){return zip_index(caml_call1(e, 0));}
   function unzip$0(e){
    function a(a){return a[2];}
    function b(a){return a[1];}
    return [0,
            function(a){return map$0(b, e, a);},
            function(b){return map$0(a, e, b);}];
   }
   function partition$0(p, e){
    function a(x){return 1 - caml_call1(p, x);}
    return [0,
            function(a){return filter$0(p, e, a);},
            function(b){return filter$0(a, e, b);}];
   }
   function for_all$0(p, e){return for_all(p, caml_call1(e, 0));}
   function exists$0(p, e){return exists(p, caml_call1(e, 0));}
   function for_all2$0(p, e1, e2){
    var a = caml_call1(e2, 0);
    return for_all2(p, caml_call1(e1, 0), a);
   }
   function exists2$0(p, e1, e2){
    var a = caml_call1(e2, 0);
    return exists2(p, caml_call1(e1, 0), a);
   }
   function map2$0(f, e1, e2, param){
    var a = caml_call1(e2, 0);
    return map2(f, caml_call1(e1, 0), a);
   }
   function iter2$0(f, e1, e2){
    var a = caml_call1(e2, 0);
    return iter2(f, caml_call1(e1, 0), a);
   }
   function fold2$0(f, acc, e1, e2){
    var a = caml_call1(e2, 0);
    return fold2(f, acc, caml_call1(e1, 0), a);
   }
   function min$0(lt, e){return min(lt, caml_call1(e, 0));}
   function max$0(lt, e){return max(lt, caml_call1(e, 0));}
   function eq$0(eq$0, e1, e2){
    var a = caml_call1(e2, 0);
    return eq(eq$0, caml_call1(e1, 0), a);
   }
   function lexico$0(cmp, e1, e2){
    var a = caml_call1(e2, 0);
    return lexico(cmp, caml_call1(e1, 0), a);
   }
   function compare$0(cmp, e1, e2){
    var gen2 = caml_call1(e2, 0), gen1 = caml_call1(e1, 0);
    return lexico(cmp, gen1, gen2);
   }
   function sum$0(e){return sum(caml_call1(e, 0));}
   function find$0(f, e){return find(f, caml_call1(e, 0));}
   function merge$0(e, param){return merge(caml_call1(e, 0));}
   function intersection$0(cmp, e1, e2, param){
    var a = caml_call1(e2, 0);
    return intersection(cmp, caml_call1(e1, 0), a);
   }
   function sorted_merge$0(cmp, e1, e2, param){
    var a = caml_call1(e2, 0);
    return sorted_merge(cmp, caml_call1(e1, 0), a);
   }
   function sorted_merge_n$0(cmp, l, param){
    return sorted_merge_n
            (cmp,
             caml_call2
              (Stdlib_List[20], function(g){return caml_call1(g, 0);}, l));
   }
   function tee$0(n, e){return tee(n, caml_call1(e, 0));}
   function round_robin$0(n, e){return round_robin(n, caml_call1(e, 0));}
   function interleave$0(e1, e2, param){
    var a = caml_call1(e2, 0);
    return interleave(caml_call1(e1, 0), a);
   }
   function intersperse$0(x, e, param){
    return intersperse(x, caml_call1(e, 0));
   }
   function product$0(e1, e2, param){
    var a = caml_call1(e2, 0);
    return product(caml_call1(e1, 0), a);
   }
   function group$0(eq, e, param){return group(eq, caml_call1(e, 0));}
   function uniq$0(eq, e, param){return uniq(eq, caml_call1(e, 0));}
   function sort$0(opt, enum$){
    var cmp = opt ? opt[1] : caml_compare;
    return function(param){return sort([0, cmp], caml_call1(enum$, 0));};
   }
   function sort_uniq$0(opt, e){
    var
     cmp = opt ? opt[1] : caml_compare,
     e$0 = sort$0([0, cmp], e),
     a = [0, function(x, y){return 0 === caml_call2(cmp, x, y) ? 1 : 0;}];
    return function(b){return uniq$0(a, e$0, b);};
   }
   function chunks$0(n, e, param){return chunks(n, caml_call1(e, 0));}
   function permutations$0(g, param){return permutations(caml_call1(g, 0));}
   function permutations_heap$0(g, param){
    return permutations_heap(caml_call1(g, 0));
   }
   function combinations$0(n, g, param){
    return combinations(n, caml_call1(g, 0));
   }
   function power_set$0(g, param){return power_set(caml_call1(g, 0));}
   function of_list$0(l, param){return of_list(l);}
   function to_rev_list$0(e){return to_rev_list(caml_call1(e, 0));}
   function to_list$0(e){return to_list(caml_call1(e, 0));}
   function to_array$0(e){return to_array(caml_call1(e, 0));}
   function of_array$0(start, len, a, param){return of_array(start, len, a);}
   function of_string$0(start, len, s, param){return of_string(start, len, s);
   }
   function to_string$0(s){return to_string(caml_call1(s, 0));}
   function to_buffer$0(buf, s){return to_buffer(buf, caml_call1(s, 0));}
   function to_iter(s, yield$){return iter$0(yield$, s);}
   function rand_int$0(i, param){return rand_int(i);}
   function int_range$0(step, i, j, param){return int_range(step, i, j);}
   function lines$0(g, param){return lines(caml_call1(g, 0));}
   function unlines$0(g, param){return unlines(caml_call1(g, 0));}
   function symbol$1(i, j, param){return int_range(step, i, j);}
   function symbol_bind$0(x, f){
    return function(a){return flat_map$0(f, x, a);};
   }
   function symbol_map$0(x, f){return function(a){return map$0(f, x, a);};}
   function symbol$2(x, f){return function(a){return map$0(f, x, a);};}
   var
    Infix$0 = [0, symbol$1, symbol_bind$0, symbol_map$0, symbol$2],
    cst_peek_n = "peek_n",
    v = [0, cst_src_gen_ml, 2050, 8],
    w = [0, cst_src_gen_ml, 2058, 4],
    x = [0, 3, [0, 1, 0]];
   function pp$0(start, stop, sep, horizontal, pp_elem, fmt, e){
    return pp(start, stop, sep, horizontal, pp_elem, fmt, caml_call1(e, 0));
   }
   function of_gen(caching, max_chunk_size, g){
    var cached = [0, 0];
    return function(param){
     var match = cached[1];
     if(match){var mlist = match[1]; return GenMList[3].call(null, mlist);}
     var mlist$0 = GenMList[2].call(null, max_chunk_size, caching, g);
     cached[1] = [0, mlist$0];
     return GenMList[3].call(null, mlist$0);};
   }
   function of_seq$0(seq){return function(param){return of_seq(seq);};}
   function start(g){return caml_call1(g, 0);}
   function persistent(gen){
    var l = GenMList[1].call(null, gen);
    return function(param){return GenMList[3].call(null, l);};
   }
   function persistent_to_seq(gen){
    var l = GenMList[1].call(null, gen);
    return GenMList[4].call(null, l);
   }
   function persistent_lazy(caching, max_chunk_size, gen){
    var l = GenMList[2].call(null, max_chunk_size, caching, gen);
    return function(param){return GenMList[3].call(null, l);};
   }
   function persistent_lazy_to_seq(caching, max_chunk_size, gen){
    var l = GenMList[2].call(null, max_chunk_size, caching, gen);
    return GenMList[4].call(null, l);
   }
   function to_iter$0(g, yield$){return iter(yield$, g);}
   function peek(g){
    var state = [0, 389604418];
    function next(param){
     for(;;){
      var match = state[1];
      if(typeof match !== "number"){
       var x$0 = match[2], res = caml_call1(g, 0);
       if(res){
        var y = res[1];
        state[1] = [0, 14611, y];
        return [0, [0, x$0, res]];
       }
       state[1] = 926227490;
       return [0, [0, x$0, 0]];
      }
      if(926227490 <= match) return 0;
      var match$0 = caml_call1(g, 0);
      if(! match$0){state[1] = 926227490; return 0;}
      var x = match$0[1];
      state[1] = [0, 14611, x];
     }
    }
    return next;
   }
   function queue_to_array(q){
    if(caml_call1(Stdlib_Queue[14], q)) return [0];
    var
     x = caml_call1(Stdlib_Queue[8], q),
     a = caml_array_make(caml_call1(Stdlib_Queue[15], q), x),
     i = [0, 0];
    caml_call2
     (Stdlib_Queue[16],
      function(x){
       var b = i[1];
       caml_check_bound(a, b)[b + 1] = x;
       i[1]++;
       return 0;
      },
      q);
    return a;
   }
   function peek_n(n, g){
    if(n < 1) caml_call1(Stdlib[1], cst_peek_n);
    var state = [0, 389604418], q = caml_call1(Stdlib_Queue[2], 0);
    function next(param){
     for(;;){
      var match = state[1];
      if(389604418 !== match) break;
      fill(n);
      var a = caml_call1(Stdlib_Queue[14], q) ? 926227490 : 192584839;
      state[1] = a;
     }
     if(926227490 <= match) return 0;
     if(caml_call1(Stdlib_Queue[14], q))
      throw caml_maybe_attach_backtrace([0, Assert_failure, v], 1);
     var x = caml_call1(Stdlib_Queue[7], q);
     fill(1);
     var b = caml_call1(Stdlib_Queue[14], q) ? 926227490 : 192584839;
     state[1] = b;
     return [0, [0, x, queue_to_array(q)]];
    }
    function fill(i$1){
     var i = i$1;
     for(;;){
      if((i + caml_call1(Stdlib_Queue[15], q) | 0) > n)
       throw caml_maybe_attach_backtrace([0, Assert_failure, w], 1);
      if(0 < i){
       var match = caml_call1(g, 0);
       if(match){
        var x = match[1];
        caml_call2(Stdlib_Queue[4], x, q);
        var i$0 = i - 1 | 0;
        i = i$0;
        continue;
       }
      }
      return;
     }
    }
    return next;
   }
   function with_file_in(a, opt, filename, f){
    var
     mode = a ? a[1] : 420,
     flags = opt ? opt[1] : 0,
     ic = caml_call3(Stdlib[81], flags, mode, filename);
    try{var x = caml_call1(f, ic); caml_call1(Stdlib[94], ic); return x;}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_call1(Stdlib[94], ic);
     throw caml_maybe_attach_backtrace(e, 0);
    }
   }
   function with_in(mode, flags, filename, f){
    return with_file_in
            (mode,
             flags,
             filename,
             function(ic){
              function next(param){
               try{var a = [0, caml_call1(Stdlib[82], ic)]; return a;}
               catch(exn$0){
                var exn = caml_wrap_exception(exn$0);
                if(exn === Stdlib[12]) return 0;
                throw caml_maybe_attach_backtrace(exn, 0);
               }
              }
              return caml_call1(f, next);
             });
   }
   function with_lines(mode, flags, filename, f){
    return with_file_in
            (mode,
             flags,
             filename,
             function(ic){
              function next(param){
               try{var a = [0, caml_call1(Stdlib[83], ic)]; return a;}
               catch(exn$0){
                var exn = caml_wrap_exception(exn$0);
                if(exn === Stdlib[12]) return 0;
                throw caml_maybe_attach_backtrace(exn, 0);
               }
              }
              return caml_call1(f, next);
             });
   }
   function with_file_out(a, opt, filename, f){
    var
     mode = a ? a[1] : 420,
     flags = opt ? opt[1] : x,
     oc = caml_call3(Stdlib[62], flags, mode, filename);
    try{var x$0 = caml_call1(f, oc); caml_call1(Stdlib[76], oc); return x$0;}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_call1(Stdlib[77], oc);
     throw caml_maybe_attach_backtrace(e, 0);
    }
   }
   function write_str(mode, flags, opt, filename, gen){
    var sep = opt ? opt[1] : cst$2;
    return with_file_out
            (mode,
             flags,
             filename,
             function(oc){
              var i$0 = 0;
              for(;;){
               var match = caml_call1(gen, 0);
               if(! match) return 0;
               var x = match[1];
               if(0 < i$0) caml_call2(Stdlib[66], oc, sep);
               caml_call2(Stdlib[66], oc, x);
               var i = i$0 + 1 | 0;
               i$0 = i;
              }
             });
   }
   function write(mode, flags, filename, gen){
    return with_file_out
            (mode,
             flags,
             filename,
             function(oc){
              for(;;){
               var match = caml_call1(gen, 0);
               if(! match) return 0;
               var x = match[1];
               caml_call2(Stdlib[65], oc, x);
              }
             });
   }
   function write_lines(mode, flags, filename, gen){
    return with_file_out
            (mode,
             flags,
             filename,
             function(oc){
              for(;;){
               var match = caml_call1(gen, 0);
               if(! match) return 0;
               var x = match[1];
               caml_call2(Stdlib[66], oc, x);
               caml_call2(Stdlib[65], oc, 10);
              }
             });
   }
   var
    Gen =
      [0,
       get,
       next,
       get_exn,
       junk,
       repeatedly,
       empty,
       singleton,
       singleton,
       repeat,
       iterate,
       unfold,
       init,
       is_empty,
       fold,
       reduce,
       scan,
       unfold_scan,
       iter,
       iteri,
       length,
       map,
       mapi,
       fold_map,
       append,
       flatten,
       flat_map,
       mem,
       take,
       drop$0,
       nth,
       take_nth,
       filter,
       take_while,
       fold_while,
       drop_while,
       filter_map,
       zip_index,
       unzip,
       partition,
       for_all,
       exists,
       min,
       max,
       eq,
       lexico,
       compare,
       find,
       sum,
       map2,
       iter2,
       fold2,
       for_all2,
       exists2,
       zip_with,
       zip,
       merge,
       intersection,
       sorted_merge,
       sorted_merge_n,
       tee,
       round_robin,
       interleave,
       intersperse,
       product,
       group,
       uniq,
       sort,
       sort_uniq,
       chunks,
       permutations,
       permutations_heap,
       combinations,
       power_set,
       of_list,
       to_list,
       to_rev_list,
       to_array,
       of_array,
       of_string,
       to_string,
       to_buffer,
       rand_int,
       int_range,
       lines,
       unlines,
       Infix,
       symbol,
       symbol_bind,
       symbol_map,
       symbol$0,
       pp,
       of_seq,
       to_iter$0,
       [0,
        empty$1,
        singleton$0,
        singleton$0,
        repeat$0,
        iterate$0,
        unfold$0,
        init$0,
        is_empty$1,
        fold$0,
        reduce$0,
        scan$0,
        unfold_scan$0,
        iter$0,
        iteri$0,
        length$0,
        map$0,
        mapi$0,
        fold_map$0,
        append$0,
        flatten$0,
        flat_map$0,
        mem$0,
        take$0,
        drop$1,
        nth$0,
        take_nth$0,
        filter$0,
        take_while$0,
        fold_while$0,
        drop_while$0,
        filter_map$0,
        zip_index$0,
        unzip$0,
        partition$0,
        for_all$0,
        exists$0,
        min$0,
        max$0,
        eq$0,
        lexico$0,
        compare$0,
        find$0,
        sum$0,
        map2$0,
        iter2$0,
        fold2$0,
        for_all2$0,
        exists2$0,
        zip_with$0,
        zip$0,
        merge$0,
        intersection$0,
        sorted_merge$0,
        sorted_merge_n$0,
        tee$0,
        round_robin$0,
        interleave$0,
        intersperse$0,
        product$0,
        group$0,
        uniq$0,
        sort$0,
        sort_uniq$0,
        chunks$0,
        permutations$0,
        permutations_heap$0,
        combinations$0,
        power_set$0,
        of_list$0,
        to_list$0,
        to_rev_list$0,
        to_array$0,
        of_array$0,
        of_string$0,
        to_string$0,
        to_buffer$0,
        rand_int$0,
        int_range$0,
        lines$0,
        unlines$0,
        Infix$0,
        symbol$1,
        symbol_bind$0,
        symbol_map$0,
        symbol$2,
        pp$0,
        of_seq$0,
        to_iter,
        cycle,
        lift,
        lift2,
        of_gen],
       persistent,
       persistent_lazy,
       persistent_to_seq,
       persistent_lazy_to_seq,
       peek,
       peek_n,
       start,
       [0, with_in, with_lines, write_str, write, write_lines]];
   runtime.caml_register_global(45, Gen, "Gen");
   return;
  }
  (globalThis));

//# unitInfo: Provides: GenLabels
//# unitInfo: Requires: Gen
//# shape: GenLabels:[F(1),F(1),F(1),F(1),F(2),F(1)*,F(1)*->F(1),F(1)*->F(1),F(2)*,F(2)*->F(1),F(2)*->F(1),F(2)*->F(1),F(1),F(3),F(2),F(3)*->F(1),F(3)*->F(1),F(2),F(2),F(1),F(2)*->F(1),F(1)*->F(1)*,F(3)*,F(2)*->F(1),F(1)*->F(1),F(2)*->F(1),F(3),F(2)->F(1),F(2)->F(1),F(2),F(2)->F(1),F(2)*->F(1),F(2)*->F(1),F(3),F(2)*->F(1),F(2)*->F(1),F(1)*->F(1),F(1),F(2),F(2),F(2),F(2),F(2),F(3),F(3),F(3),F(2),F(1),F(3)*->F(1),F(3),F(4),F(3),F(3),F(3)*->F(1),F(2)*,F(1)->F(1),F(3)->F(1),F(3)->F(1),F(2)->F(1),F(2),F(2),F(2)*->F(1),F(2)*->F(1),F(2)*->F(1),F(2)->F(1),F(2)*->F(1),F(2)->F(1),F(2),F(2)*->F(1),F(1)->F(1),F(1)->F(1),F(2)->F(1),F(1)->F(1),F(1)*->F(1),F(1),F(1),F(1),F(3)->F(1),F(3)->F(1),F(1),F(2),F(1)*->F(1),F(3)->F(1),F(1)->F(1),F(1)*->F(1),[F(2),F(2)*,F(2)*,F(2)*],F(2),F(2)*,F(2)*,F(2)*,F(7),F(1)*->F(1),F(2),N,F(1)->F(1)*,F(3)->F(1)*,F(1)*->F(1),F(2)->F(1),F(1),N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Gen = global_data.Gen,
    get = Gen[1],
    next = Gen[2],
    get_exn = Gen[3],
    junk = Gen[4],
    repeatedly = Gen[5],
    empty = Gen[6],
    singleton = Gen[7],
    return$ = Gen[8],
    repeat = Gen[9],
    iterate = Gen[10],
    unfold = Gen[11],
    init = Gen[12],
    is_empty = Gen[13],
    fold = Gen[14],
    reduce = Gen[15],
    scan = Gen[16],
    unfold_scan = Gen[17],
    iter = Gen[18],
    iteri = Gen[19],
    length = Gen[20],
    map = Gen[21],
    mapi = Gen[22],
    fold_map = Gen[23],
    append = Gen[24],
    flatten = Gen[25],
    flat_map = Gen[26],
    mem = Gen[27],
    take = Gen[28],
    drop = Gen[29],
    nth = Gen[30],
    take_nth = Gen[31],
    filter = Gen[32],
    take_while = Gen[33],
    fold_while = Gen[34],
    drop_while = Gen[35],
    filter_map = Gen[36],
    zip_index = Gen[37],
    unzip = Gen[38],
    partition = Gen[39],
    for_all = Gen[40],
    exists = Gen[41],
    min = Gen[42],
    max = Gen[43],
    eq = Gen[44],
    lexico = Gen[45],
    compare = Gen[46],
    find = Gen[47],
    sum = Gen[48],
    map2 = Gen[49],
    iter2 = Gen[50],
    fold2 = Gen[51],
    for_all2 = Gen[52],
    exists2 = Gen[53],
    zip_with = Gen[54],
    zip = Gen[55],
    merge = Gen[56],
    intersection = Gen[57],
    sorted_merge = Gen[58],
    sorted_merge_n = Gen[59],
    tee = Gen[60],
    round_robin = Gen[61],
    interleave = Gen[62],
    intersperse = Gen[63],
    product = Gen[64],
    group = Gen[65],
    uniq = Gen[66],
    sort = Gen[67],
    sort_uniq = Gen[68],
    chunks = Gen[69],
    permutations = Gen[70],
    permutations_heap = Gen[71],
    combinations = Gen[72],
    power_set = Gen[73],
    of_list = Gen[74],
    to_list = Gen[75],
    to_rev_list = Gen[76],
    to_array = Gen[77],
    of_array = Gen[78],
    of_string = Gen[79],
    to_string = Gen[80],
    to_buffer = Gen[81],
    rand_int = Gen[82],
    int_range = Gen[83],
    lines = Gen[84],
    unlines = Gen[85],
    Infix = Gen[86],
    symbol = Gen[87],
    symbol_bind = Gen[88],
    symbol_map = Gen[89],
    symbol$0 = Gen[90],
    pp = Gen[91],
    of_seq = Gen[92],
    to_iter = Gen[93],
    Restart = Gen[94],
    persistent = Gen[95],
    persistent_lazy = Gen[96],
    peek = Gen[99],
    peek_n = Gen[100],
    start = Gen[101],
    IO = Gen[102],
    GenLabels =
      [0,
       get,
       next,
       get_exn,
       junk,
       repeatedly,
       empty,
       singleton,
       return$,
       repeat,
       iterate,
       unfold,
       init,
       is_empty,
       fold,
       reduce,
       scan,
       unfold_scan,
       iter,
       iteri,
       length,
       map,
       mapi,
       fold_map,
       append,
       flatten,
       flat_map,
       mem,
       take,
       drop,
       nth,
       take_nth,
       filter,
       take_while,
       fold_while,
       drop_while,
       filter_map,
       zip_index,
       unzip,
       partition,
       for_all,
       exists,
       min,
       max,
       eq,
       lexico,
       compare,
       find,
       sum,
       map2,
       iter2,
       fold2,
       for_all2,
       exists2,
       zip_with,
       zip,
       merge,
       intersection,
       sorted_merge,
       sorted_merge_n,
       tee,
       round_robin,
       interleave,
       intersperse,
       product,
       group,
       uniq,
       sort,
       sort_uniq,
       chunks,
       permutations,
       permutations_heap,
       combinations,
       power_set,
       of_list,
       to_list,
       to_rev_list,
       to_array,
       of_array,
       of_string,
       to_string,
       to_buffer,
       rand_int,
       int_range,
       lines,
       unlines,
       Infix,
       symbol,
       symbol_bind,
       symbol_map,
       symbol$0,
       pp,
       of_seq,
       to_iter,
       [0,
        Restart[1],
        Restart[2],
        Restart[3],
        Restart[4],
        Restart[5],
        Restart[6],
        Restart[7],
        Restart[8],
        Restart[9],
        Restart[10],
        Restart[11],
        Restart[12],
        Restart[13],
        Restart[14],
        Restart[15],
        Restart[16],
        Restart[17],
        Restart[18],
        Restart[19],
        Restart[20],
        Restart[21],
        Restart[22],
        Restart[23],
        Restart[24],
        Restart[25],
        Restart[26],
        Restart[27],
        Restart[28],
        Restart[29],
        Restart[30],
        Restart[31],
        Restart[32],
        Restart[33],
        Restart[34],
        Restart[35],
        Restart[36],
        Restart[37],
        Restart[38],
        Restart[39],
        Restart[40],
        Restart[41],
        Restart[42],
        Restart[43],
        Restart[44],
        Restart[45],
        Restart[46],
        Restart[47],
        Restart[48],
        Restart[49],
        Restart[50],
        Restart[51],
        Restart[52],
        Restart[53],
        Restart[54],
        Restart[55],
        Restart[56],
        Restart[57],
        Restart[58],
        Restart[59],
        Restart[60],
        Restart[61],
        Restart[62],
        Restart[63],
        Restart[64],
        Restart[65],
        Restart[66],
        Restart[67],
        Restart[68],
        Restart[69],
        Restart[70],
        Restart[71],
        Restart[72],
        Restart[73],
        Restart[74],
        Restart[75],
        Restart[76],
        Restart[77],
        Restart[78],
        Restart[79],
        Restart[80],
        Restart[81],
        Restart[82],
        Restart[83],
        Restart[84],
        Restart[85],
        Restart[86],
        Restart[87],
        Restart[88],
        Restart[89],
        Restart[90],
        Restart[91]],
       persistent,
       persistent_lazy,
       peek,
       peek_n,
       start,
       IO];
   runtime.caml_register_global(1, GenLabels, "GenLabels");
   return;
  }
  (globalThis));

//# unitInfo: Provides: GenClone
//# unitInfo: Requires: CamlinternalOO, Stdlib
//# shape: GenClone:[F(1),F(2),[F(4)]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$2 = "",
    cst_clone = "clone",
    cst_gen = "gen",
    cst_prepend = "prepend",
    caml_get_cached_method = runtime.caml_get_cached_method,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_oo_cache_id = runtime.caml_oo_cache_id,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$2,
    cst$0 = cst$2,
    cst$1 = cst$2,
    b = [0, cst_gen, cst_clone],
    shared = [0, cst_clone, cst_gen],
    CamlinternalOO = global_data.CamlinternalOO,
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    cache_id = caml_oo_cache_id(),
    cache_id$0 = caml_oo_cache_id(),
    cache_id$1 = caml_oo_cache_id(),
    cache_id$2 = caml_oo_cache_id(),
    c = [],
    d = [0, cst_prepend, cst_gen, cst_clone],
    e = [0, cst_clone, cst_gen, cst_prepend],
    f = [0, "src/genClone.ml", 32, 19];
   function to_prependable(c$0){
    var
     g = caml_call1(caml_get_cached_method(c$0, 5144720, cache_id), c$0),
     st = [0, 3507667];
    function next(param){
     var match = st[1];
     if(typeof match === "number") return caml_call1(g, 0);
     var match$0 = match[2];
     if(! match$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, f], 1);
     var x = match$0[1];
     if(match$0[2]){
      var l = match$0[2];
      st[1] = [0, 73271853, l];
      return [0, x];
     }
     st[1] = 3507667;
     return [0, x];
    }
    var h = c[1];
    if(! h[1]){
     var
      a = caml_call1(CamlinternalOO[16], e),
      b = caml_call2(CamlinternalOO[3], a, cst),
      i = caml_call2(CamlinternalOO[8], a, d);
     caml_call2
      (CamlinternalOO[11],
       a,
       [0,
        i[2],
        function(self_2){var env = self_2[b + 1]; return env[3];},
        i[3],
        function(self_2){
         var env = self_2[b + 1], a = env[2];
         return to_prependable
                 (caml_call1
                   (caml_get_cached_method(a, -933031075, cache_id$0), a));
        },
        i[1],
        function(self_2, x){
         var env = self_2[b + 1], match = env[1][1];
         if(typeof match === "number")
          var a = [0, 73271853, [0, x, 0]];
         else
          var l = match[2], a = [0, 73271853, [0, x, l]];
         env[1][1] = a;
         return 0;
        }]);
     caml_call1(CamlinternalOO[17], a);
     h[1] =
      function(d){
       var c = caml_call2(CamlinternalOO[24], 0, a);
       c[b + 1] = d;
       return c;
      };
    }
    return caml_call1(h[1], [0, st, c$0, next]);
   }
   caml_update_dummy(c, [0, [0, 0, 0, 0]]);
   var letrec_function_context = [];
   function map(f, c){
    var g = caml_call1(caml_get_cached_method(c, 5144720, cache_id$1), c);
    function next(param){
     var match = caml_call1(g, 0);
     if(! match) return 0;
     var x = match[1];
     return [0, caml_call1(f, x)];
    }
    var d = letrec_function_context[1];
    if(! d[1]){
     var
      a = caml_call1(CamlinternalOO[16], shared),
      e = caml_call2(CamlinternalOO[3], a, cst$0),
      h = caml_call2(CamlinternalOO[8], a, b);
     caml_call2
      (CamlinternalOO[11],
       a,
       [0,
        h[1],
        function(self_3){var env = self_3[e + 1]; return env[3];},
        h[2],
        function(self_3){
         var
          env = self_3[e + 1],
          a = env[2],
          b = caml_call1(caml_get_cached_method(a, -933031075, cache_id$2), a);
         return map(env[1], b);
        }]);
     caml_call1(CamlinternalOO[17], a);
     d[1] =
      function(c){
       var b = caml_call2(CamlinternalOO[24], 0, a);
       b[e + 1] = c;
       return b;
      };
    }
    return caml_call1(d[1], [0, f, c, next]);
   }
   caml_update_dummy(letrec_function_context, [0, [0, 0, 0, 0]]);
   var a = [0, 0], cst_invalidated_iterator = "invalidated iterator";
   function with_in(c, opt, filename, f){
    var
     mode = c ? c[1] : 420,
     flags = opt ? opt[1] : 0,
     ic = caml_call3(Stdlib[81], flags, mode, filename),
     timestamp = [0, 0];
    function make(i){
     var state = [0, 675659445];
     function next(param){
      for(;;){
       var match = state[1];
       if(typeof match !== "number"){
        var t = match[2];
        if(t < timestamp[1]) caml_call1(Stdlib[2], cst_invalidated_iterator);
        try{var a = [0, caml_call1(Stdlib[82], ic)]; return a;}
        catch(exn$0){
         var exn = caml_wrap_exception(exn$0);
         if(exn === Stdlib[12]) return 0;
         throw caml_maybe_attach_backtrace(exn, 0);
        }
       }
       caml_call2(Stdlib[90], ic, i);
       timestamp[1]++;
       state[1] = [0, 40653089, timestamp[1]];
      }
     }
     if(! a[1]){
      var
       c = caml_call1(CamlinternalOO[16], shared),
       d = caml_call2(CamlinternalOO[3], c, cst$1),
       e = caml_call2(CamlinternalOO[8], c, b);
      caml_call2
       (CamlinternalOO[11],
        c,
        [0,
         e[2],
         function(self_4){
          var env = self_4[d + 1], i = caml_call1(Stdlib[91], env[2]);
          return caml_call1(env[3], i);
         },
         e[1],
         function(self_4){var env = self_4[d + 1]; return env[1];}]);
      caml_call1(CamlinternalOO[17], c);
      a[1] =
       function(b){
        var a = caml_call2(CamlinternalOO[24], 0, c);
        a[d + 1] = b;
        return a;
       };
     }
     return caml_call1(a[1], [0, next, ic, make]);
    }
    try{var x = caml_call1(f, make(0)); caml_call1(Stdlib[94], ic); return x;}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_call1(Stdlib[94], ic);
     throw caml_maybe_attach_backtrace(e, 0);
    }
   }
   var IO = [0, with_in], GenClone = [0, to_prependable, map, IO];
   runtime.caml_register_global(12, GenClone, "GenClone");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuLmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJnZW4uY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiR2VuX2ludGYiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxXQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsIkdlblNoaW1zIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQSx5QkFBQUMsV0FBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjMwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Imdlbi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJHZW5NX2ludGYiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxZQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NDMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZmFiaWFuLy5vcGFtL2RlZmF1bHQvbGliL2dlbi9nZW5NTGlzdC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIlxuKCogVGhpcyBmaWxlIGlzIGZyZWUgc29mdHdhcmUsIHBhcnQgb2YgZ2VuLiBTZWUgZmlsZSBcImxpY2Vuc2VcIiBmb3IgbW9yZSBkZXRhaWxzLiAqKVxuXG4oKiogezEgRWZmaWNpZW50IE11dGFibGUgTGlzdHN9ICopXG5cbnR5cGUgJ2EgZ2VuID0gdW5pdCAtPiAnYSBvcHRpb25cbnR5cGUgJ2EgaXRlciA9ICgnYSAtPiB1bml0KSAtPiB1bml0XG50eXBlICdhIGNsb25hYmxlID0gPFxuICBnZW4gOiAnYSBnZW47ICAoKiogR2VuZXJhdG9yIG9mIHZhbHVlcyB0aWVkIHRvIHRoaXMgY29weSAqKVxuICBjbG9uZSA6ICdhIGNsb25hYmxlOyAgKCoqIENsb25lIHRoZSBpbnRlcm5hbCBzdGF0ZSAqKVxuPlxuXG50eXBlICdhIG5vZGUgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgJ2EgYXJyYXkgKiBpbnQgcmVmICogJ2Egbm9kZSByZWZcbiAgfCBDb25zMSBvZiAnYSAqICdhIG5vZGUgcmVmXG4gIHwgU3VzcGVuZCBvZiAnYSBnZW5cblxudHlwZSAnYSB0ID0ge1xuICBzdGFydCA6ICdhIG5vZGUgcmVmOyAoKiBmaXJzdCBub2RlLiAqKVxuICBtdXRhYmxlIGNodW5rX3NpemUgOiBpbnQ7XG4gIG1heF9jaHVua19zaXplIDogaW50O1xufVxuXG5sZXQgX21ha2Ugfm1heF9jaHVua19zaXplIGdlbiA9IHtcbiAgc3RhcnQgPSByZWYgKFN1c3BlbmQgZ2VuKTtcbiAgY2h1bmtfc2l6ZSA9IDg7XG4gIG1heF9jaHVua19zaXplO1xufVxuXG5sZXQgX21ha2Vfbm9fYnVmZmVyIGdlbiA9IHtcbiAgc3RhcnQgPSByZWYgKFN1c3BlbmQgZ2VuKTtcbiAgY2h1bmtfc2l6ZSA9IDE7XG4gIG1heF9jaHVua19zaXplID0gMTtcbn1cblxuKCogaW5jcmVtZW50IHRoZSBzaXplIG9mIGNodW5rcyAqKVxubGV0IF9pbmNyX2NodW5rX3NpemUgbWxpc3QgPVxuICBpZiBtbGlzdC5jaHVua19zaXplIDwgbWxpc3QubWF4X2NodW5rX3NpemVcbiAgdGhlbiBtbGlzdC5jaHVua19zaXplIDwtIDIgKiBtbGlzdC5jaHVua19zaXplXG5cbigqIHJlYWQgb25lIGNodW5rIG9mIGlucHV0OyByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgbm9kZS5cbiAgIHdpbGwgcG90ZW50aWFsbHkgY2hhbmdlIFttbGlzdC5jaHVua19zaXplXS4gKilcbmxldCBfcmVhZF9jaHVuayBtbGlzdCBnZW4gPVxuICBtYXRjaCBnZW4oKSB3aXRoXG4gIHwgTm9uZSAtPiBOaWwgICgqIGRvbmUgKilcbiAgfCBTb21lIHggd2hlbiBtbGlzdC5tYXhfY2h1bmtfc2l6ZSA9IDEgLT5cbiAgICAgIGxldCB0YWlsID0gcmVmIChTdXNwZW5kIGdlbikgaW5cbiAgICAgIGxldCBub2RlID0gQ29uczEgKHgsIHRhaWwpIGluXG4gICAgICBub2RlXG4gIHwgU29tZSB4IC0+XG4gICAgICAoKiBuZXcgbGlzdCBub2RlICopXG4gICAgICBsZXQgciA9IHJlZiAxIGluXG4gICAgICBsZXQgYSA9IEFycmF5Lm1ha2UgbWxpc3QuY2h1bmtfc2l6ZSB4IGluXG4gICAgICBsZXQgdGFpbCA9IHJlZiAoU3VzcGVuZCBnZW4pIGluXG4gICAgICBsZXQgc3RvcCA9IHJlZiBmYWxzZSBpblxuICAgICAgbGV0IG5vZGUgPSBDb25zIChhLCByLCB0YWlsKSBpblxuICAgICAgKCogcmVhZCB0aGUgcmVzdCBvZiB0aGUgY2h1bmsgKilcbiAgICAgIHdoaWxlIG5vdCAhc3RvcCAmJiAhciA8IG1saXN0LmNodW5rX3NpemUgZG9cbiAgICAgICAgbWF0Y2ggZ2VuKCkgd2l0aFxuICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgIHRhaWwgOj0gTmlsO1xuICAgICAgICAgICAgc3RvcCA6PSB0cnVlXG4gICAgICAgIHwgU29tZSB4IC0+XG4gICAgICAgICAgICBhLighcikgPC0geDtcbiAgICAgICAgICAgIGluY3IgcjtcbiAgICAgIGRvbmU7XG4gICAgICBfaW5jcl9jaHVua19zaXplIG1saXN0O1xuICAgICAgbm9kZVxuXG4oKiBlYWdlciBjb25zdHJ1Y3Rpb24gKilcbmxldCBvZl9nZW4gZ2VuID1cbiAgbGV0IG1saXN0ID0gX21ha2Ugfm1heF9jaHVua19zaXplOjQwOTYgZ2VuIGluXG4gIGxldCByZWMgX2ZpbGwgcHJldiA9IG1hdGNoIF9yZWFkX2NodW5rIG1saXN0IGdlbiB3aXRoXG4gICAgfCBOaWwgLT4gcHJldiA6PSBOaWxcbiAgICB8IFN1c3BlbmQgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IENvbnMxIChfLCBwcmV2JykgYXMgbm9kZSAtPlxuICAgICAgICBwcmV2IDo9IG5vZGU7XG4gICAgICAgIF9maWxsIHByZXYnXG4gICAgfCBDb25zIChfLCBfLCBwcmV2JykgYXMgbm9kZSAtPlxuICAgICAgICBwcmV2IDo9IG5vZGU7XG4gICAgICAgIF9maWxsIHByZXYnXG4gIGluXG4gIF9maWxsIG1saXN0LnN0YXJ0O1xuICBtbGlzdFxuXG4oKiBsYXp5IGNvbnN0cnVjdGlvbiAqKVxubGV0IG9mX2dlbl9sYXp5ID8obWF4X2NodW5rX3NpemU9MjA0OCkgPyhjYWNoaW5nPXRydWUpIGdlbiA9XG4gIGlmIGNhY2hpbmdcbiAgdGhlblxuICAgIGxldCBtYXhfY2h1bmtfc2l6ZSA9IG1heCBtYXhfY2h1bmtfc2l6ZSAyIGluXG4gICAgX21ha2Ugfm1heF9jaHVua19zaXplIGdlblxuICBlbHNlIF9tYWtlX25vX2J1ZmZlciBnZW5cblxubGV0IHRvX2dlbiBsID1cbiAgbGV0IGN1ciA9IHJlZiBsLnN0YXJ0IGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgbGV0IHJlYyBuZXh0KCkgPSBtYXRjaCAhICFjdXIgd2l0aFxuICAgIHwgTmlsIC0+IE5vbmVcbiAgICB8IENvbnMxICh4LCBsJykgLT5cbiAgICAgICAgY3VyIDo9IGwnO1xuICAgICAgICBTb21lIHhcbiAgICB8IENvbnMgKGEsbixsJykgLT5cbiAgICAgICAgaWYgIWkgPSAhblxuICAgICAgICB0aGVuIGJlZ2luXG4gICAgICAgICAgY3VyIDo9IGwnO1xuICAgICAgICAgIGkgOj0gMDtcbiAgICAgICAgICBuZXh0KClcbiAgICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICBsZXQgeSA9IGEuKCFpKSBpblxuICAgICAgICAgIGluY3IgaTtcbiAgICAgICAgICBTb21lIHlcbiAgICAgICAgZW5kXG4gICAgfCBTdXNwZW5kIGdlbiAtPlxuICAgICAgICBsZXQgbm9kZSA9IF9yZWFkX2NodW5rIGwgZ2VuIGluXG4gICAgICAgICFjdXIgOj0gbm9kZTtcbiAgICAgICAgbmV4dCgpXG4gIGluXG4gIG5leHRcblxubGV0IHRvX3NlcSBsMCA6IF8gU2VxLnQgPVxuICBsZXQgcmVjIG5leHQgbCBpICgpPVxuICAgIG1hdGNoICFsIHdpdGhcbiAgICB8IE5pbCAtPiBTZXEuTmlsXG4gICAgfCBDb25zMSAoeCwgbCcpIC0+XG4gICAgICAgIFNlcS5Db25zICh4LCBuZXh0IGwnIGkpXG4gICAgfCBDb25zIChhLG4sbCcpIC0+XG4gICAgICAgIGlmIGkgPSAhbiB0aGVuIChcbiAgICAgICAgICBuZXh0IGwnIDAgKClcbiAgICAgICAgKSBlbHNlIChcbiAgICAgICAgICBsZXQgeSA9IGEuKGkpIGluXG4gICAgICAgICAgU2VxLkNvbnMgKHksIG5leHQgbCAoaSsxKSlcbiAgICAgICAgKVxuICAgIHwgU3VzcGVuZCBnZW4gLT5cbiAgICAgICAgbGV0IG5vZGUgPSBfcmVhZF9jaHVuayBsMCBnZW4gaW5cbiAgICAgICAgbCA6PSBub2RlOyAoKiBtb2RpZnkgcHJldmlvdXMgcG9pbnRlciAqKVxuICAgICAgICBuZXh0IGwgaSAoKVxuICBpblxuICBuZXh0IGwwLnN0YXJ0IDBcblxubGV0IHRvX2Nsb25hYmxlIGwgOiAnYSBjbG9uYWJsZSA9XG4gIGxldCByZWMgbWFrZSBub2RlIGkgPVxuICAgIGxldCBjdXIgPSByZWYgbm9kZSBhbmQgaSA9IHJlZiBpIGluXG4gICAgbGV0IHJlYyBuZXh0KCkgPSBtYXRjaCAhICFjdXIgd2l0aFxuICAgICAgfCBOaWwgLT4gTm9uZVxuICAgICAgfCBDb25zIChhLG4sbCcpIC0+XG4gICAgICAgICAgaWYgIWkgPSAhblxuICAgICAgICAgIHRoZW4gYmVnaW5cbiAgICAgICAgICAgIGN1ciA6PSBsJztcbiAgICAgICAgICAgIGkgOj0gMDtcbiAgICAgICAgICAgIG5leHQoKVxuICAgICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgICBsZXQgeSA9IGEuKCFpKSBpblxuICAgICAgICAgICAgaSA6PSAhaSsxO1xuICAgICAgICAgICAgU29tZSB5XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMxICh4LCBsJykgLT5cbiAgICAgICAgICBjdXIgOj0gbCc7XG4gICAgICAgICAgU29tZSB4XG4gICAgICB8IFN1c3BlbmQgZ2VuIC0+XG4gICAgICAgICAgbGV0IG5vZGUgPSBfcmVhZF9jaHVuayBsIGdlbiBpblxuICAgICAgICAgICghY3VyKSA6PSBub2RlO1xuICAgICAgICAgIG5leHQoKVxuICAgIGluXG4gICAgb2JqZWN0XG4gICAgICBtZXRob2QgZ2VuID0gbmV4dFxuICAgICAgbWV0aG9kIGNsb25lID0gbWFrZSAhY3VyICFpXG4gICAgZW5kXG4gIGluXG4gIG1ha2UgbC5zdGFydCAwXG5cblxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfY2xvbmUiLCJjc3RfZ2VuIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfbWF5YmVfYXR0YWNoX2JhY2t0cmFjZSIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJnbG9iYWxfZGF0YSIsImNzdCIsInNoYXJlZCIsIkNhbWxpbnRlcm5hbE9PIiwiU3RkbGliIiwiQXNzZXJ0X2ZhaWx1cmUiLCJtYWtlIiwibWF4X2NodW5rX3NpemUiLCJnZW4iLCJyZWFkX2NodW5rIiwibWxpc3QiLCJtYXRjaCIsIngiLCJ0YWlsIiwibm9kZSIsInIiLCJhIiwic3RvcCIsIm9mX2dlbiIsInByZXYiLCJvZl9nZW5fbGF6eSIsIm9wdCIsImNhY2hpbmciLCJ0b19nZW4iLCJsIiwiY3VyIiwiaSIsIm5leHQiLCJwYXJhbSIsIm4iLCJ5IiwidG9fc2VxIiwibDAiLCJ0b19jbG9uYWJsZSIsInNlbGZfMSIsImVudiIsIkdlbk1MaXN0Il0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBO0FBQUEsWUFBQUMsS0FBQUMsZ0JBQUFDO0FBQUFBLElDd0JnQztBQUFBLEdBSS9CO0FBQUEsWUFBQUMsV0FBQUMsT0FBQUY7QUFBQUEsUUFBQUcsUUFnQk87QUFBQSxJQUFLLFlBQ0Q7QUFBQSxRQUFBQyxJQURDO0FBQUEsSUFFRztBQUFBLFNBQUFDLE9BQ1YsZUFBQUMsT0FDQTtBQUFBLEtBQ0E7QUFBQTtBQUFBO0FBQUEsS0FBQUMsSUFHQTtBQUFBLEtBQUFDLElBQ1E7QUFBQSxLQUFBSCxTQUNSO0FBQUEsS0FBQUksT0FDQTtBQUFBLEtBQUFILFNBQ0E7QUFBQSxJQUVBO0FBQUE7QUFBQSxVQUFBSCxVQUNRO0FBQUEsTUFBSztBQUFBLFdBQUFDLE1BQUEsZ0JBS1A7QUFBQTtBQUFBLE9BQVc7QUFBQTtBQUFBO0FBQUEsTUFIWDtBQUFBLE1BQ0E7QUFBQTtBQUFBO0FBQUEsS0F4QlYsd0JBQ0s7QUFBQSxLQTRCcUI7QUFBQTtBQUFBLEdBQ2xCO0FBQUEsWUFBQU0sT0FBQVY7QUFBQUEsUUFBQUUsUUFJSSxpQkFBQVMsU0FXWixVQUFBQSxPQUFBO0FBQUE7QUFBQSxTQUFBTCxPQVYyQjtBQUFBLEtBQXFCLDZCQUNyQyxhQVNNO0FBQUEsS0FWK0I7QUFBQTtBQUFBLFlBQUFLLFNBQUEsU0FPMUMsZ0JBQ0E7QUFBQTtBQUFBLFlBQUFBLFNBUjBDLFNBSTFDLGdCQUNBO0FBQUEsZ0JBSFc7QUFBQTtBQUFBO0FBQUEsR0FTWjtBQUFBLFlBQUFDLFlBQUEsR0FBQUMsS0FBQWI7QUFBQUEsUUFBQUQsaUJBR1MsaUJBQUFlLFVBQUE7QUFBQSxJQUNkLGNBMUR3QjtBQUFBLFFBQUFmLG1CQTRERDtBQUFBLElBQ3JCLGtDQUNzQjtBQUFBO0FBQUEsWUFBQWdCLE9BQUFDO0FBQUFBLFFBQUFDLE1BR3hCLFdBQUFDLElBQ0E7QUFBQSxhQUFBQyxLQUFBQztBQUFBQSxLQUNpQjtBQUFBLFVBQUFqQixRQUFBO0FBQUEsb0NBQ047QUFBQSxNQURNO0FBQUE7QUFBQSxhQUFBYSxNQUFBLFVBQUFLLElBQUEsVUFBQWIsSUFBQTtBQUFBLFNBTVg7QUFBQSxrQkFLUyxNQUFBYyxJQUNDO0FBQUEsVUFDUjtBQUFBLFVBQ0E7QUFBQTtBQUFBLFNBUEc7QUFBQSxTQUVIO0FBQUE7QUFBQTtBQUFBLGFBQUFOLE1BVFMsVUFBQVosSUFBQSxVQUdYLGNBQ0E7QUFBQTtBQUFBLGFBQUFKLE1BSlcsVUFBQU0sT0FpQkEsb0JBQ1g7QUFBQTtBQUFBO0FBQUEsSUFDTTtBQUFBLElBRVo7QUFBQSxHQUFJO0FBQUEsWUFBQWlCLE9BQUFDO0FBQUFBLGFBQUFMLEtBQUFILEtBQUFFLEtBQUFFO0FBQUFBO0FBQUFBO0FBQUFBLFVBQUFKLElBSUYsS0FBQUUsSUFBQTtBQUFBO0FBQUE7QUFBQSxXQUFBZixRQUFBO0FBQUEscUNBQ1M7QUFBQSxPQURUO0FBQUE7QUFBQSxjQUFBYSxNQUFBLFVBQUFLLElBQUEsVUFBQWIsSUFBQTtBQUFBLFVBS0k7QUFBQSxVQUFlO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBQVIsTUFMbkIsVUFBQU0sT0FZZSxxQkFDWDtBQUFBO0FBQUE7QUFBQSxVQUFBVSxNQWJKLFVBQUFaLElBQUE7QUFBQSxNQUcwQiwwQkFBVCx5QkFBUztBQUFBO0FBQUEsU0FBQWtCLElBS1osbUNBQ0s7QUFBQSxLQUFZLDBCQUFaLHVCQUFZO0FBQUEsSUFLaEI7QUFBQSxZQUVqQjtBQUFBLHVCRDFJRixzQkMwSUU7QUFBQSxHQUFlO0FBQUEsV0QxSWpCO0FBQUEsWUFBQUcsWUFBQVQ7QUFBQUEsYUFBQWxCLEtBQUFRLE1BQUFZO0FBQUFBLFNBQUFELE1DOElJLFdBQUFDLE1BQUE7QUFBQSxjQUFBQyxLQUFBQztBQUFBQSxNQUNpQjtBQUFBLFdBQUFqQixRQUFBO0FBQUEscUNBQ047QUFBQSxPQURNO0FBQUE7QUFBQSxjQUFBYSxNQUFBLFVBQUFLLElBQUEsVUFBQWIsSUFBQTtBQUFBLFVBR1g7QUFBQSxtQkFLUyxRQUFBYyxJQUNDO0FBQUEsV0FDUjtBQUFBLFdBQ0E7QUFBQTtBQUFBLFVBUEc7QUFBQSxVQUVIO0FBQUE7QUFBQTtBQUFBLGNBQUFOLE1BTlMsVUFBQVosSUFBQSxVQWNYLGNBQ0E7QUFBQTtBQUFBLGNBQUFKLE1BZlcsVUFBQU0sT0FpQkEsb0JBQ1g7QUFBQTtBQUFBO0FBQUEsS0FDTTtBQUFBLEtBRVo7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxrQkFBQW9CLFlBQUFDLE1EcEtKLGVDcUttQjtBQUFBO0FBQUEsa0JBQUFEO0FBQUFBLGNBQUFDLE1EcktuQjtBQUFBLFVDc0txQjtBQUFBO0FBQUEsTUFGakI7QUFBQTtBQUFBO0FBQUEsZ0JEcEtKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQ29LSSxrREFHRztBQUFBO0FBQUEsSUFFTCxvQkFBYztBQUFBO0FBQUEsT0FBQUMsV0R6S2hCIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjQwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Imdlbi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2ZhYmlhbi8ub3BhbS9kZWZhdWx0L2xpYi9nZW4vZ2VuTS5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIlxuKCogVGhpcyBmaWxlIGlzIGZyZWUgc29mdHdhcmUsIHBhcnQgb2YgZ2VuLiBTZWUgZmlsZSBcImxpY2Vuc2VcIiBmb3IgbW9yZSBkZXRhaWxzLiAqKVxuXG4oKiogezEgTW9uYWRpYyBJbnRlcmZhY2V9ICopXG5cbm1vZHVsZSB0eXBlIE1PTkFEID0gR2VuTV9pbnRmLk1PTkFEXG5cbm1vZHVsZSBNYWtlKE0gOiBNT05BRCkgPSBzdHJ1Y3RcbiAgbW9kdWxlIE0gPSBNXG5cbiAgbGV0ICg+Pj0pID0gTS4oPj49KVxuICBsZXQgKD58PSkgPSBNLig+fD0pXG5cbiAgdHlwZSArJ2EgdCA9IHVuaXQgLT4gJ2Egb3B0aW9uIE0udFxuXG4gIGxldCByZXR1cm4geCA9XG4gICAgbGV0IGZpcnN0ID0gcmVmIHRydWUgaW5cbiAgICBmdW4gKCkgLT5cbiAgICAgIGlmICFmaXJzdCB0aGVuIChcbiAgICAgICAgZmlyc3QgOj0gZmFsc2U7XG4gICAgICAgIE0ucmV0dXJuIChTb21lIHgpXG4gICAgICApIGVsc2UgTS5yZXR1cm4gTm9uZVxuXG4gIGxldCBzZXF1ZW5jZV9tIGcgKCkgPSBtYXRjaCBnKCkgd2l0aFxuICAgIHwgTm9uZSAtPiBNLnJldHVybiBOb25lXG4gICAgfCBTb21lIGFjdCAtPlxuICAgICAgICBhY3QgPnw9IGZ1biB4IC0+IFNvbWUgeFxuXG4gIGxldCBtYXAgZiBnICgpID1cbiAgICBnKCkgPnw9IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgeCAtPiBTb21lIChmIHgpXG5cbiAgbGV0IGZsYXRfbWFwIGYgZyA9XG4gICAgbGV0IHJlYyBuZXh0IGYgZyAoKSA9XG4gICAgICBnKCkgPj49IGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gTS5yZXR1cm4gTm9uZSAoKiBkb25lICopXG4gICAgICB8IFNvbWUgeCAtPlxuICAgICAgICAgIGxldCBjdXIgPSBmIHggaW5cbiAgICAgICAgICBtYXBfZnJvbSBmIGcgY3VyICgpXG4gICAgYW5kIG1hcF9mcm9tIGYgZyBjdXIgKCkgPVxuICAgICAgbGV0IHJlcyA9IGN1cigpIGluXG4gICAgICByZXMgPj49IGZ1bmN0aW9uXG4gICAgICB8IE5vbmUgLT4gbmV4dCBmIGcgKClcbiAgICAgIHwgU29tZSBfIC0+IHJlc1xuICAgIGluXG4gICAgbmV4dCBmIGdcblxuICBsZXQgcmVjIGZvbGQgZiBhY2MgZyA9XG4gICAgZygpID4+PSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBNLnJldHVybiBhY2NcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgICBsZXQgYWNjID0gZiBhY2MgeCBpblxuICAgICAgICBmb2xkIGYgYWNjIGdcblxuICBsZXQgcmVjIGZvbGRfbSBmIGFjYyBnID1cbiAgICBnKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IE0ucmV0dXJuIGFjY1xuICAgIHwgU29tZSB4IC0+XG4gICAgICAgIGYgYWNjIHggPj49IGZ1biBhY2MgLT4gZm9sZF9tIGYgYWNjIGdcblxuICBsZXQgcmVjIGl0ZXIgZiBnID1cbiAgICBnKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IE0ucmV0dXJuICgpXG4gICAgfCBTb21lIHggLT4gZiB4OyBpdGVyIGYgZ1xuXG4gIGxldCByZWMgaXRlcl9zIGYgZyA9XG4gICAgZygpID4+PSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBNLnJldHVybiAoKVxuICAgIHwgU29tZSB4IC0+IGYgeCA+Pj0gZnVuICgpIC0+IGl0ZXJfcyBmIGdcblxuICBsZXQgcmVjIGl0ZXJfcCBmIGcgPVxuICAgIGcoKSA+Pj0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gTS5yZXR1cm4gKClcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgICBsZXQgXyA9IGYgeCBpblxuICAgICAgICBpdGVyX3AgZiBnXG5cbiAgbW9kdWxlIEluZml4ID0gc3RydWN0XG4gICAgbGV0ICg+fD0pIHggZiA9IG1hcCBmIHhcbiAgICBsZXQgKD4+PSkgeCBmID0gZmxhdF9tYXAgZiB4XG4gIGVuZFxuXG4gIGluY2x1ZGUgSW5maXhcbmVuZFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiR2VuTSIsIk0iLCJyZXR1cm4kIiwieCIsImZpcnN0IiwicGFyYW0iLCJzZXF1ZW5jZV9tIiwiZyIsIm1hdGNoIiwiYWN0IiwibWFwIiwiZmxhdF9tYXAiLCJuZXh0IiwiY3VyIiwibWFwX2Zyb20iLCJyZXMiLCJmb2xkIiwiYWNjIiwiZm9sZF9tIiwiaXRlciIsIml0ZXJfcyIsIml0ZXJfcCIsInN5bWJvbCIsInN5bWJvbF9iaW5kIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsZ0JBQUFDO0FBQUFBLFlBQUE7QUFBQSxpQkFBQUMsUUFBQUM7QUFBQUEsYUFBQUMsUUNnQkk7QUFBQSxTQUNBLGdCQUFBQztBQUFBQSxVQUNFO0FBQUEsbUNBRUU7QUFBQSxvQkFDSyxtQkFBYSxFQUp0QjtBQUFBLFFBSXNCO0FBQUEsaUJBQUFDLFdBQUFDLEdBQUFGO0FBQUFBLGFBQUFHLFFBRUk7QUFBQSxTQUFHLFlBQ25CLDBCQUVpQjtBQUFBLGFBQUFDLE1BSEU7QUFBQSxTQUd6QixtQ0FBQU4sR0FBaUIsY0FBTTtBQUFBO0FBQUEsaUJBQUFPLElBQUFkLEdBQUFXLEdBQUFGO0FBQUFBLFNBRzNCLE9BQUc7QUFBQTtBQUFBLGtCQUFIO0FBQUEsMkJBQUFBO0FBQUFBLG1CQUFRLFlBQ0U7QUFBQSx1QkFBQUYsSUFERjtBQUFBLG1CQUVTLDRCQUFLO0FBQUE7QUFBQTtBQUFBLGlCQUFBUSxTQUFBZixHQUFBVztBQUFBQSxrQkFBQUssS0FBQWhCLEdBQUFXLEdBQUFGO0FBQUFBLFVBSXBCLE9BQUc7QUFBQTtBQUFBLG1CQUFIO0FBQUEsNEJBQUFBO0FBQUFBLG9CQUFRLFlBQ0UsMEJBR2E7QUFBQSx3QkFBQUYsSUFKZixVQUFBVSxNQUdNO0FBQUEsb0JBQ1YsNkJBQW1CO0FBQUE7QUFBQTtBQUFBLGtCQUFBQyxTQUFBbEIsR0FBQVcsR0FBQU0sS0FBQVI7QUFBQUEsY0FBQVUsTUFFYjtBQUFBLFVBQ1Y7QUFBQTtBQUFBO0FBQUEsNEJBQUFWLE9BQVEscUJBQ0UsYUFDSztBQUFBO0FBQUEsU0FFakI7QUFBQSxRQUFRO0FBQUEsaUJBQUFXLEtBQUFwQixHQUFBcUIsS0FBQVY7QUFBQUEsU0FHUixPQUFHO0FBQUE7QUFBQSxrQkFBSDtBQUFBLDJCQUFBRjtBQUFBQSxtQkFBUSxZQUNFLDRCQUdNO0FBQUEsdUJBQUFGLElBSlIsVUFBQWMsUUFHTTtBQUFBLG1CQUNWLHdCQUFZO0FBQUE7QUFBQTtBQUFBLGlCQUFBQyxPQUFBdEIsR0FBQXFCLEtBQUFWO0FBQUFBLFNBR2hCLE9BQUc7QUFBQTtBQUFBLGtCQUFIO0FBQUEsMkJBQUFGO0FBQUFBLG1CQUFRLFlBQ0UsNEJBRStCO0FBQUEsdUJBQUFGLElBSGpDO0FBQUEsbUJBR0osT0FBTztBQUFBO0FBQUEsNEJBQVA7QUFBQSxxQ0FBQWMsS0FBdUIsd0JBQWM7QUFBQTtBQUFBO0FBQUEsaUJBQUFFLEtBQUF2QixHQUFBVztBQUFBQSxTQUd6QyxPQUFHO0FBQUE7QUFBQSxrQkFBSDtBQUFBLDJCQUFBRjtBQUFBQSxtQkFBUSxZQUNFLDBCQUNlO0FBQUEsdUJBQUFGLElBRmpCO0FBQUEsbUJBRUk7QUFBQSxtQkFBRyxpQkFBVTtBQUFBO0FBQUE7QUFBQSxpQkFBQWlCLE9BQUF4QixHQUFBVztBQUFBQSxTQUd6QixPQUFHO0FBQUE7QUFBQSxrQkFBSDtBQUFBLDJCQUFBRjtBQUFBQSxtQkFBUSxZQUNFLDBCQUM4QjtBQUFBLHVCQUFBRixJQUZoQztBQUFBLG1CQUVJLE9BQUc7QUFBQSwrQkFBSCwyQkFBQUUsT0FBa0IsbUJBQVU7QUFBQTtBQUFBO0FBQUEsaUJBQUFnQixPQUFBekIsR0FBQVc7QUFBQUEsU0FHeEMsT0FBRztBQUFBO0FBQUEsa0JBQUg7QUFBQSwyQkFBQUY7QUFBQUEsbUJBQVEsWUFDRSwwQkFHSTtBQUFBLHVCQUFBRixJQUpOO0FBQUEsbUJBR0k7QUFBQSxtQkFBRyxtQkFDRDtBQUFBO0FBQUE7QUFBQSxpQkFBQW1CLE9BQUFuQixHQUFBUCxHQUdFLHlDQUFPO0FBQUEsaUJBQUEyQixZQUFBcEIsR0FBQVAsR0FDUCxxQkFBWTtBQUFBLFFEaEZoQyIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM4MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJnZW4uY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiR2VuTGFiZWxzX2ludGYiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxpQkFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjM5NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJnZW4uY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9mYWJpYW4vLm9wYW0vZGVmYXVsdC9saWIvZ2VuL2dlbi5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIlxuKCogVGhpcyBmaWxlIGlzIGZyZWUgc29mdHdhcmUsIHBhcnQgb2YgZ2VuLiBTZWUgZmlsZSBcImxpY2Vuc2VcIiBmb3IgbW9yZSBkZXRhaWxzLiAqKVxuXG4oKiogezIgR2xvYmFsIHR5cGUgZGVjbGFyYXRpb25zfSAqKVxuXG50eXBlICdhIHQgPSB1bml0IC0+ICdhIG9wdGlvblxuXG50eXBlICdhIGdlbiA9ICdhIHRcblxubW9kdWxlIHR5cGUgUyA9IEdlbl9pbnRmLlNcblxuKCokaW5qZWN0XG4gIFtAQEBvY2FtbC53YXJuaW5nIFwiLTI2XCJdXG5cbiAgbGV0IHBpbnQgaSA9IHN0cmluZ19vZl9pbnQgaVxuICBsZXQgcGlsaXN0IGwgPVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAxNSBpblxuICAgIGxldCBmbXQgPSBGb3JtYXQuZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiJWFAP1wiXG4gICAgICAoR2VuLnBwIEZvcm1hdC5wcF9wcmludF9pbnQpIChHZW4ub2ZfbGlzdCBsKTtcbiAgICBCdWZmZXIuY29udGVudHMgYlxuICBsZXQgcGkybGlzdCBsID1cbiAgICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMTUgaW5cbiAgICBsZXQgZm10ID0gRm9ybWF0LmZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICAgIEZvcm1hdC5mcHJpbnRmIGZtdCBcIiVhQD9cIlxuICAgICAgKEdlbi5wcCAoZnVuIGZtdCAoYSxiKSAtPiBGb3JtYXQuZnByaW50ZiBmbXQgXCIlZCwlZFwiIGEgYikpXG4gICAgICAoR2VuLm9mX2xpc3QgbCk7XG4gICAgQnVmZmVyLmNvbnRlbnRzIGJcbiAgbGV0IHBzdHJsaXN0IGwgPVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAxNSBpblxuICAgIGxldCBmbXQgPSBGb3JtYXQuZm9ybWF0dGVyX29mX2J1ZmZlciBiIGluXG4gICAgRm9ybWF0LmZwcmludGYgZm10IFwiJWFAP1wiXG4gICAgICAoR2VuLnBwIEZvcm1hdC5wcF9wcmludF9zdHJpbmcpIChHZW4ub2ZfbGlzdCBsKTtcbiAgICBCdWZmZXIuY29udGVudHMgYlxuXG4qKVxuXG4oKiogezIgVHJhbnNpZW50IGdlbmVyYXRvcnN9ICopXG5cbmxldCBlbXB0eSAoKSA9IE5vbmVcblxuKCokVCBlbXB0eVxuICBlbXB0eSB8PiB0b19saXN0ID0gW11cbiopXG5cbmxldCBzaW5nbGV0b24geCA9XG4gIGxldCBmaXJzdCA9IHJlZiB0cnVlIGluXG4gIGZ1biAoKSAtPlxuICAgIGlmICFmaXJzdCB0aGVuIChmaXJzdCA6PSBmYWxzZTsgU29tZSB4KSBlbHNlIE5vbmVcblxuKCokVCBzaW5nbGV0b25cbiAgc2luZ2xldG9uIDEgfD4gdG9fbGlzdCA9IFsxXVxuICBzaW5nbGV0b24gXCJmb29cIiB8PiB0b19saXN0ID0gW1wiZm9vXCJdXG4qKVxuXG4oKiRSXG4gIGxldCBnZW4gPSBHZW4uc2luZ2xldG9uIDQyIGluXG4gIE9Vbml0LmFzc2VydF9lcXVhbCAoU29tZSA0MikgKEdlbi5nZXQgZ2VuKTtcbiAgT1VuaXQuYXNzZXJ0X2VxdWFsIE5vbmUgKEdlbi5nZXQgZ2VuKTtcbiAgbGV0IGdlbiA9IEdlbi5zaW5nbGV0b24gNDIgaW5cbiAgT1VuaXQuYXNzZXJ0X2VxdWFsIDEgKEdlbi5sZW5ndGggZ2VuKTtcbiopXG5cbmxldCByZXR1cm4gPSBzaW5nbGV0b25cblxubGV0IHJlcGVhdCB4ICgpID0gU29tZSB4XG5cbigqJFQgcmVwZWF0XG4gIHJlcGVhdCA0MiB8PiB0YWtlIDMgfD4gdG9fbGlzdCA9IFs0MjsgNDI7IDQyXVxuKilcblxubGV0IHJlcGVhdGVkbHkgZiAoKSA9IFNvbWUgKGYgKCkpXG5cbigqJFQgcmVwZWF0ZWRseVxuICByZXBlYXRlZGx5IChsZXQgciA9IHJlZiAwIGluIGZ1biAoKSAtPiBpbmNyIHI7ICFyKSBcXFxuICAgIHw+IHRha2UgNSB8PiB0b19saXN0ID0gWzE7MjszOzQ7NV1cbiopXG5cbmxldCBpdGVyYXRlIHggZiA9XG4gIGxldCBjdXIgPSByZWYgeCBpblxuICBmdW4gKCkgLT5cbiAgICBsZXQgeCA9ICFjdXIgaW5cbiAgICBjdXIgOj0gZiAhY3VyO1xuICAgIFNvbWUgeFxuXG4oKiRUIGl0ZXJhdGVcbiAgaXRlcmF0ZSAwICgoKykxKSB8PiB0YWtlIDUgfD4gdG9fbGlzdCA9IFswOzE7MjszOzRdXG4qKVxuXG5sZXQgbmV4dCBnZW4gPSBnZW4gKClcblxubGV0IGdldCBnZW4gPSBnZW4gKClcblxubGV0IGdldF9leG4gZ2VuID1cbiAgbWF0Y2ggZ2VuICgpIHdpdGhcbiAgfCBTb21lIHggLT4geFxuICB8IE5vbmUgLT4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJHZW4uZ2V0X2V4blwiKVxuXG4oKiRSIGdldF9leG5cbiAgbGV0IGcgPSBvZl9saXN0IFsxOzI7M10gaW5cbiAgYXNzZXJ0X2VxdWFsIDEgKGdldF9leG4gZyk7XG4gIGFzc2VydF9lcXVhbCAyIChnZXRfZXhuIGcpO1xuICBhc3NlcnRfZXF1YWwgMyAoZ2V0X2V4biBnKTtcbiAgYXNzZXJ0X3JhaXNlcyAoSW52YWxpZF9hcmd1bWVudCBcIkdlbi5nZXRfZXhuXCIpIChmdW4gKCkgLT4gZ2V0X2V4biBnKVxuKilcblxubGV0IGp1bmsgZ2VuID0gaWdub3JlIChnZW4gKCkpXG5cbmxldCByZWMgZm9sZCBmIGFjYyBnZW4gPVxuICBtYXRjaCBnZW4gKCkgd2l0aFxuICB8IE5vbmUgLT4gYWNjXG4gIHwgU29tZSB4IC0+IGZvbGQgZiAoZiBhY2MgeCkgZ2VuXG5cbigqJFFcbiAgKFEubGlzdCBRLnNtYWxsX2ludCkgKGZ1biBsIC0+IFxcXG4gICAgb2ZfbGlzdCBsIHw+IGZvbGQgKGZ1biBsIHgtPng6OmwpIFtdID0gTGlzdC5yZXYgbClcbiopXG5cbmxldCByZWR1Y2UgZiBnID1cbiAgbGV0IGFjYyA9IG1hdGNoIGcgKCkgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcInJlZHVjZVwiKVxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgZm9sZCBmIGFjYyBnXG5cbigqIER1YWwgb2YgeyFmb2xkfSwgd2l0aCBhIGRlY29uc3RydWN0aW5nIG9wZXJhdGlvbiAqKVxubGV0IHVuZm9sZCBmIGFjYyA9XG4gIGxldCBhY2MgPSByZWYgYWNjIGluXG4gIGZ1biAoKSAtPlxuICAgIG1hdGNoIGYgIWFjYyB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgKHgsIGFjYycpIC0+XG4gICAgICAgIGFjYyA6PSBhY2MnO1xuICAgICAgICBTb21lIHhcblxuKCokVCB1bmZvbGRcbiAgdW5mb2xkIChmdW4gKHByZXYsY3VyKSAtPiBTb21lIChwcmV2LCAoY3VyLHByZXYrY3VyKSkpICgwLDEpIFxcXG4gICAgfD4gdGFrZSA3IHw+IHRvX2xpc3QgPSBbMDsgMTsgMTsgMjsgMzsgNTsgOF1cbiopXG5cbmxldCBpbml0ID8obGltaXQ9bWF4X2ludCkgZiA9XG4gIGxldCByID0gcmVmIDAgaW5cbiAgZnVuICgpIC0+XG4gICAgaWYgIXIgPj0gbGltaXRcbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IGYgIXIgaW5cbiAgICAgIGxldCBfID0gaW5jciByIGluXG4gICAgICBTb21lIHhcblxuKCokVCBpbml0XG4gIGluaXQgfmxpbWl0OjUgKGZ1biBpLT5pKSB8PiB0b19saXN0ID0gWzA7MTsyOzM7NF1cbiopXG5cbmxldCByZWMgaXRlciBmIGdlbiA9XG4gIG1hdGNoIGdlbigpIHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSB4IC0+IGYgeDsgaXRlciBmIGdlblxuXG4oKiRSIGl0ZXJcbiAgbGV0IGUgPSBSZXN0YXJ0LigxIC0tIDEwKSBpblxuICBPVW5pdC5hc3NlcnRfZXF1YWwgfnByaW50ZXI6cGludCAxMCAoUmVzdGFydC5sZW5ndGggZSk7XG4gIE9Vbml0LmFzc2VydF9lcXVhbCBbMTsyXSBSZXN0YXJ0Lih0b19saXN0ICgxIC0tIDIpKTtcbiAgT1VuaXQuYXNzZXJ0X2VxdWFsIFsxOzI7Mzs0OzVdIChSZXN0YXJ0LnRvX2xpc3QgKFJlc3RhcnQudGFrZSA1IGUpKTtcbiAgKilcblxubGV0IGl0ZXJpIGYgZ2VuID1cbiAgbGV0IHJlYyBpdGVyaSBpID0gbWF0Y2ggZ2VuKCkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSB4IC0+IGYgaSB4OyBpdGVyaSAoaSsxKVxuICBpblxuICBpdGVyaSAwXG5cbmxldCBpc19lbXB0eSBnZW4gPSBtYXRjaCBnZW4gKCkgd2l0aFxuICB8IE5vbmUgLT4gdHJ1ZVxuICB8IFNvbWUgXyAtPiBmYWxzZVxuXG4oKiRUXG4gIGlzX2VtcHR5IGVtcHR5XG4gIG5vdCAoaXNfZW1wdHkgKHNpbmdsZXRvbiAyKSlcbiopXG5cbmxldCBsZW5ndGggZ2VuID1cbiAgZm9sZCAoZnVuIGFjYyBfIC0+IGFjYyArIDEpIDAgZ2VuXG5cbigqJFFcbiAgKFEubGlzdCBRLnNtYWxsX2ludCkgKGZ1biBsIC0+IFxcXG4gICAgb2ZfbGlzdCBsIHw+IGxlbmd0aCA9IExpc3QubGVuZ3RoIGwpXG4qKVxuXG4oKiB1c2VmdWwgc3RhdGUgKilcbm1vZHVsZSBSdW5TdGF0ZSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHwgSW5pdFxuICAgIHwgUnVuIG9mICdhXG4gICAgfCBTdG9wXG5lbmRcblxubGV0IHNjYW4gZiBhY2MgZyA9XG4gIGxldCBvcGVuIFJ1blN0YXRlIGluXG4gIGxldCBzdGF0ZSA9IHJlZiBJbml0IGluXG4gIGZ1biAoKSAtPlxuICAgIG1hdGNoICFzdGF0ZSB3aXRoXG4gICAgfCBJbml0IC0+XG4gICAgICAgIHN0YXRlIDo9IFJ1biBhY2M7XG4gICAgICAgIFNvbWUgYWNjXG4gICAgfCBTdG9wIC0+IE5vbmVcbiAgICB8IFJ1biBhY2MgLT5cbiAgICAgICAgbWF0Y2ggZygpIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHN0YXRlIDo9IFN0b3A7IE5vbmVcbiAgICAgICAgfCBTb21lIHggLT5cbiAgICAgICAgICAgIGxldCBhY2MnID0gZiBhY2MgeCBpblxuICAgICAgICAgICAgc3RhdGUgOj0gUnVuIGFjYyc7XG4gICAgICAgICAgICBTb21lIGFjYydcblxuKCokVCBzY2FuXG4gIHNjYW4gKGZ1biBhY2MgeCAtPiB4KzE6OmFjYykgW10gKDEtLTUpIHw+IHRvX2xpc3QgXFxcbiAgICA9IFtbXTsgWzJdOyBbMzsyXTsgWzQ7MzsyXTsgWzU7NDszOzJdOyBbNjs1OzQ7MzsyXV1cbiopXG5cbmxldCB1bmZvbGRfc2NhbiBmIGFjYyBnID1cbiAgbGV0IG9wZW4gUnVuU3RhdGUgaW5cbiAgbGV0IHN0YXRlID0gcmVmIChSdW4gYWNjKSBpblxuICBmdW4gKCkgLT5cbiAgICBtYXRjaCAhc3RhdGUgd2l0aFxuICAgIHwgSW5pdCAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IFN0b3AgLT4gTm9uZVxuICAgIHwgUnVuIGFjYyAtPlxuICAgICAgICBtYXRjaCBnKCkgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gc3RhdGUgOj0gU3RvcDsgTm9uZVxuICAgICAgICB8IFNvbWUgeCAtPlxuICAgICAgICAgICAgbGV0IGFjYycsIHkgPSBmIGFjYyB4IGluXG4gICAgICAgICAgICBzdGF0ZSA6PSBSdW4gYWNjJztcbiAgICAgICAgICAgIFNvbWUgeVxuXG4oKiRUIHVuZm9sZF9zY2FuXG4gIHVuZm9sZF9zY2FuIChmdW4gYWNjIHggLT4geCthY2MsYWNjKSAwICgxLS01KSB8PiB0b19saXN0IFxcXG4gICAgPSBbMDsgMTsgMzsgNjsgMTBdXG4qKVxuXG4oKiogezMgTGF6eX0gKilcblxubGV0IG1hcCBmIGdlbiA9XG4gIGxldCBzdG9wID0gcmVmIGZhbHNlIGluXG4gIGZ1biAoKSAtPlxuICAgIGlmICFzdG9wIHRoZW4gTm9uZVxuICAgIGVsc2UgbWF0Y2ggZ2VuKCkgd2l0aFxuICAgICAgfCBOb25lIC0+IHN0b3A6PSB0cnVlOyBOb25lXG4gICAgICB8IFNvbWUgeCAtPiBTb21lIChmIHgpXG5cbigqJFEgbWFwXG4gIChRLmxpc3QgUS5zbWFsbF9pbnQpIChmdW4gbCAtPiBcXFxuICAgIGxldCBmIHggPSB4KjIgaW4gXFxcbiAgICBvZl9saXN0IGwgfD4gbWFwIGYgfD4gdG9fbGlzdCA9IExpc3QubWFwIGYgbClcbiopXG5cbigqJFJcbiAgbGV0IGUgPSAxIC0tIDEwIGluXG4gIGxldCBlJyA9IGUgPj58IHN0cmluZ19vZl9pbnQgaW5cbiAgT1VuaXQuYXNzZXJ0X2VxdWFsIH5wcmludGVyOnBzdHJsaXN0IFtcIjlcIjsgXCIxMFwiXSAoR2VuLnRvX2xpc3QgKEdlbi5kcm9wIDggZScpKTtcbiopXG5cbmxldCBtYXBpIGYgPVxuICBsZXQgY250ID0gcmVmIDAgaW5cbiAgbGV0IGNudF9tYXAgeCA9XG4gICAgbGV0IGkgPSAhY250IGluIGNudCA6PSBpICsgMTsgZiBpIHggaW5cbiAgbWFwIGNudF9tYXBcblxuKCokUSBtYXBpXG4gIChRLmxpc3QgUS5zbWFsbF9pbnQpIChmdW4gbCAtPiBcXFxuICAgIGxldCBsZW4gPSBMaXN0Lmxlbmd0aCBsIGluIFxcXG4gICAgbGV0IGYgaSB4ID0gaSt4KzEgaW4gXFxcbiAgICBvZl9saXN0IGwgfD4gbWFwaSBmIHw+IHRvX2xpc3QgfD4gZnVuIGwnIC0+IExpc3QuZm9sZF9sZWZ0ICgrKSAwIGwnPSBcXFxuICAgICAgbGVuKihsZW4rMSkvMiArIExpc3QuZm9sZF9sZWZ0ICgrKSAwIGwpXG4qKVxuXG5sZXQgZm9sZF9tYXAgZiBzIGdlbiA9XG4gIG1hcCAobGV0IHN0YXRlID0gcmVmIHMgaW4gZnVuIHggLT4gc3RhdGUgOj0gZiAoIXN0YXRlKSB4OyAhc3RhdGUpIGdlblxuXG4oKiRUXG4gIGZvbGRfbWFwICgrKSAwICgxLS0zKSB8PiB0b19saXN0ID0gWzE7Mzs2XVxuKilcblxubGV0IGFwcGVuZCBnZW4xIGdlbjIgPVxuICBsZXQgZmlyc3QgPSByZWYgdHJ1ZSBpblxuICBmdW4gKCkgLT5cbiAgICBpZiAhZmlyc3RcbiAgICB0aGVuIG1hdGNoIGdlbjEoKSB3aXRoXG4gICAgICB8IChTb21lIF8pIGFzIHggLT4geFxuICAgICAgfCBOb25lIC0+IGZpcnN0Oj1mYWxzZTsgZ2VuMigpXG4gICAgZWxzZSBnZW4yKClcblxuKCokUVxuICAoUS5wYWlyIChRLmxpc3QgUS5zbWFsbF9pbnQpKFEubGlzdCBRLnNtYWxsX2ludCkpIChmdW4gKGwxLGwyKSAtPiBcXFxuICAgIGFwcGVuZCAob2ZfbGlzdCBsMSkgKG9mX2xpc3QgbDIpIHw+IHRvX2xpc3QgPSBsMSBAIGwyKVxuKilcblxuKCokUlxuICBsZXQgZSA9IEdlbi5hcHBlbmQgKDEgLS0gNSkgKDYgLS0gMTApIGluXG4gIE9Vbml0LmFzc2VydF9lcXVhbCBbMTA7OTs4Ozc7Njs1OzQ7MzsyOzFdIChHZW4udG9fcmV2X2xpc3QgZSk7XG4qKVxuXG5sZXQgZmxhdHRlbiBuZXh0X2dlbiA9XG4gIGxldCBvcGVuIFJ1blN0YXRlIGluXG4gIGxldCBzdGF0ZSA9IHJlZiBJbml0IGluXG4gICgqIGdldCBuZXh0IGVsZW1lbnQgKilcbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBtYXRjaCAhc3RhdGUgd2l0aFxuICAgIHwgSW5pdCAtPiBnZXRfbmV4dF9nZW4oKVxuICAgIHwgUnVuIGdlbiAtPlxuICAgICAgICBiZWdpbiBtYXRjaCBnZW4gKCkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBnZXRfbmV4dF9nZW4gKClcbiAgICAgICAgICB8IChTb21lIF8pIGFzIHggLT4geFxuICAgICAgICBlbmRcbiAgICB8IFN0b3AgLT4gTm9uZVxuICBhbmQgZ2V0X25leHRfZ2VuKCkgPSBtYXRjaCBuZXh0X2dlbigpIHdpdGhcbiAgICB8IE5vbmUgLT4gc3RhdGUgOj0gU3RvcDsgTm9uZVxuICAgIHwgU29tZSBnZW4gLT4gc3RhdGUgOj0gUnVuIGdlbjsgbmV4dCgpXG4gIGluXG4gIG5leHRcblxubGV0IGZsYXRfbWFwIGYgbmV4dF9lbGVtID1cbiAgbGV0IG9wZW4gUnVuU3RhdGUgaW5cbiAgbGV0IHN0YXRlID0gcmVmIEluaXQgaW5cbiAgbGV0IHJlYyBuZXh0KCkgPVxuICAgIG1hdGNoICFzdGF0ZSB3aXRoXG4gICAgfCBJbml0IC0+IGdldF9uZXh0X2dlbigpXG4gICAgfCBSdW4gZ2VuIC0+XG4gICAgICAgIGJlZ2luIG1hdGNoIGdlbiAoKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGdldF9uZXh0X2dlbiAoKVxuICAgICAgICAgIHwgKFNvbWUgXykgYXMgeCAtPiB4XG4gICAgICAgIGVuZFxuICAgIHwgU3RvcCAtPiBOb25lXG4gIGFuZCBnZXRfbmV4dF9nZW4oKSA9IG1hdGNoIG5leHRfZWxlbSgpIHdpdGhcbiAgICB8IE5vbmUgLT4gc3RhdGU6PVN0b3A7IE5vbmVcbiAgICB8IFNvbWUgeCAtPiBzdGF0ZSA6PSBSdW4gKGYgeCk7IG5leHQoKVxuICAgIHwgZXhjZXB0aW9uIGUgLT4gc3RhdGUgOj0gU3RvcDsgcmFpc2UgZVxuICBpblxuICBuZXh0XG5cbigqJFEgZmxhdF9tYXBcbiAgKFEubGlzdCBRLnNtYWxsX2ludCkgKGZ1biBsIC0+IFxcXG4gICAgbGV0IGYgeCA9IG9mX2xpc3QgW3g7eCoyXSBpbiBcXFxuICAgIGVxIChtYXAgZiAob2ZfbGlzdCBsKSB8PiBmbGF0dGVuKSAoZmxhdF9tYXAgZiAob2ZfbGlzdCBsKSkpXG4qKVxuXG4oKiRUXG4gIGZsYXRfbWFwIChmdW4geCAtPiBpZiB4IG1vZCAxXzUwMF8wMDA9MCB0aGVuIHNpbmdsZXRvbiB4IGVsc2UgZW1wdHkpICgxIC0tIDZfMDAwXzAwMCkgXFxcbiAgICB8PiB0b19saXN0ID0gWzFfNTAwXzAwMDsgM18wMDBfMDAwOyA0XzUwMF8wMDA7IDZfMDAwXzAwMF1cbiopXG5cbigqJFJcbiAgbGV0IGUgPSAxIC0tIDMgaW5cbiAgbGV0IGUnID0gZSA+Pj0gKGZ1biB4IC0+IHggLS0gKHgrMSkpIGluXG4gIE9Vbml0LmFzc2VydF9lcXVhbCBbMTsyOzI7MzszOzRdIChHZW4udG9fbGlzdCBlJyk7XG4qKVxuXG5sZXQgbWVtID8oZXE9KD0pKSB4IGdlbiA9XG4gIGxldCByZWMgbWVtIGVxIHggZ2VuID1cbiAgICBtYXRjaCBnZW4oKSB3aXRoXG4gICAgfCBTb21lIHkgLT4gZXEgeCB5IHx8IG1lbSBlcSB4IGdlblxuICAgIHwgTm9uZSAtPiBmYWxzZVxuICBpbiBtZW0gZXEgeCBnZW5cblxubGV0IHRha2UgbiBnZW4gPVxuICBhc3NlcnQgKG4gPj0gMCk7XG4gIGxldCBjb3VudCA9IHJlZiAwIGluICAoKiBob3cgbWFueSB5aWVsZGVkIGVsZW1lbnRzICopXG4gIGZ1biAoKSAtPlxuICAgIGlmICFjb3VudCA9IG4gfHwgIWNvdW50ID0gfi0xXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZSBtYXRjaCBnZW4oKSB3aXRoXG4gICAgICB8IE5vbmUgLT4gY291bnQgOj0gfi0xOyBOb25lICAgKCogaW5kaWNhdGUgc3RvcCAqKVxuICAgICAgfCAoU29tZSBfKSBhcyB4IC0+IGluY3IgY291bnQ7IHhcblxuKCokUVxuICAoUS5wYWlyIFEuc21hbGxfaW50IChRLmxpc3QgUS5zbWFsbF9pbnQpKSAoZnVuIChuLGwpIC0+IFxcXG4gICAgb2ZfbGlzdCBsIHw+IHRha2UgbiB8PiBsZW5ndGggPSBHZW5TaGltc18uU3RkbGliLm1pbiBuIChMaXN0Lmxlbmd0aCBsKSlcbiopXG5cbigqIGNhbGwgW2dlbl0gYXQgbW9zdCBbbl0gdGltZXMsIGFuZCBzdG9wICopXG5sZXQgcmVjIF9fZHJvcCBuIGdlbiA9XG4gIGlmIG4gPSAwIHRoZW4gKClcbiAgZWxzZSBtYXRjaCBnZW4oKSB3aXRoXG4gICAgfCBTb21lIF8gLT4gX19kcm9wIChuLTEpIGdlblxuICAgIHwgTm9uZSAtPiAoKVxuXG5sZXQgZHJvcCBuIGdlbiA9XG4gIGFzc2VydCAobiA+PSAwKTtcbiAgbGV0IGRyb3BwZWQgPSByZWYgZmFsc2UgaW5cbiAgZnVuICgpIC0+XG4gICAgaWYgIWRyb3BwZWRcbiAgICB0aGVuIGdlbigpXG4gICAgZWxzZSBiZWdpblxuICAgICAgKCogZHJvcCBbbl0gZWxlbWVudHMgYW5kIHlpZWxkIHRoZSBuZXh0IGVsZW1lbnQgKilcbiAgICAgIGRyb3BwZWQgOj0gdHJ1ZTtcbiAgICAgIF9fZHJvcCBuIGdlbjtcbiAgICAgIGdlbigpXG4gICAgZW5kXG5cbigqJFFcbiAgKFEucGFpciBRLnNtYWxsX2ludCAoUS5saXN0IFEuc21hbGxfaW50KSkgKGZ1biAobixsKSAtPiBcXFxuICAgIGxldCBnMSxnMiA9IHRha2UgbiAob2ZfbGlzdCBsKSwgZHJvcCBuIChvZl9saXN0IGwpIGluIFxcXG4gICAgYXBwZW5kIGcxIGcyIHw+IHRvX2xpc3QgPSBsKVxuKilcblxubGV0IG50aCBuIGdlbiA9XG4gIGFzc2VydCAobj49MCk7XG4gIF9fZHJvcCBuIGdlbjtcbiAgbWF0Y2ggZ2VuICgpIHdpdGhcbiAgfCBOb25lIC0+IHJhaXNlIE5vdF9mb3VuZFxuICB8IFNvbWUgeCAtPiB4XG5cbigqJD0gbnRoICYgfnByaW50ZXI6c3RyaW5nX29mX2ludFxuICA0IChudGggNCAoMC0tMTApKVxuICA4IChudGggOCAoMC0tMTApKVxuKilcblxuKCokVFxuICAodHJ5IGlnbm9yZSAobnRoIDExICgxLS0xMCkpOyBmYWxzZSB3aXRoIE5vdF9mb3VuZCAtPiB0cnVlKVxuKilcblxubGV0IHRha2VfbnRoIG4gZ2VuID1cbiAgYXNzZXJ0IChuPj0xKTtcbiAgbGV0IGkgPSByZWYgbiBpblxuICBsZXQgcmVjIG5leHQoKSA9XG4gICAgbWF0Y2ggZ2VuKCkgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCAoU29tZSBfKSBhcyByZXMgd2hlbiAhaSA9IG4gLT4gaTo9MTsgcmVzXG4gICAgfCBTb21lIF8gLT4gaW5jciBpOyBuZXh0KClcbiAgaW4gbmV4dFxuXG5sZXQgZmlsdGVyIHAgZ2VuID1cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICAoKiB3cmFwIGV4Y2VwdGlvbiBpbnRvIG9wdGlvbiwgZm9yIG5leHQgdG8gYmUgdGFpbHJlYyAqKVxuICAgIG1hdGNoIGdlbigpIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgKFNvbWUgeCkgYXMgcmVzIC0+XG4gICAgICAgIGlmIHAgeFxuICAgICAgICB0aGVuIHJlcyAoKiB5aWVsZCBlbGVtZW50ICopXG4gICAgICAgIGVsc2UgbmV4dCAoKSAgKCogZGlzY2FyZCBlbGVtZW50ICopXG4gIGluIG5leHRcblxuKCokVFxuICBmaWx0ZXIgKGZ1biB4IC0+eCBtb2QgMiA9IDApICgxLS0xMCkgfD4gdG9fbGlzdCA9IFsyOzQ7Njs4OzEwXVxuKilcblxubGV0IHRha2Vfd2hpbGUgcCBnZW4gPVxuICBsZXQgc3RvcCA9IHJlZiBmYWxzZSBpblxuICBmdW4gKCkgLT5cbiAgICBpZiAhc3RvcFxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgbWF0Y2ggZ2VuKCkgd2l0aFxuICAgICAgfCAoU29tZSB4KSBhcyByZXMgLT5cbiAgICAgICAgICBpZiBwIHggdGhlbiByZXMgZWxzZSAoc3RvcCA6PSB0cnVlOyBOb25lKVxuICAgICAgfCBOb25lIC0+IHN0b3A6PXRydWU7IE5vbmVcblxuKCokVFxuICB0YWtlX3doaWxlIChmdW4geCAtPng8MTApICgxLS0xMDAwKSB8PiBlcSAoMS0tOSlcbiopXG5cbmxldCBmb2xkX3doaWxlIGYgcyBnZW4gPVxuICBsZXQgc3RhdGUgPSByZWYgcyBpblxuICBsZXQgcmVjIGNvbnN1bWUgZ2VuID0gbWF0Y2ggZ2VuKCkgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSB4IC0+XG4gICAgICAgIGxldCBhY2MsIGNvbnQgPSBmICFzdGF0ZSB4IGluXG4gICAgICAgIHN0YXRlIDo9IGFjYztcbiAgICAgICAgbWF0Y2ggY29udCB3aXRoXG4gICAgICAgIHwgYFN0b3AgLT4gKClcbiAgICAgICAgfCBgQ29udGludWUgLT4gY29uc3VtZSBnZW5cbiAgaW5cbiAgY29uc3VtZSBnZW47XG4gICFzdGF0ZVxuXG4oKiRUXG4gIGZvbGRfd2hpbGUgKGZ1biBhY2MgYiAtPiBpZiBiIHRoZW4gYWNjKzEsIGBDb250aW51ZSBlbHNlIGFjYywgYFN0b3ApIDAgXFxcbiAgICAob2ZfbGlzdCBbdHJ1ZTt0cnVlO2ZhbHNlO3RydWVdKSA9IDJcbiopXG5cbm1vZHVsZSBEcm9wV2hpbGVTdGF0ZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgU3RvcFxuICAgIHwgRHJvcFxuICAgIHwgWWllbGRcbmVuZFxuXG4oKiBzdGF0ZSBtYWNoaW5lIHN0YXJ0cyBhdCBEcm9wOlxuICAgIERyb3A6XG4gICAgICAtIElmIG5leHQgZWxlbWVudCBkb2Vzbid0IHNhdGlzZnkgcHJlZGljYXRlLCBnb3RvIHlpZWxkXG4gICAgICAtIGlmIG5vIG1vcmUgZWxlbWVudHMsIGdvdG8gc3RvcFxuICAgIFlpZWxkOlxuICAgICAgLSBpZiB0aGVyZSBpcyBhIG5leHQgZWxlbWVudCwgeWllbGQgaXRcbiAgICAgIC0gaWYgbm8gbW9yZSBlbGVtZW50cywgZ290byBzdG9wXG4gICAgU3RvcDoganVzdCByZXR1cm4gTm9uZVxuKilcbmxldCBkcm9wX3doaWxlIHAgZ2VuID1cbiAgbGV0IG9wZW4gRHJvcFdoaWxlU3RhdGUgaW5cbiAgbGV0IHN0YXRlID0gcmVmIERyb3AgaW5cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBtYXRjaCAhc3RhdGUgd2l0aFxuICAgIHwgU3RvcCAtPiBOb25lXG4gICAgfCBEcm9wIC0+XG4gICAgICAgIGJlZ2luIG1hdGNoIGdlbiAoKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IHN0YXRlIDo9IFN0b3A7IE5vbmVcbiAgICAgICAgICB8IChTb21lIHgpIGFzIHJlcyAtPlxuICAgICAgICAgICAgICBpZiBwIHggdGhlbiBuZXh0KCkgZWxzZSAoc3RhdGU6PVlpZWxkOyByZXMpXG4gICAgICAgIGVuZFxuICAgIHwgWWllbGQgLT5cbiAgICAgICAgYmVnaW4gbWF0Y2ggZ2VuICgpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gc3RhdGUgOj0gU3RvcDsgTm9uZVxuICAgICAgICAgIHwgU29tZSBfIGFzIHJlcyAtPiByZXNcbiAgICAgICAgZW5kXG4gIGluIG5leHRcblxuKCokVFxuICBkcm9wX3doaWxlIChmdW4geC0+IHg8MTApICgxLS0yMCkgfD4gZXEgKDEwLS0yMClcbiopXG5cbmxldCBmaWx0ZXJfbWFwIGYgZ2VuID1cbiAgKCogdGFpbHJlYyAqKVxuICBsZXQgcmVjIG5leHQgKCkgPVxuICAgIG1hdGNoIGdlbigpIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSB4IC0+XG4gICAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBuZXh0KClcbiAgICAgICAgfCAoU29tZSBfKSBhcyByZXMgLT4gcmVzXG4gIGluIG5leHRcblxuKCokVFxuICBmaWx0ZXJfbWFwIChmdW4geC0+IGlmIHggbW9kIDIgPSAwIHRoZW4gU29tZSAoc3RyaW5nX29mX2ludCB4KSBlbHNlIE5vbmUpICgxLS0xMCkgXFxcbiAgICB8PiB0b19saXN0ID0gTGlzdC5tYXAgc3RyaW5nX29mX2ludCBbMjs0OzY7ODsxMF1cbiopXG5cbigqJFJcbiAgbGV0IGYgeCA9IGlmIHggbW9kIDIgPSAwIHRoZW4gU29tZSAoc3RyaW5nX29mX2ludCB4KSBlbHNlIE5vbmUgaW5cbiAgbGV0IGUgPSBHZW4uZmlsdGVyX21hcCBmICgxIC0tIDEwKSBpblxuICBPVW5pdC5hc3NlcnRfZXF1YWwgW1wiMlwiOyBcIjRcIjsgXCI2XCI7IFwiOFwiOyBcIjEwXCJdIChHZW4udG9fbGlzdCBlKTtcbiopXG5cbmxldCB6aXBfaW5kZXggZ2VuID1cbiAgbGV0IHIgPSByZWYgfi0xIGluXG4gIGZ1biAoKSAtPlxuICAgIG1hdGNoIGdlbigpIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZVxuICAgIHwgU29tZSB4IC0+XG4gICAgICAgIGluY3IgcjtcbiAgICAgICAgU29tZSAoIXIsIHgpXG5cbigqJFRcbiAgemlwX2luZGV4ICgxLS01KSB8PiB0b19saXN0ID0gWzAsMTsgMSwyOyAyLDM7IDMsNDsgNCw1XVxuKilcblxubGV0IHVuemlwIGdlbiA9XG4gIGxldCBzdG9wID0gcmVmIGZhbHNlIGluXG4gIGxldCBxMSA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICBsZXQgcTIgPSBRdWV1ZS5jcmVhdGUgKCkgaW5cbiAgbGV0IG5leHRfbGVmdCAoKSA9XG4gICAgaWYgUXVldWUuaXNfZW1wdHkgcTFcbiAgICB0aGVuIGlmICFzdG9wIHRoZW4gTm9uZVxuICAgICAgZWxzZSBtYXRjaCBnZW4oKSB3aXRoXG4gICAgICAgIHwgU29tZSAoeCx5KSAtPlxuICAgICAgICAgICAgUXVldWUucHVzaCB5IHEyO1xuICAgICAgICAgICAgU29tZSB4XG4gICAgICAgIHwgTm9uZSAtPiBzdG9wIDo9IHRydWU7IE5vbmVcbiAgICBlbHNlIFNvbWUgKFF1ZXVlLnBvcCBxMSlcbiAgaW5cbiAgbGV0IG5leHRfcmlnaHQgKCkgPVxuICAgIGlmIFF1ZXVlLmlzX2VtcHR5IHEyXG4gICAgdGhlbiBpZiAhc3RvcCB0aGVuIE5vbmVcbiAgICAgIGVsc2UgbWF0Y2ggZ2VuKCkgd2l0aFxuICAgICAgICB8IFNvbWUgKHgseSkgLT5cbiAgICAgICAgICAgIFF1ZXVlLnB1c2ggeCBxMTtcbiAgICAgICAgICAgIFNvbWUgeVxuICAgICAgICB8IE5vbmUgLT4gc3RvcCA6PSB0cnVlOyBOb25lXG4gICAgZWxzZSBTb21lIChRdWV1ZS5wb3AgcTIpXG4gIGluXG4gIG5leHRfbGVmdCwgbmV4dF9yaWdodFxuXG4oKiRUXG4gIHVuemlwIChvZl9saXN0IFsxLDI7Myw0XSkgfD4gKGZ1biAoeCx5KS0+IHRvX2xpc3QgeCwgdG9fbGlzdCB5KSBcXFxuICAgID0gKFsxOzNdLCBbMjs0XSlcbiopXG5cbigqJFFcbiAgKFEubGlzdCAoUS5wYWlyIFEuc21hbGxfaW50IFEuc21hbGxfaW50KSkgKGZ1biBsIC0+IFxcXG4gICAgb2ZfbGlzdCBsIHw+IHVuemlwIHw+IChmdW4gKHgseSkgLT4gdG9fbGlzdCB4LHRvX2xpc3QgeSkgPSBcXFxuICAgIExpc3Quc3BsaXQgbClcbiopXG5cbigqIFtwYXJ0aXRpb24gcCBsXSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IHNhdGlzZnkgW3BdLFxuICAgYW5kIHRoZSBlbGVtZW50cyB0aGF0IGRvIG5vdCBzYXRpc2Z5IFtwXSAqKVxubGV0IHBhcnRpdGlvbiBwIGdlbiA9XG4gIGxldCBxdHJ1ZSA9IFF1ZXVlLmNyZWF0ZSAoKSBpblxuICBsZXQgcWZhbHNlID0gUXVldWUuY3JlYXRlICgpIGluXG4gIGxldCBzdG9wID0gcmVmIGZhbHNlIGluXG4gIGxldCByZWMgbmV4dHRydWUgKCkgPVxuICAgIGlmIFF1ZXVlLmlzX2VtcHR5IHF0cnVlXG4gICAgdGhlbiBpZiAhc3RvcCB0aGVuIE5vbmVcbiAgICAgIGVsc2UgbWF0Y2ggZ2VuKCkgd2l0aFxuICAgICAgICB8IChTb21lIHgpIGFzIHJlcyAtPlxuICAgICAgICAgICAgaWYgcCB4IHRoZW4gcmVzIGVsc2UgKFF1ZXVlLnB1c2ggeCBxZmFsc2U7IG5leHR0cnVlKCkpXG4gICAgICAgIHwgTm9uZSAtPiBzdG9wOj10cnVlOyBOb25lXG4gICAgZWxzZSBTb21lIChRdWV1ZS5wb3AgcXRydWUpXG4gIGFuZCBuZXh0ZmFsc2UoKSA9XG4gICAgaWYgUXVldWUuaXNfZW1wdHkgcWZhbHNlXG4gICAgdGhlbiBpZiAhc3RvcCB0aGVuIE5vbmVcbiAgICAgIGVsc2UgbWF0Y2ggZ2VuKCkgd2l0aFxuICAgICAgICB8IChTb21lIHgpIGFzIHJlcyAtPlxuICAgICAgICAgICAgaWYgcCB4IHRoZW4gKFF1ZXVlLnB1c2ggeCBxdHJ1ZTsgbmV4dGZhbHNlKCkpIGVsc2UgcmVzXG4gICAgICAgIHwgTm9uZSAtPiBzdG9wOj0gdHJ1ZTsgTm9uZVxuICAgIGVsc2UgU29tZSAoUXVldWUucG9wIHFmYWxzZSlcbiAgaW5cbiAgbmV4dHRydWUsIG5leHRmYWxzZVxuXG4oKiRUXG4gIHBhcnRpdGlvbiAoZnVuIHggLT4geCBtb2QgMiA9IDApICgxLS0xMCkgfD4gXFxcbiAgICAoZnVuICh4LHkpLT50b19saXN0IHgsIHRvX2xpc3QgeSkgPSAoWzI7NDs2Ozg7MTBdLCBbMTszOzU7Nzs5XSlcbiopXG5cbmxldCByZWMgZm9yX2FsbCBwIGdlbiA9XG4gIG1hdGNoIGdlbigpIHdpdGhcbiAgfCBOb25lIC0+IHRydWVcbiAgfCBTb21lIHggLT4gcCB4ICYmIGZvcl9hbGwgcCBnZW5cblxubGV0IHJlYyBleGlzdHMgcCBnZW4gPVxuICBtYXRjaCBnZW4oKSB3aXRoXG4gIHwgTm9uZSAtPiBmYWxzZVxuICB8IFNvbWUgeCAtPiBwIHggfHwgZXhpc3RzIHAgZ2VuXG5cbmxldCBtaW4gPyhsdD1mdW4geCB5IC0+IHggPCB5KSBnZW4gPVxuICBsZXQgZmlyc3QgPSBtYXRjaCBnZW4gKCkgd2l0aFxuICAgIHwgU29tZSB4IC0+IHhcbiAgICB8IE5vbmUgLT4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJtaW5cIilcbiAgaW5cbiAgZm9sZCAoZnVuIG1pbiB4IC0+IGlmIGx0IHggbWluIHRoZW4geCBlbHNlIG1pbikgZmlyc3QgZ2VuXG5cbigqJFRcbiAgbWluIChvZl9saXN0IFsxOzQ7NjswOzExOyAtMl0pID0gfi0yXG4gICh0cnkgaWdub3JlIChtaW4gZW1wdHkpOyBmYWxzZSB3aXRoIEludmFsaWRfYXJndW1lbnQgXyAtPiB0cnVlKVxuKilcblxubGV0IG1heCA/KGx0PWZ1biB4IHkgLT4geCA8IHkpIGdlbiA9XG4gIGxldCBmaXJzdCA9IG1hdGNoIGdlbiAoKSB3aXRoXG4gICAgfCBTb21lIHggLT4geFxuICAgIHwgTm9uZSAtPiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIm1heFwiKVxuICBpblxuICBmb2xkIChmdW4gbWF4IHggLT4gaWYgbHQgbWF4IHggdGhlbiB4IGVsc2UgbWF4KSBmaXJzdCBnZW5cblxuKCokVFxuICBtYXggKG9mX2xpc3QgWzE7NDs2OzA7MTE7IC0yXSkgPSAxMVxuICAodHJ5IGlnbm9yZSAobWF4IGVtcHR5KTsgZmFsc2Ugd2l0aCBJbnZhbGlkX2FyZ3VtZW50IF8gLT4gdHJ1ZSlcbiopXG5cbmxldCBlcSA/KGVxPSg9KSkgZ2VuMSBnZW4yID1cbiAgbGV0IHJlYyBjaGVjayAoKSA9XG4gICAgbWF0Y2ggZ2VuMSgpLCBnZW4yKCkgd2l0aFxuICAgIHwgTm9uZSwgTm9uZSAtPiB0cnVlXG4gICAgfCBTb21lIHgxLCBTb21lIHgyIHdoZW4gZXEgeDEgeDIgLT4gY2hlY2sgKClcbiAgICB8IF8gLT4gZmFsc2VcbiAgaW5cbiAgY2hlY2sgKClcblxuKCokUVxuICAoUS5wYWlyIChRLmxpc3QgUS5zbWFsbF9pbnQpKFEubGlzdCBRLnNtYWxsX2ludCkpIChmdW4gKGwxLGwyKSAtPiBcXFxuICAgIGVxIChvZl9saXN0IGwxKShvZl9saXN0IGwyKSA9IChsMSA9IGwyKSlcbiopXG5cbmxldCBsZXhpY28gPyhjbXA9R2VuU2hpbXNfLlN0ZGxpYi5jb21wYXJlKSBnZW4xIGdlbjIgPVxuICBsZXQgcmVjIGxleGljbyAoKSA9XG4gICAgbWF0Y2ggZ2VuMSgpLCBnZW4yKCkgd2l0aFxuICAgIHwgTm9uZSwgTm9uZSAtPiAwXG4gICAgfCBTb21lIHgxLCBTb21lIHgyIC0+XG4gICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZSBsZXhpY28gKClcbiAgICB8IFNvbWUgXywgTm9uZSAtPiAxXG4gICAgfCBOb25lLCBTb21lIF8gLT4gLTFcbiAgaW4gbGV4aWNvICgpXG5cbmxldCBjb21wYXJlID9jbXAgZ2VuMSBnZW4yID0gbGV4aWNvID9jbXAgZ2VuMSBnZW4yXG5cbigqJFFcbiAgKFEucGFpciAoUS5saXN0IFEuc21hbGxfaW50KShRLmxpc3QgUS5zbWFsbF9pbnQpKSAoZnVuIChsMSxsMikgLT4gXFxcbiAgICBsZXQgc2lnbiB4ID0gaWYgeCA8IDAgdGhlbiAtMSBlbHNlIGlmIHg9MCB0aGVuIDAgZWxzZSAxIGluIFxcXG4gICAgc2lnbiAoY29tcGFyZSAob2ZfbGlzdCBsMSkob2ZfbGlzdCBsMikpID0gc2lnbiAoR2VuU2hpbXNfLlN0ZGxpYi5jb21wYXJlIGwxIGwyKSlcbiopXG5cbmxldCByZWMgZmluZCBwIGUgPSBtYXRjaCBlICgpIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHggd2hlbiBwIHggLT4gU29tZSB4XG4gIHwgU29tZSBfIC0+IGZpbmQgcCBlXG5cbigqJFRcbiAgIGZpbmQgKGZ1biB4IC0+IHg+PTUpICgxLS0xMCkgPSBTb21lIDVcbiAgIGZpbmQgKGZ1biB4IC0+IHg+NSkgKDEtLTQpID0gTm9uZVxuKilcblxubGV0IHN1bSBlID1cbiAgbGV0IHJlYyBzdW0gYWNjID0gbWF0Y2ggZSgpIHdpdGhcbiAgICB8IE5vbmUgLT4gYWNjXG4gICAgfCBTb21lIHggLT4gc3VtICh4K2FjYylcbiAgaW4gc3VtIDBcblxuKCokVFxuICBzdW0gKDEtLTEwKSA9IDU1XG4qKVxuXG4oKiogezIgTXVsdGlwbGUgSXRlcmF0b3JzfSAqKVxuXG5sZXQgbWFwMiBmIGUxIGUyID1cbiAgZnVuICgpIC0+IG1hdGNoIGUxKCksIGUyKCkgd2l0aFxuICAgIHwgU29tZSB4LCBTb21lIHkgLT4gU29tZSAoZiB4IHkpXG4gICAgfCBfIC0+IE5vbmVcblxuKCokVFxuICBtYXAyICgrKSAoMS0tNSkgKDEtLTQpIHw+IGVxIChvZl9saXN0IFsyOzQ7Njs4XSlcbiAgbWFwMiAoKykgKDEtLTUpIChyZXBlYXQgMCkgfD4gZXEgKDEtLTUpXG4qKVxuXG5sZXQgcmVjIGl0ZXIyIGYgZTEgZTIgPVxuICBtYXRjaCBlMSgpLCBlMigpIHdpdGhcbiAgfCBTb21lIHgsIFNvbWUgeSAtPiBmIHggeTsgaXRlcjIgZiBlMSBlMlxuICB8IF8gLT4gKClcblxuKCokVCBpdGVyMlxuICBsZXQgciA9IHJlZiAwIGluIGl0ZXIyIChmdW4gXyBfIC0+IGluY3IgcikgKDEtLTEwKSAoNC0tNik7ICFyID0gM1xuKilcblxubGV0IHJlYyBmb2xkMiBmIGFjYyBlMSBlMiA9XG4gIG1hdGNoIGUxKCksIGUyKCkgd2l0aFxuICB8IFNvbWUgeCwgU29tZSB5IC0+IGZvbGQyIGYgKGYgYWNjIHggeSkgZTEgZTJcbiAgfCBfIC0+IGFjY1xuXG5sZXQgcmVjIGZvcl9hbGwyIHAgZTEgZTIgPVxuICBtYXRjaCBlMSgpLCBlMigpIHdpdGhcbiAgfCBTb21lIHgsIFNvbWUgeSAtPiBwIHggeSAmJiBmb3JfYWxsMiBwIGUxIGUyXG4gIHwgXyAtPiB0cnVlXG5cbmxldCByZWMgZXhpc3RzMiBwIGUxIGUyID1cbiAgbWF0Y2ggZTEoKSwgZTIoKSB3aXRoXG4gIHwgU29tZSB4LCBTb21lIHkgLT4gcCB4IHkgfHwgZXhpc3RzMiBwIGUxIGUyXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgemlwX3dpdGggZiBhIGIgPVxuICBsZXQgc3RvcCA9IHJlZiBmYWxzZSBpblxuICBmdW4gKCkgLT5cbiAgICBpZiAhc3RvcCB0aGVuIE5vbmVcbiAgICBlbHNlIG1hdGNoIGEoKSwgYigpIHdpdGhcbiAgICAgIHwgU29tZSB4YSwgU29tZSB4YiAtPiBTb21lIChmIHhhIHhiKVxuICAgICAgfCBfIC0+IHN0b3A6PXRydWU7IE5vbmVcblxubGV0IHppcCBhIGIgPSB6aXBfd2l0aCAoZnVuIHggeSAtPiB4LHkpIGEgYlxuXG4oKiRRXG4gIChRLmxpc3QgUS5zbWFsbF9pbnQpIChmdW4gbCAtPiBcXFxuICAgIHppcF93aXRoIChmdW4geCB5LT54LHkpIChvZl9saXN0IGwpIChvZl9saXN0IGwpIFxcXG4gICAgICB8PiB1bnppcCB8PiBmc3QgfD4gdG9fbGlzdCA9IGwpXG4qKVxuXG4oKiRSXG4gIGxldCBlID0gR2VuLnppcF93aXRoICgrKSAoR2VuLnJlcGVhdCAxKSAoNC0tNykgaW5cbiAgT1VuaXQuYXNzZXJ0X2VxdWFsIFs1OzY7Nzs4XSAoR2VuLnRvX2xpc3QgZSk7XG4qKVxuXG4oKiogezMgQ29tcGxleCBjb21iaW5hdG9yc30gKilcblxubW9kdWxlIE1lcmdlU3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0ge1xuICAgIGdlbnMgOiAnYSBnZW4gUXVldWUudDtcbiAgICBtdXRhYmxlIHN0YXRlIDogbXlfc3RhdGU7XG4gIH1cblxuICBhbmQgbXlfc3RhdGUgPVxuICAgIHwgTmV3R2VuICAgKCogb2J0YWluIGEgbmV3IGdlbmVyYXRvciBhbmQgcHVzaCBpdCBpbiBxdWV1ZSAqKVxuICAgIHwgWWllbGRBbmROZXcgKCogeWllbGQgZWxlbWVudCBmcm9tIHF1ZXVlLCB0aGVuIGJlaGF2ZSBsaWtlIE5ld0dlbiAqKVxuICAgIHwgWWllbGQgKCoganVzdCB5aWVsZCBlbGVtZW50cyBmcm9tIHF1ZXVlICopXG4gICAgfCBTdG9wICAoKiBubyBtb3JlIGVsZW1lbnRzICopXG5lbmRcblxuKCogc3RhdGUgbWFjaGluZSBzdGFydHMgYXQgTmV3R2VuOlxuICAgTmV3R2VuOiB1c2UgbmV4dF9nZW4gdG8gcHVzaCBhIG5ldyBnZW4gaW50byB0aGUgcXVldWVcbiAgIFlpZWxkOlxuICAgIHdoaWxlIHRoZSBxdWV1ZSBpcyBub3QgZW1wdHk6XG4gICAgICBwb3AgZ2VuIGcgZnJvbSBpdFxuICAgICAgaWYgZyBpcyBlbXB0eSBjb250aW51ZVxuICAgICAgZWxzZTpcbiAgICAgICAgcG9wIGVsZW1lbnQgeCBmcm9tIGdcbiAgICAgICAgcHVzaCBnIGF0IGJhY2sgb2YgcXVldWVcbiAgICAgICAgeWllbGQgeFxuICAgWWllbGRBbmROZXc6IG1peCBvZiBZaWVsZCBhbmQgTmV3R2VuLlxuICAgIGlmIG5leHRfZ2VuIGlzIGV4aGF1c3RlZCwgZ290byBZaWVsZDtcbiAgICBpZiBxdWV1ZSBpcyBlbXB0eSwgZ290byBOZXdHZW5cbiAgIFN0b3A6IGRvIG5vdGhpbmdcbiopXG5sZXQgbWVyZ2UgbmV4dF9nZW4gPVxuICBsZXQgb3BlbiBNZXJnZVN0YXRlIGluXG4gIGxldCBzdGF0ZSA9IHtnZW5zID0gUXVldWUuY3JlYXRlKCk7IHN0YXRlPU5ld0dlbjt9aW5cbiAgKCogcmVjdXJzaXZlIGZ1bmN0aW9uIHRvIGdldCBuZXh0IGVsZW1lbnQgKilcbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBtYXRjaCBzdGF0ZS5zdGF0ZSB3aXRoXG4gICAgfCBTdG9wIC0+IE5vbmVcbiAgICB8IFlpZWxkIC0+ICAoKiBvbmx5IHlpZWxkIGZyb20gZ2VuZXJhdG9ycyBpbiBzdGF0ZS5nZW5zICopXG4gICAgICAgIGlmIFF1ZXVlLmlzX2VtcHR5IHN0YXRlLmdlbnNcbiAgICAgICAgdGhlbiAoc3RhdGUuc3RhdGUgPC0gU3RvcDsgTm9uZSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCBnZW4gPSBRdWV1ZS5wb3Agc3RhdGUuZ2VucyBpblxuICAgICAgICAgIGJlZ2luIG1hdGNoIGdlbiAoKSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gbmV4dCgpXG4gICAgICAgICAgICB8IChTb21lIF8pIGFzIHJlcyAtPlxuICAgICAgICAgICAgICAgIFF1ZXVlLnB1c2ggZ2VuIHN0YXRlLmdlbnM7ICAoKiBwdXQgZ2VuIGJhY2sgaW4gcXVldWUgKilcbiAgICAgICAgICAgICAgICByZXNcbiAgICAgICAgICBlbmRcbiAgICB8IE5ld0dlbiAtPlxuICAgICAgICBiZWdpbiBtYXRjaCBuZXh0X2dlbigpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgc3RhdGUuc3RhdGUgPC0gWWllbGQ7ICAoKiBleGhhdXN0ZWQgKilcbiAgICAgICAgICAgICAgbmV4dCgpXG4gICAgICAgICAgfCBTb21lIGdlbiAtPlxuICAgICAgICAgICAgICBRdWV1ZS5wdXNoIGdlbiBzdGF0ZS5nZW5zO1xuICAgICAgICAgICAgICBzdGF0ZS5zdGF0ZSA8LSBZaWVsZEFuZE5ldztcbiAgICAgICAgICAgICAgbmV4dCgpXG4gICAgICAgIGVuZFxuICAgIHwgWWllbGRBbmROZXcgLT4gKCogeWllbGQgZWxlbWVudCBmcm9tIHF1ZXVlLCB0aGVuIGdldCBhIG5ldyBnZW5lcmF0b3IgKilcbiAgICAgICAgaWYgUXVldWUuaXNfZW1wdHkgc3RhdGUuZ2Vuc1xuICAgICAgICB0aGVuIChzdGF0ZS5zdGF0ZSA8LSBOZXdHZW47IG5leHQoKSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxldCBnZW4gPSBRdWV1ZS5wb3Agc3RhdGUuZ2VucyBpblxuICAgICAgICAgIGJlZ2luIG1hdGNoIGdlbiAoKSB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gc3RhdGUuc3RhdGUgPC0gTmV3R2VuOyBuZXh0KClcbiAgICAgICAgICAgIHwgKFNvbWUgXykgYXMgcmVzIC0+XG4gICAgICAgICAgICAgICAgUXVldWUucHVzaCBnZW4gc3RhdGUuZ2VucztcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGF0ZSA8LSBOZXdHZW47XG4gICAgICAgICAgICAgICAgcmVzXG4gICAgICAgICAgZW5kXG4gIGluIG5leHRcblxuKCokVFxuICBtZXJnZSAob2ZfbGlzdCBbb2ZfbGlzdCBbMTszOzVdOyBvZl9saXN0IFsyOzQ7Nl07IG9mX2xpc3QgWzc7ODs5XV0pIFxcXG4gICAgfD4gdG9fbGlzdCB8PiBMaXN0LnNvcnQgR2VuU2hpbXNfLlN0ZGxpYi5jb21wYXJlID0gWzE7MjszOzQ7NTs2Ozc7ODs5XVxuKilcblxuKCokUlxuICBsZXQgZSA9IG9mX2xpc3QgWzEtLTM7IDQtLTY7IDctLTldIGluXG4gIGxldCBlJyA9IG1lcmdlIGUgaW5cbiAgT1VuaXQuYXNzZXJ0X2VxdWFsIFsxOzI7Mzs0OzU7Njs3Ozg7OV1cbiAgICAodG9fbGlzdCBlJyB8PiBMaXN0LnNvcnQgR2VuU2hpbXNfLlN0ZGxpYi5jb21wYXJlKTtcbiopXG5cbmxldCBpbnRlcnNlY3Rpb24gPyhjbXA9R2VuU2hpbXNfLlN0ZGxpYi5jb21wYXJlKSBnZW4xIGdlbjIgPVxuICBsZXQgeDEgPSByZWYgKGdlbjEgKCkpIGluXG4gIGxldCB4MiA9IHJlZiAoZ2VuMiAoKSkgaW5cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBtYXRjaCAheDEsICF4MiB3aXRoXG4gICAgfCBTb21lIHkxLCBTb21lIHkyIC0+XG4gICAgICAgIGxldCBjID0gY21wIHkxIHkyIGluXG4gICAgICAgIGlmIGMgPSAwICAoKiBlcXVhbCBlbGVtZW50cywgeWllbGQhICopXG4gICAgICAgIHRoZW4gKHgxIDo9IGdlbjEoKTsgeDIgOj0gZ2VuMigpOyBTb21lIHkxKVxuICAgICAgICBlbHNlIGlmIGMgPCAwICgqIGRyb3AgeTEgKilcbiAgICAgICAgdGhlbiAoeDEgOj0gZ2VuMSAoKTsgbmV4dCAoKSlcbiAgICAgICAgZWxzZSAoKiBkcm9wIHkyICopXG4gICAgICAgICAgKHgyIDo9IGdlbjIoKTsgbmV4dCAoKSlcbiAgICB8IF8gLT4gTm9uZVxuICBpbiBuZXh0XG5cbigqJFRcbiAgaW50ZXJzZWN0aW9uIChvZl9saXN0IFsxOzE7MjszOzQ7OF0pIChvZl9saXN0IFsxOzI7NDs1OzY7Nzs4OzldKSBcXFxuICAgIHw+IHRvX2xpc3QgPSBbMTsyOzQ7OF1cbiopXG5cbmxldCBzb3J0ZWRfbWVyZ2UgPyhjbXA9R2VuU2hpbXNfLlN0ZGxpYi5jb21wYXJlKSBnZW4xIGdlbjIgPVxuICBsZXQgeDEgPSByZWYgKGdlbjEgKCkpIGluXG4gIGxldCB4MiA9IHJlZiAoZ2VuMiAoKSkgaW5cbiAgZnVuICgpIC0+XG4gICAgbWF0Y2ggIXgxLCAheDIgd2l0aFxuICAgIHwgTm9uZSwgTm9uZSAtPiBOb25lXG4gICAgfCAoU29tZSB5MSlhcyByMSwgKChTb21lIHkyKSBhcyByMikgLT5cbiAgICAgICAgaWYgY21wIHkxIHkyIDw9IDBcbiAgICAgICAgdGhlbiAoeDEgOj0gZ2VuMSAoKTsgcjEpXG4gICAgICAgIGVsc2UgKHgyIDo9IGdlbjIgKCk7IHIyKVxuICAgIHwgKFNvbWUgXylhcyByLCBOb25lIC0+XG4gICAgICAgIHgxIDo9IGdlbjEgKCk7XG4gICAgICAgIHJcbiAgICB8IE5vbmUsICgoU29tZSBfKWFzIHIpIC0+XG4gICAgICAgIHgyIDo9IGdlbjIgKCk7XG4gICAgICAgIHJcblxuKCokVFxuICBzb3J0ZWRfbWVyZ2UgKG9mX2xpc3QgWzE7MjsyOzM7NTsxMDsxMDBdKSAob2ZfbGlzdCBbMjs0OzU7NjsxMV0pIFxcXG4gICAgfD4gdG9fbGlzdCA9IFsxOzI7MjsyOzM7NDs1OzU7NjsxMDsxMTsxMDBdXG4qKVxuXG4oKiRSXG4gIFtHZW4ub2ZfbGlzdCBbMTszOzVdOyBHZW4ub2ZfbGlzdCBbMDsxOzE7Mzs0OzY7MTBdOyBHZW4ub2ZfbGlzdCBbMjsyOzExXV1cbiAgICB8PiBHZW4uc29ydGVkX21lcmdlX24gP2NtcDpOb25lXG4gICAgfD4gR2VuLnRvX2xpc3RcbiAgICB8PiBPVW5pdC5hc3NlcnRfZXF1YWwgfnByaW50ZXI6cGlsaXN0IFswOzE7MTsxOzI7MjszOzM7NDs1OzY7MTA7MTFdXG4qKVxuXG4oKiogezQgTXV0YWJsZSBoZWFwICh0YWtlbiBmcm9tIGhlYXAubWwgdG8gYXZvaWQgZGVwZW5kZW5jaWVzKX0gKilcbm1vZHVsZSBIZWFwID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9IHtcbiAgICBtdXRhYmxlIHRyZWUgOiAnYSB0cmVlO1xuICAgIGNtcCA6ICdhIC0+ICdhIC0+IGludDtcbiAgfSAoKiogQSBwYWlyaW5nIHRyZWUgaGVhcCB3aXRoIHRoZSBnaXZlbiBjb21wYXJpc29uIGZ1bmN0aW9uICopXG5cbiAgYW5kICdhIHRyZWUgPVxuICAgIHwgRW1wdHlcbiAgICB8IE5vZGUgb2YgJ2EgKiAnYSB0cmVlICogJ2EgdHJlZVxuXG4gIGxldCBlbXB0eSB+Y21wID0ge1xuICAgIHRyZWUgPSBFbXB0eTtcbiAgICBjbXA7XG4gIH1cblxuICBsZXQgaXNfZW1wdHkgaCA9XG4gICAgbWF0Y2ggaC50cmVlIHdpdGhcbiAgICB8IEVtcHR5IC0+IHRydWVcbiAgICB8IE5vZGUgXyAtPiBmYWxzZVxuXG4gIGxldCByZWMgdW5pb24gfmNtcCB0MSB0MiA9IG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgfCBFbXB0eSwgXyAtPiB0MlxuICAgIHwgXywgRW1wdHkgLT4gdDFcbiAgICB8IE5vZGUgKHgxLCBsMSwgcjEpLCBOb2RlICh4MiwgbDIsIHIyKSAtPlxuICAgICAgICBpZiBjbXAgeDEgeDIgPD0gMFxuICAgICAgICB0aGVuIE5vZGUgKHgxLCB1bmlvbiB+Y21wIHQyIHIxLCBsMSlcbiAgICAgICAgZWxzZSBOb2RlICh4MiwgdW5pb24gfmNtcCB0MSByMiwgbDIpXG5cbiAgbGV0IGluc2VydCBoIHggPVxuICAgIGgudHJlZSA8LSB1bmlvbiB+Y21wOmguY21wIChOb2RlICh4LCBFbXB0eSwgRW1wdHkpKSBoLnRyZWVcblxuICBsZXQgcG9wIGggPSBtYXRjaCBoLnRyZWUgd2l0aFxuICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgfCBOb2RlICh4LCBsLCByKSAtPlxuICAgICAgICBoLnRyZWUgPC0gdW5pb24gfmNtcDpoLmNtcCBsIHI7XG4gICAgICAgIHhcbmVuZFxuXG5sZXQgc29ydGVkX21lcmdlX24gPyhjbXA9R2VuU2hpbXNfLlN0ZGxpYi5jb21wYXJlKSBsID1cbiAgKCogbWFrZSBhIGhlYXAgb2YgKHZhbHVlLCBnZW5lcmF0b3IpICopXG4gIGxldCBjbXAgKHYxLF8pICh2MixfKSA9IGNtcCB2MSB2MiBpblxuICBsZXQgaGVhcCA9IEhlYXAuZW1wdHkgfmNtcCBpblxuICAoKiBhZGQgaW5pdGlhbCB2YWx1ZXMgKilcbiAgTGlzdC5pdGVyXG4gICAgKGZ1biBnZW4nIC0+IG1hdGNoIGdlbicoKSB3aXRoXG4gICAgICAgfCBTb21lIHggLT4gSGVhcC5pbnNlcnQgaGVhcCAoeCwgZ2VuJylcbiAgICAgICB8IE5vbmUgLT4gKCkpXG4gICAgbDtcbiAgZnVuICgpIC0+XG4gICAgaWYgSGVhcC5pc19lbXB0eSBoZWFwIHRoZW4gTm9uZVxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCB4LCBnZW4gPSBIZWFwLnBvcCBoZWFwIGluXG4gICAgICBtYXRjaCBnZW4oKSB3aXRoXG4gICAgICB8IFNvbWUgeSAtPlxuICAgICAgICAgIEhlYXAuaW5zZXJ0IGhlYXAgKHksIGdlbik7ICAoKiBpbnNlcnQgbmV4dCB2YWx1ZSAqKVxuICAgICAgICAgIFNvbWUgeFxuICAgICAgfCBOb25lIC0+IFNvbWUgeCAoKiBnZW4gZW1wdHksIGRyb3AgaXQgKilcbiAgICBlbmRcblxuKCokVFxuICBzb3J0ZWRfbWVyZ2VfbiBbb2ZfbGlzdCBbMTsyOzI7Mzs1OzEwOzEwMF07IG9mX2xpc3QgWzI7NDs1OzY7MTFdOyAoNi0tMTApXSBcXFxuICAgIHw+IHRvX2xpc3QgPSBbMTsyOzI7MjszOzQ7NTs1OzY7Njs3Ozg7OTsxMDsxMDsxMTsxMDBdXG4qKVxuXG5sZXQgcm91bmRfcm9iaW4gPyhuPTIpIGdlbiA9XG4gICgqIGFycmF5IG9mIHF1ZXVlcywgdG9nZXRoZXIgd2l0aCB0aGVpciBpbmRleCAqKVxuICBsZXQgcXMgPSBBcnJheS5pbml0IG4gKGZ1biBfIC0+IFF1ZXVlLmNyZWF0ZSAoKSkgaW5cbiAgbGV0IGN1ciA9IHJlZiAwIGluXG4gICgqIGdldCBuZXh0IGVsZW1lbnQgZm9yIHRoZSBpLXRoIHF1ZXVlICopXG4gIGxldCByZWMgbmV4dCBpID1cbiAgICBsZXQgcSA9IHFzLihpKSBpblxuICAgIGlmIFF1ZXVlLmlzX2VtcHR5IHFcbiAgICB0aGVuIHVwZGF0ZV90b19pIGkgICgqIGNvbnN1bWUgZ2VuZXJhdG9yICopXG4gICAgZWxzZSBTb21lKFF1ZXVlLnBvcCBxKVxuICAoKiBjb25zdW1lIFtnZW5dIHVudGlsIHNvbWUgZWxlbWVudCBmb3IgW2ldLXRoIGdlbmVyYXRvciBpc1xuICAgICBhdmFpbGFibGUuICopXG4gIGFuZCB1cGRhdGVfdG9faSBpID1cbiAgICBtYXRjaCBnZW4oKSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgICBsZXQgaiA9ICFjdXIgaW5cbiAgICAgICAgY3VyIDo9IChqKzEpIG1vZCBuOyAgKCogbW92ZSBjdXJzb3IgdG8gbmV4dCBnZW5lcmF0b3IgKilcbiAgICAgICAgbGV0IHEgPSBxcy4oaikgaW5cbiAgICAgICAgaWYgaiA9IGlcbiAgICAgICAgdGhlbiBiZWdpblxuICAgICAgICAgIGFzc2VydCAoUXVldWUuaXNfZW1wdHkgcSk7XG4gICAgICAgICAgU29tZSB4ICAoKiByZXR1cm4gdGhlIGVsZW1lbnQgKilcbiAgICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICBRdWV1ZS5wdXNoIHggcTtcbiAgICAgICAgICB1cGRhdGVfdG9faSBpICAoKiBjb250aW51ZSBjb25zdW1pbmcgW2dlbl0gKilcbiAgICAgICAgZW5kXG4gIGluXG4gICgqIGdlbmVyYXRvcnMgKilcbiAgbGV0IGwgPSBBcnJheS5tYXBpIChmdW4gaSBfIC0+IChmdW4gKCkgLT4gbmV4dCBpKSkgcXMgaW5cbiAgQXJyYXkudG9fbGlzdCBsXG5cbigqJFRcbiAgcm91bmRfcm9iaW4gfm46MyAoMS0tMTIpIHw+IExpc3QubWFwIHRvX2xpc3QgPSBcXFxuICAgIFtbMTs0Ozc7MTBdOyBbMjs1Ozg7MTFdOyBbMzs2Ozk7MTJdXVxuKilcblxuKCokUlxuICBsZXQgZSA9IFJlc3RhcnQucm91bmRfcm9iaW4gfm46MiBSZXN0YXJ0LigxLS0xMCkgaW5cbiAgbWF0Y2ggZSB3aXRoXG4gIHwgW2E7Yl0gLT5cbiAgICBPVW5pdC5hc3NlcnRfZXF1YWwgWzE7Mzs1Ozc7OV0gKEdlbi50b19saXN0IGEpO1xuICAgIE9Vbml0LmFzc2VydF9lcXVhbCBbMjs0OzY7ODsxMF0gKEdlbi50b19saXN0IGIpXG4gIHwgXyAtPiBPVW5pdC5hc3NlcnRfZmFpbHVyZSBcIndyb25nIGxpc3QgbGVuZ3RoXCJcbiopXG5cbigqJFJcbiAgbGV0IGUgPSBSZXN0YXJ0LnJvdW5kX3JvYmluIH5uOjMgUmVzdGFydC4oMSAtLSA5OTkpIGluXG4gIGxldCBsID0gTGlzdC5tYXAgR2VuLmxlbmd0aCBlIGluXG4gIE9Vbml0LmFzc2VydF9lcXVhbCBbMzMzOzMzMzszMzNdIGw7XG4qKVxuXG4oKiBEdXBsaWNhdGUgdGhlIGVudW0gaW50byBbbl0gZ2VuZXJhdG9ycyAoZGVmYXVsdCAyKS4gVGhlIGdlbmVyYXRvcnNcbiAgIHNoYXJlIHRoZSBzYW1lIHVuZGVybHlpbmcgaW5zdGFuY2Ugb2YgdGhlIGVudW0sIHNvIHRoZSBvcHRpbWFsIGNhc2UgaXNcbiAgIHdoZW4gdGhleSBhcmUgY29uc3VtZWQgZXZlbmx5ICopXG5sZXQgdGVlID8obj0yKSBnZW4gPVxuICAoKiBhcnJheSBvZiBxdWV1ZXMsIHRvZ2V0aGVyIHdpdGggdGhlaXIgaW5kZXggKilcbiAgbGV0IHFzID0gQXJyYXkuaW5pdCBuIChmdW4gXyAtPiBRdWV1ZS5jcmVhdGUgKCkpIGluXG4gIGxldCBmaW5pc2hlZCA9IHJlZiBmYWxzZSBpbiAoKiBpcyBbZ2VuXSBleGhhdXN0ZWQ/ICopXG4gICgqIGdldCBuZXh0IGVsZW1lbnQgZm9yIHRoZSBpLXRoIHF1ZXVlICopXG4gIGxldCByZWMgbmV4dCBpID1cbiAgICBpZiBRdWV1ZS5pc19lbXB0eSBxcy4oaSlcbiAgICB0aGVuXG4gICAgICBpZiAhZmluaXNoZWQgdGhlbiBOb25lXG4gICAgICBlbHNlIGdldF9uZXh0IGkgICgqIGNvbnN1bWUgZ2VuZXJhdG9yICopXG4gICAgZWxzZSBRdWV1ZS5wb3AgcXMuKGkpXG4gICgqIGNvbnN1bWUgb25lIG1vcmUgZWxlbWVudCAqKVxuICBhbmQgZ2V0X25leHQgaSA9IG1hdGNoIGdlbigpIHdpdGhcbiAgICB8IFNvbWUgXyBhcyByZXMgLT5cbiAgICAgICAgZm9yIGogPSAwIHRvIG4tMSBkb1xuICAgICAgICAgIGlmIGogPD4gaSB0aGVuIFF1ZXVlLnB1c2ggcmVzIHFzLihqKVxuICAgICAgICBkb25lO1xuICAgICAgICByZXNcbiAgICB8IE5vbmUgLT4gZmluaXNoZWQgOj0gdHJ1ZTsgTm9uZVxuICBpblxuICAoKiBnZW5lcmF0b3JzICopXG4gIGxldCBsID0gQXJyYXkubWFwaSAoZnVuIGkgXyAtPiAoZnVuICgpIC0+IG5leHQgaSkpIHFzIGluXG4gIEFycmF5LnRvX2xpc3QgbFxuXG4oKiRUXG4gIHRlZSB+bjozICgxLS0xMikgfD4gTGlzdC5tYXAgdG9fbGlzdCA9IFxcXG4gICAgW3RvX2xpc3QgKDEtLTEyKTsgdG9fbGlzdCAoMS0tMTIpOyB0b19saXN0ICgxLS0xMildXG4qKVxuXG5cbm1vZHVsZSBJbnRlcmxlYXZlU3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB8IE9ubHkgb2YgJ2EgZ2VuXG4gICAgfCBCb3RoIG9mICdhIGdlbiAqICdhIGdlbiAqIGJvb2wgcmVmXG4gICAgfCBTdG9wXG5lbmRcblxuKCogWWllbGQgZWxlbWVudHMgZnJvbSBhIGFuZCBiIGFsdGVybmF0aXZlbHkgKilcbmxldCBpbnRlcmxlYXZlIGdlbl9hIGdlbl9iID1cbiAgbGV0IG9wZW4gSW50ZXJsZWF2ZVN0YXRlIGluXG4gIGxldCBzdGF0ZSA9IHJlZiAoQm90aCAoZ2VuX2EsIGdlbl9iLCByZWYgdHJ1ZSkpIGluXG4gIGxldCByZWMgbmV4dCgpID0gbWF0Y2ggIXN0YXRlIHdpdGhcbiAgICB8IFN0b3AgLT4gTm9uZVxuICAgIHwgT25seSBnIC0+XG4gICAgICAgIGJlZ2luIG1hdGNoIGcoKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IHN0YXRlIDo9IFN0b3A7IE5vbmVcbiAgICAgICAgICB8IChTb21lIF8pIGFzIHJlcyAtPiByZXNcbiAgICAgICAgZW5kXG4gICAgfCBCb3RoIChnMSwgZzIsIHIpIC0+XG4gICAgICAgIG1hdGNoIChpZiAhciB0aGVuIGcxKCkgZWxzZSBnMigpKSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgc3RhdGUgOj0gaWYgIXIgdGhlbiBPbmx5IGcyIGVsc2UgT25seSBnMTtcbiAgICAgICAgICAgIG5leHQoKVxuICAgICAgICB8IChTb21lIF8pIGFzIHJlcyAtPlxuICAgICAgICAgICAgciA6PSBub3QgIXI7ICgqIHN3YXAgKilcbiAgICAgICAgICAgIHJlc1xuICBpbiBuZXh0XG5cbigqJFRcbiAgaW50ZXJsZWF2ZSAocmVwZWF0IDApICgxLS01KSB8PiB0YWtlIDEwIHw+IHRvX2xpc3QgPSBcXFxuICAgIFswOzE7MDsyOzA7MzswOzQ7MDs1XVxuKilcblxuKCokUlxuICBsZXQgZTEgPSBHZW4ub2ZfbGlzdCBbMTszOzU7Nzs5XSBpblxuICBsZXQgZTIgPSBHZW4ub2ZfbGlzdCBbMjs0OzY7ODsxMF0gaW5cbiAgbGV0IGUgPSBHZW4uaW50ZXJsZWF2ZSBlMSBlMiBpblxuICBPVW5pdC5hc3NlcnRfZXF1YWwgWzE7MjszOzQ7NTs2Ozc7ODs5OzEwXSAoR2VuLnRvX2xpc3QgZSk7XG4qKVxuXG5tb2R1bGUgSW50ZXJzcGVyc2VTdGF0ZSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPVxuICAgIHwgU3RhcnRcbiAgICB8IFlpZWxkRWxlbSBvZiAnYSBvcHRpb25cbiAgICB8IFlpZWxkU2VwIG9mICdhIG9wdGlvbiAgKCogbmV4dCB2YWwgKilcbiAgICB8IFN0b3BcbmVuZFxuXG4oKiBQdXQgW3hdIGJldHdlZW4gZWxlbWVudHMgb2YgW2VudW1dICopXG5sZXQgaW50ZXJzcGVyc2UgeCBnZW4gPVxuICBsZXQgb3BlbiBJbnRlcnNwZXJzZVN0YXRlIGluXG4gIGxldCBzdGF0ZSA9IHJlZiBTdGFydCBpblxuICBsZXQgcmVjIG5leHQoKSA9IG1hdGNoICFzdGF0ZSB3aXRoXG4gICAgfCBTdG9wIC0+IE5vbmVcbiAgICB8IFlpZWxkRWxlbSByZXMgLT5cbiAgICAgICAgYmVnaW4gbWF0Y2ggZ2VuKCkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBzdGF0ZSA6PSBTdG9wXG4gICAgICAgICAgfCBTb21lIF8gYXMgcmVzJyAtPiBzdGF0ZSA6PSBZaWVsZFNlcCByZXMnXG4gICAgICAgIGVuZDtcbiAgICAgICAgcmVzXG4gICAgfCBZaWVsZFNlcCByZXMgLT5cbiAgICAgICAgc3RhdGUgOj0gWWllbGRFbGVtIHJlcztcbiAgICAgICAgU29tZSB4XG4gICAgfCBTdGFydCAtPlxuICAgICAgICBtYXRjaCBnZW4oKSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBzdGF0ZSA6PSBTdG9wOyBOb25lXG4gICAgICAgIHwgU29tZSBfIGFzIHJlcyAtPiBzdGF0ZSA6PSBZaWVsZEVsZW0gcmVzOyBuZXh0KClcbiAgaW4gbmV4dFxuXG4oKiRUXG4gIGludGVyc3BlcnNlIDAgKDEtLTUpIHw+IHRvX2xpc3QgPSBbMTswOzI7MDszOzA7NDswOzVdXG4qKVxuXG4oKiRSXG4gIGxldCBlID0gMSAtLSA1IGluXG4gIGxldCBlJyA9IEdlbi5pbnRlcnNwZXJzZSAwIGUgaW5cbiAgT1VuaXQuYXNzZXJ0X2VxdWFsIFsxOzA7MjswOzM7MDs0OzA7NV0gKEdlbi50b19saXN0IGUnKTtcbiopXG5cbigqIENhcnRlc2lhbiBwcm9kdWN0ICopXG5sZXQgcHJvZHVjdCBnZW5hIGdlbmIgPVxuICBsZXQgYWxsX2EgPSByZWYgW10gaW5cbiAgbGV0IGFsbF9iID0gcmVmIFtdIGluXG4gICgqIGN1cjogY3VycmVudCBzdGF0ZSwgaS5lLiwgd2hhdCB3ZSBoYXZlIHRvIGRvIG5leHQuIENhbiBiZSBzdG9wLFxuICAgICBnZXRMZWZ0L2dldFJpZ2h0ICh0byBvYnRhaW4gbmV4dCBlbGVtZW50IGZyb20gZmlyc3Qvc2Vjb25kIGdlbmVyYXRvciksXG4gICAgIG9yIHByb2RMZWZ0L3Byb2RSSWdodCB0byBjb21wdXRlIHRoZSBwcm9kdWN0IG9mIGFuIGVsZW1lbnQgd2l0aCBhIGxpc3RcbiAgICAgb2YgYWxyZWFkeSBtZXQgZWxlbWVudHMgKilcbiAgbGV0IGN1ciA9IHJlZiBgR2V0TGVmdCBpblxuICBsZXQgcmVjIG5leHQgKCkgPVxuICAgIG1hdGNoICFjdXIgd2l0aFxuICAgIHwgYFN0b3AgLT4gTm9uZVxuICAgIHwgYEdldExlZnQgLT5cbiAgICAgICAgYmVnaW4gbWF0Y2ggZ2VuYSgpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gY3VyIDo9IGBHZXRSaWdodE9yU3RvcFxuICAgICAgICAgIHwgU29tZSBhIC0+IGFsbF9hIDo9IGEgOjogIWFsbF9hOyBjdXIgOj0gYFByb2RMZWZ0IChhLCAhYWxsX2IpXG4gICAgICAgIGVuZDtcbiAgICAgICAgbmV4dCAoKVxuICAgIHwgYEdldFJpZ2h0IHwgYEdldFJpZ2h0T3JTdG9wIC0+ICAoKiBUT0RPOiB0ZXN0ICopXG4gICAgICAgIGJlZ2luIG1hdGNoIGdlbmIoKSB3aXRoXG4gICAgICAgICAgfCBOb25lIHdoZW4gIWN1ciA9IGBHZXRSaWdodE9yU3RvcCAtPiBjdXIgOj0gYFN0b3BcbiAgICAgICAgICB8IE5vbmUgLT4gY3VyIDo9IGBHZXRMZWZ0XG4gICAgICAgICAgfCBTb21lIGIgLT4gYWxsX2IgOj0gYjo6IWFsbF9iOyBjdXIgOj0gYFByb2RSaWdodCAoYiwgIWFsbF9hKVxuICAgICAgICBlbmQ7XG4gICAgICAgIG5leHQgKClcbiAgICB8IGBQcm9kTGVmdCAoXywgW10pIC0+XG4gICAgICAgIGN1ciA6PSBgR2V0UmlnaHQ7XG4gICAgICAgIG5leHQoKVxuICAgIHwgYFByb2RMZWZ0ICh4LCB5OjpsKSAtPlxuICAgICAgICBjdXIgOj0gYFByb2RMZWZ0ICh4LCBsKTtcbiAgICAgICAgU29tZSAoeCwgeSlcbiAgICB8IGBQcm9kUmlnaHQgKF8sIFtdKSAtPlxuICAgICAgICBjdXIgOj0gYEdldExlZnQ7XG4gICAgICAgIG5leHQoKVxuICAgIHwgYFByb2RSaWdodCAoeSwgeDo6bCkgLT5cbiAgICAgICAgY3VyIDo9IGBQcm9kUmlnaHQgKHksIGwpO1xuICAgICAgICBTb21lICh4LCB5KVxuICBpblxuICBuZXh0XG5cbigqJFRcbiAgcHJvZHVjdCAoMS0tMykgKG9mX2xpc3QgW1wiYVwiOyBcImJcIl0pIHw+IHRvX2xpc3QgXFxcbiAgICB8PiBMaXN0LnNvcnQgR2VuU2hpbXNfLlN0ZGxpYi5jb21wYXJlID0gXFxcbiAgICAgIFsxLCBcImFcIjsgMSwgXCJiXCI7IDIsIFwiYVwiOyAyLCBcImJcIjsgMywgXCJhXCI7IDMsIFwiYlwiXVxuKilcblxuKCokUlxuICBsZXQgcHJpbnRlciA9IHBpMmxpc3QgaW5cbiAgbGV0IGUgPSBHZW4ucHJvZHVjdCAoMS0tMykgKDQtLTUpIGluXG4gIE9Vbml0LmFzc2VydF9lcXVhbCB+cHJpbnRlciBbMSw0OyAxLDU7IDIsNDsgMiw1OyAzLDQ7IDMsNV1cbiAgICAoTGlzdC5zb3J0IEdlblNoaW1zXy5TdGRsaWIuY29tcGFyZSAoR2VuLnRvX2xpc3QgZSkpO1xuKilcblxuKCogR3JvdXAgZXF1YWwgY29uc2VjdXRpdmUgZWxlbWVudHMgdG9nZXRoZXIuICopXG5sZXQgZ3JvdXAgPyhlcT0oPSkpIGdlbiA9XG4gIG1hdGNoIGdlbigpIHdpdGhcbiAgfCBOb25lIC0+IGZ1biAoKSAtPiBOb25lXG4gIHwgU29tZSB4IC0+XG4gICAgICBsZXQgY3VyID0gcmVmIFt4XSBpblxuICAgICAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICAgICAgKCogdHJ5IHRvIGdldCBhbiBlbGVtZW50ICopXG4gICAgICAgIGxldCBuZXh0X3ggPSBpZiAhY3VyID0gW10gdGhlbiBOb25lIGVsc2UgZ2VuKCkgaW5cbiAgICAgICAgbWF0Y2ggbmV4dF94LCAhY3VyIHdpdGhcbiAgICAgICAgfCBOb25lLCBbXSAtPiBOb25lXG4gICAgICAgIHwgTm9uZSwgbCAtPlxuICAgICAgICAgICAgY3VyIDo9IFtdOyAgKCogc3RvcCAqKVxuICAgICAgICAgICAgU29tZSBsXG4gICAgICAgIHwgU29tZSB4LCB5OjpfIHdoZW4gZXEgeCB5IC0+XG4gICAgICAgICAgICBjdXIgOj0geDo6IWN1cjtcbiAgICAgICAgICAgIG5leHQgKCkgICgqIHNhbWUgZ3JvdXAgKilcbiAgICAgICAgfCBTb21lIHgsIGwgLT5cbiAgICAgICAgICAgIGN1ciA6PSBbeF07XG4gICAgICAgICAgICBTb21lIGxcbiAgICAgIGluIG5leHRcblxuKCokVFxuICBncm91cCAob2ZfbGlzdCBbMDswOzA7MTswOzI7MjszOzQ7NTs1OzU7NTsxMF0pIHw+IHRvX2xpc3QgPSBcXFxuICAgIFtbMDswOzBdO1sxXTtbMF07WzI7Ml07WzNdO1s0XTtbNTs1OzU7NV07WzEwXV1cbiopXG5cbmxldCB1bmlxID8oZXE9KD0pKSBnZW4gPVxuICBsZXQgb3BlbiBSdW5TdGF0ZSBpblxuICBsZXQgc3RhdGUgPSByZWYgSW5pdCBpblxuICBsZXQgcmVjIG5leHQoKSA9IG1hdGNoICFzdGF0ZSB3aXRoXG4gICAgfCBTdG9wIC0+IE5vbmVcbiAgICB8IEluaXQgLT5cbiAgICAgICAgYmVnaW4gbWF0Y2ggZ2VuKCkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBzdGF0ZTo9IFN0b3A7IE5vbmVcbiAgICAgICAgICB8IChTb21lIHgpIGFzIHJlcyAtPiBzdGF0ZSA6PSBSdW4geDsgcmVzXG4gICAgICAgIGVuZFxuICAgIHwgUnVuIHggLT5cbiAgICAgICAgYmVnaW4gbWF0Y2ggZ2VuKCkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBzdGF0ZTo9IFN0b3A7IE5vbmVcbiAgICAgICAgICB8IChTb21lIHkpIGFzIHJlcyAtPlxuICAgICAgICAgICAgICBpZiBlcSB4IHlcbiAgICAgICAgICAgICAgdGhlbiBuZXh0KCkgICAoKiBpZ25vcmUgZHVwbGljYXRlICopXG4gICAgICAgICAgICAgIGVsc2UgKHN0YXRlIDo9IFJ1biB5OyByZXMpXG4gICAgICAgIGVuZFxuICBpbiBuZXh0XG5cbigqJFRcbiAgdW5pcSAob2ZfbGlzdCBbMDswOzA7MTswOzI7MjszOzQ7NTs1OzU7NTsxMF0pIHw+IHRvX2xpc3QgPSBcXFxuICAgIFswOzE7MDsyOzM7NDs1OzEwXVxuKilcblxubGV0IHNvcnQgPyhjbXA9R2VuU2hpbXNfLlN0ZGxpYi5jb21wYXJlKSBnZW4gPVxuICAoKiBidWlsZCBoZWFwICopXG4gIGxldCBoID0gSGVhcC5lbXB0eSB+Y21wIGluXG4gIGl0ZXIgKEhlYXAuaW5zZXJ0IGgpIGdlbjtcbiAgZnVuICgpIC0+XG4gICAgaWYgSGVhcC5pc19lbXB0eSBoXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZSBTb21lIChIZWFwLnBvcCBoKVxuKCokVFxuICBzb3J0IChvZl9saXN0IFswOzA7MDsxOzA7MjsyOzM7NDs1OzU7NTstNDI7NTsxMF0pIHw+IHRvX2xpc3QgPSBcXFxuICAgIFstNDI7MDswOzA7MDsxOzI7MjszOzQ7NTs1OzU7NTsxMF1cbiopXG5cblxuKCogTk9URTogdXNpbmcgYSBzZXQgaXMgbm90IHJlYWxseSBwb3NzaWJsZSwgYmVjYXVzZSBvbmNlIHdlIGhhdmUgYnVpbHQgdGhlXG4gICBzZXQgdGhlcmUgaXMgbm8gc2ltcGxlIHdheSB0byBpdGVyYXRlIG9uIGl0ICopXG5sZXQgc29ydF91bmlxID8oY21wPUdlblNoaW1zXy5TdGRsaWIuY29tcGFyZSkgZ2VuID1cbiAgdW5pcSB+ZXE6KGZ1biB4IHkgLT4gY21wIHggeSA9IDApIChzb3J0IH5jbXAgZ2VuKVxuXG4oKiRUXG4gIHNvcnRfdW5pcSAob2ZfbGlzdCBbMDswOzA7MTswOzI7MjszOzQ7NTs0Mjs1OzU7NDI7NTsxMF0pIHw+IHRvX2xpc3QgPSBcXFxuICAgIFswOzE7MjszOzQ7NTsxMDs0Ml1cbiopXG5cbmxldCBjaHVua3MgbiBlID1cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBtYXRjaCBlKCkgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIHggLT5cbiAgICAgICAgbGV0IGEgPSBBcnJheS5tYWtlIG4geCBpblxuICAgICAgICBmaWxsIGEgMVxuXG4gIGFuZCBmaWxsIGEgaSA9XG4gICAgKCogZmlsbCB0aGUgYXJyYXkuIFtpXTogY3VycmVudCBpbmRleCB0byBmaWxsICopXG4gICAgaWYgaSA9IG5cbiAgICB0aGVuIFNvbWUgYVxuICAgIGVsc2UgbWF0Y2ggZSgpIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBTb21lIChBcnJheS5zdWIgYSAwIGkpICAoKiBsYXN0IGFycmF5IGlzIG5vdCBmdWxsICopXG4gICAgICB8IFNvbWUgeCAtPlxuICAgICAgICAgIGEuKGkpIDwtIHg7XG4gICAgICAgICAgZmlsbCBhIChpKzEpXG4gIGluXG4gIG5leHRcblxuKCokVFxuICBjaHVua3MgMjUgKDAtLTEwMCkgfD4gbWFwIEFycmF5LnRvX2xpc3QgfD4gdG9fbGlzdCA9IFxcXG4gICAgTGlzdC5tYXAgdG9fbGlzdCBbKDAtLTI0KTsgKDI1LS00OSk7KDUwLS03NCk7KDc1LS05OSk7KDEwMC0tMTAwKV1cbiopXG5cbigqJFFcbiAgUS4obGlzdCBpbnQpIChmdW4gbCAtPiBcXFxuICAgIG9mX2xpc3QgbCB8PiBjaHVua3MgMjUgfD4gZmxhdF9tYXAgb2ZfYXJyYXkgfD4gdG9fbGlzdCA9IGwpXG4qKVxuXG4oKiBzdGF0ZSBvZiB0aGUgcGVybXV0YXRpb24gbWFjaGluZS4gT25lIG1hY2hpbmUgbWFuYWdlcyBvbmUgZWxlbWVudCBbeF0sXG4gICBhbmQgZGVwZW5kcyBvbiBhIGRlZXBlciBtYWNoaW5lIFtnXSB0aGF0IGdlbmVyYXRlcyBwZXJtdXRhdGlvbnMgb2YgdGhlXG4gICBsaXN0IG1pbnVzIHRoaXMgZWxlbWVudCAoZG93biB0byB0aGUgZW1wdHkgbGlzdCkuXG4gICBUaGUgbWFjaGluZSBjYW4gZG8gdHdvIHRoaW5nczpcbiAgICAtIGluc2VydCB0aGUgZWxlbWVudCBpbiB0aGUgY3VycmVudCBsaXN0IG9mIFtnXSwgYXQgYW55IHBvc2l0aW9uXG4gICAgLSBvYnRhaW4gdGhlIG5leHQgbGlzdCBvZiBbZ11cbiopXG5cbigqIFRPRE86IGNoZWNrIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlYXAnc19hbGdvcml0aG0gLCBtaWdodCBiZSBiZXR0ZXIgKilcblxubW9kdWxlIFBlcm1TdGF0ZSA9IHN0cnVjdFxuICB0eXBlICdhIHN0YXRlID1cbiAgICB8IERvbmVcbiAgICB8IEJhc2UgKCogYm90dG9tIG1hY2hpbmUsIHlpZWxkIFtdICopXG4gICAgfCBJbnNlcnQgb2YgJ2EgaW5zZXJ0X3N0YXRlXG4gIGFuZCAnYSBpbnNlcnRfc3RhdGUgPSB7XG4gICAgeCA6ICdhO1xuICAgIG11dGFibGUgbCA6ICdhIGxpc3Q7XG4gICAgbXV0YWJsZSBuIDogaW50OyAoKiBpZHggZm9yIGluc2VydGlvbiAqKVxuICAgIGxlbiA6IGludDsgKCogbGVuIG9mIFtsXSAqKVxuICAgIHN1YiA6ICdhIHQ7XG4gIH1cbiAgYW5kICdhIHQgPSB7XG4gICAgbXV0YWJsZSBzdCA6ICdhIHN0YXRlO1xuICB9XG5lbmRcblxubGV0IHBlcm11dGF0aW9ucyBnID1cbiAgbGV0IG9wZW4gUGVybVN0YXRlIGluXG4gICgqIG1ha2UgYSBtYWNoaW5lIGZvciBuIGVsZW1lbnRzLiBJbnZhcmlhbnQ6IG49bGVuKGwpICopXG4gIGxldCByZWMgbWFrZV9tYWNoaW5lIG4gbCA9IG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gYXNzZXJ0IChuPTApOyB7c3Q9QmFzZX1cbiAgICB8IHggOjogdGFpbCAtPlxuICAgICAgICBsZXQgc3ViID0gbWFrZV9tYWNoaW5lIChuLTEpIHRhaWwgaW5cbiAgICAgICAgbGV0IHN0ID0gbWF0Y2ggbmV4dCBzdWIgKCkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBEb25lXG4gICAgICAgICAgfCBTb21lIGwgLT4gSW5zZXJ0IHt4O249MDtsO2xlbj1uO3N1Yn1cbiAgICAgICAgaW5cbiAgICAgICAge3N0O31cbiAgKCogbmV4dCBlbGVtZW50IG9mIHRoZSBtYWNoaW5lICopXG4gIGFuZCBuZXh0IG0gKCkgPSBtYXRjaCBtLnN0IHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgQmFzZSAtPiBtLnN0IDwtIERvbmU7IFNvbWUgW11cbiAgICB8IEluc2VydCAoe3g7bGVuO247bDtzdWJ9IGFzIHN0YXRlKSAtPlxuICAgICAgICBpZiBuPWxlblxuICAgICAgICB0aGVuIG1hdGNoIG5leHQgc3ViICgpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gbS5zdCA8LSBEb25lOyBOb25lXG4gICAgICAgICAgfCBTb21lIGwgLT5cbiAgICAgICAgICAgICAgc3RhdGUubCA8LSBsO1xuICAgICAgICAgICAgICBzdGF0ZS5uIDwtIDA7XG4gICAgICAgICAgICAgIG5leHQgbSAoKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBzdGF0ZS5uIDwtIHN0YXRlLm4gKyAxO1xuICAgICAgICAgIFNvbWUgKGluc2VydCB4IG4gbClcbiAgICAgICAgKVxuICBhbmQgaW5zZXJ0IHggbiBsID0gbWF0Y2ggbiwgbCB3aXRoXG4gICAgfCAwLCBfIC0+IHg6OmxcbiAgICB8IF8sIFtdIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgXywgeTo6dGFpbCAtPiB5IDo6IGluc2VydCB4IChuLTEpIHRhaWxcbiAgaW5cbiAgbGV0IGwgPSBmb2xkIChmdW4gYWNjIHgtPng6OmFjYykgW10gZyBpblxuICBuZXh0IChtYWtlX21hY2hpbmUgKExpc3QubGVuZ3RoIGwpIGwpXG5cbigqJFQgcGVybXV0YXRpb25zXG4gIHBlcm11dGF0aW9ucyAoMS0tMykgfD4gdG9fbGlzdCB8PiBMaXN0LnNvcnQgR2VuU2hpbXNfLlN0ZGxpYi5jb21wYXJlID0gXFxcbiAgICBbWzE7MjszXTsgWzE7MzsyXTsgWzI7MTszXTsgWzI7MzsxXTsgWzM7MTsyXTsgWzM7MjsxXV1cbiAgcGVybXV0YXRpb25zIGVtcHR5IHw+IHRvX2xpc3QgPSBbW11dXG4gIHBlcm11dGF0aW9ucyAoc2luZ2xldG9uIDEpIHw+IHRvX2xpc3QgPSBbWzFdXVxuKilcblxuXG4oKlxuQ3JlZGl0cyB0byBCZXJuYXJkbyBGcmVpdGFzIFBhdWxvIGRhIENvc3RhIGZvciBbcGVybXV0YXRpb25zX2hlYXBdIVxuXG5CLlIuSGVhcCdzIGFsZ29yaXRobSBmb3IgcGVybXV0YXRpb25zLFxuY2YgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZWFwJTI3c19hbGdvcml0aG0uXG5cbkNvbnRpbnVhdGlvbi1iYXNlZCByZWN1cnNpdmUgZm9ybXVsYSwgbW9kZWwgZm9yIHRoZSBzdGF0ZSBtYW5pcHVsYXRpb25zXG5iZWxvdzpcbiAgIHtbXG4gICAgIGxldCByZWMgaGVhcF9wZXJtIGsgYSBuID1cbiAgICAgICBtYXRjaCBuIHdpdGhcbiAgICAgICB8IDAgLT4gayBhXG4gICAgICAgfCBuIC0+XG4gICAgICAgICAgIGZvciBpID0gMCB0byBuLTEgZG9cbiAgICAgICAgICAgICBoZWFwX3Blcm0gayBhIChuLTEpO1xuICAgICAgICAgICAgIGxldCBqID0gKGlmIG4gbW9kIDIgPSAxIHRoZW4gMCBlbHNlIGkpIGluXG4gICAgICAgICAgICAgbGV0IHQgPSBhLihqKSBpblxuICAgICAgICAgICAgIGEuKGopIDwtIGEuKG4tMSk7XG4gICAgICAgICAgICAgYS4obi0xKSA8LSB0XG4gICAgICAgICAgIGRvbmVcbiAgIF19XG4qKVxuXG4oKiBUaGUgc3RhdGUgb2YgdGhlIHBlcm11dGF0aW9uIG1hY2hpbmUsIGNvbnRhaW5pbmdcbiAgIC0gdGhlIGFycmF5IFthXSB3ZSdyZSBwZXJtdXRpbmcsIGluIHRoZSBcImN1cnJlbnQgcGVybXV0YXRpb25cIjtcbiAgIC0gdGhlIGxldmVsIG9mIHJlY3Vyc2lvbiBbbl06IHdlIGNhbiBwZXJtdXRlIGVsZW1lbnRzIHdpdGggaW5kZXggPCBbbl1cbiAgIC0gdGhlIHN0YWNrIG9mIHZhbHVlcyBvZiBpbmRpY2VzIHRvIHBlcm11dGUgW2ldIGluIHRoZSBsaXN0IFtpc11cbiAgIFRoZSBwZXJtdXRhdGlvbiBzdG9wcyB3aGVuIHdlIGhhdmUgbm8gbW9yZSBlbGVtZW50cyBpbiB0aGUgc3RhY2sgW2lzXS5cbiopXG5tb2R1bGUgSGVhcFBlcm1TdGF0ZSA9IHN0cnVjdFxuICB0eXBlICdhIHN0YXRlID0ge1xuICAgIGVsdHMgOiAnYSBhcnJheTtcbiAgICBtdXRhYmxlIG4gOiBpbnQ7XG4gICAgbXV0YWJsZSBpcyA6IGludCBsaXN0O1xuICB9XG5lbmRcblxubGV0IHBlcm11dGF0aW9uc19oZWFwIGcgPVxuICBsZXQgb3BlbiBIZWFwUGVybVN0YXRlIGluXG4gIGxldCBsID0gZm9sZCAoZnVuIGFjYyB4LT54OjphY2MpIFtdIGcgaW5cbiAgbGV0IGEgPSBBcnJheS5vZl9saXN0IGwgaW5cbiAgbGV0IHJlYyBuZXh0IHN0ICgpID0gbWF0Y2ggc3QubiB3aXRoXG4gICAgfCAwIC0+XG4gICAgICAgIGJlZ2luIG1hdGNoIHN0LmlzIHdpdGhcbiAgICAgICAgICB8IFtdIHwgXzo6W10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCAwOjppOjppcycgLT4gKCogXCJQb3Agc3RhdGVcIiBiZWZvcmUgcmV0dXJuaW5nIG5leHQgZWxlbWVudCAqKVxuICAgICAgICAgICAgICBzdC5pcyA8LSAoaSsxKTo6aXMnO1xuICAgICAgICAgICAgICBzdC5uIDwtIDE7XG4gICAgICAgICAgICAgIFNvbWUgKEFycmF5LmNvcHkgYSlcbiAgICAgICAgICB8IF86Ol86Ol8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgIGVuZFxuICAgIHwgbiAtPlxuICAgICAgICBtYXRjaCBzdC5pcyB3aXRoXG4gICAgICAgIHwgW10gLT4gTm9uZVxuICAgICAgICB8IGk6OmlzJyB3aGVuIGkgPSBuIC0+ICgqIFBvcCBzdGF0ZSBhdCBlbmQgb2YgbG9vcCAqKVxuICAgICAgICAgICAgc3QuaXMgPC0gaXMnO1xuICAgICAgICAgICAgc3QubiA8LSBuKzE7XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBzdC5pcyB3aXRoXG4gICAgICAgICAgICAgIHwgW10gLT4gTm9uZSAoKiBsYXN0IGxvb3AgKilcbiAgICAgICAgICAgICAgfCBpOjppcycgLT5cbiAgICAgICAgICAgICAgICAgIGxldCBqID0gKGlmIHN0Lm4gbW9kIDIgPSAxIHRoZW4gMCBlbHNlIGkpIGluXG4gICAgICAgICAgICAgICAgICBsZXQgdG1wID0gc3QuZWx0cy4oaikgaW5cbiAgICAgICAgICAgICAgICAgIHN0LmVsdHMuKGopIDwtIHN0LmVsdHMuKG4pO1xuICAgICAgICAgICAgICAgICAgc3QuZWx0cy4obikgPC0gdG1wO1xuICAgICAgICAgICAgICAgICAgc3QuaXMgPC0gKGkrMSk6OmlzJztcbiAgICAgICAgICAgICAgICAgIG5leHQgc3QgKClcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF86Ol8gLT4gKCogUmVjdXJzZSBkb3duIGFuZCBzdGFydCBuZXcgbG9vcCAqKVxuICAgICAgICAgICAgc3QubiA8LSBuLTE7XG4gICAgICAgICAgICBzdC5pcyA8LSAwIDo6IHN0LmlzO1xuICAgICAgICAgICAgbmV4dCBzdCAoKVxuICBpblxuICBsZXQgbiA9IEFycmF5Lmxlbmd0aCBhIGluXG4gIGlmIG4gPSAwIHRoZW4gZW1wdHlcbiAgZWxzZSBuZXh0IHtlbHRzID0gYTsgbj1uOyBpcz1bMF19XG5cbigqJFQgcGVybXV0YXRpb25zX2hlYXBcbiAgcGVybXV0YXRpb25zX2hlYXAgKDEtLTMpIHw+IHRvX2xpc3QgfD4gTGlzdC5zb3J0IEdlblNoaW1zXy5TdGRsaWIuY29tcGFyZSA9IFxcXG4gICAgW1t8MTsyOzN8XTsgW3wxOzM7MnxdOyBbfDI7MTszfF07IFt8MjszOzF8XTsgW3wzOzE7MnxdOyBbfDM7MjsxfF1dXG4gIHBlcm11dGF0aW9uc19oZWFwIGVtcHR5IHw+IHRvX2xpc3QgPSBbXVxuICBwZXJtdXRhdGlvbnNfaGVhcCAoc2luZ2xldG9uIDEpIHw+IHRvX2xpc3QgPSBbW3wxfF1dXG4qKVxuXG5tb2R1bGUgQ29tYlN0YXRlID0gc3RydWN0XG4gIHR5cGUgJ2Egc3RhdGUgPVxuICAgIHwgRG9uZVxuICAgIHwgQmFzZVxuICAgIHwgQWRkIG9mICdhICogJ2EgdCAqICdhIHQgKCogYWRkIHggYXQgYmVnaW5uaW5nIG9mIGZpcnN0OyB0aGVuIHN3aXRjaCB0byBzZWNvbmQgKilcbiAgICB8IEZvbGxvdyBvZiAnYSB0ICAoKiBqdXN0IGZvcndhcmQgKilcbiAgYW5kICdhIHQgPSB7XG4gICAgbXV0YWJsZSBzdCA6ICdhIHN0YXRlXG4gIH1cbmVuZFxuXG5sZXQgY29tYmluYXRpb25zIG4gZyA9XG4gIGxldCBvcGVuIENvbWJTdGF0ZSBpblxuICBhc3NlcnQgKG4gPj0gMCk7XG4gIGxldCByZWMgbWFrZV9zdGF0ZSBuIGwgPSBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDAsIF8gLT4ge3N0PUJhc2V9XG4gICAgfCBfLCBbXSAtPiB7c3Q9RG9uZX1cbiAgICB8IF8sIHg6OnRhaWwgLT5cbiAgICAgICAgbGV0IG0xID0gbWFrZV9zdGF0ZSAobi0xKSB0YWlsIGluXG4gICAgICAgIGxldCBtMiA9IG1ha2Vfc3RhdGUgbiB0YWlsIGluXG4gICAgICAgIHtzdD1BZGQoeCxtMSxtMil9XG4gIGFuZCBuZXh0IG0gKCkgPSBtYXRjaCBtLnN0IHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgQmFzZSAtPiBtLnN0IDwtIERvbmU7IFNvbWUgW11cbiAgICB8IEZvbGxvdyBtIC0+XG4gICAgICAgIGJlZ2luIG1hdGNoIG5leHQgbSAoKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IG0uc3QgPC0gRG9uZTsgTm9uZVxuICAgICAgICAgIHwgU29tZSBfIGFzIHJlcyAtPiByZXNcbiAgICAgICAgZW5kXG4gICAgfCBBZGQgKHgsIG0xLCBtMikgLT5cbiAgICAgICAgbWF0Y2ggbmV4dCBtMSAoKSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgbS5zdCA8LSBGb2xsb3cgbTI7XG4gICAgICAgICAgICBuZXh0IG0gKClcbiAgICAgICAgfCBTb21lIGwgLT4gU29tZSAoeDo6bClcbiAgaW5cbiAgbGV0IGwgPSBmb2xkIChmdW4gYWNjIHgtPng6OmFjYykgW10gZyBpblxuICBuZXh0IChtYWtlX3N0YXRlIG4gbClcblxuKCokVFxuICBjb21iaW5hdGlvbnMgMiAoMS0tNCkgfD4gbWFwIChMaXN0LnNvcnQgR2VuU2hpbXNfLlN0ZGxpYi5jb21wYXJlKSBcXFxuICAgIHw+IHRvX2xpc3QgfD4gTGlzdC5zb3J0IEdlblNoaW1zXy5TdGRsaWIuY29tcGFyZSA9IFxcXG4gICAgW1sxOzJdOyBbMTszXTsgWzE7NF07IFsyOzNdOyBbMjs0XTsgWzM7NF1dXG4gIGNvbWJpbmF0aW9ucyAwICgxLS00KSB8PiB0b19saXN0ID0gW1tdXVxuICBjb21iaW5hdGlvbnMgMSAoc2luZ2xldG9uIDEpIHw+IHRvX2xpc3QgPSBbWzFdXVxuKilcblxubW9kdWxlIFBvd2VyU2V0U3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSAnYSBzdGF0ZSA9XG4gICAgfCBEb25lXG4gICAgfCBCYXNlXG4gICAgfCBBZGQgb2YgJ2EgKiAnYSB0ICgqIGFkZCB4IGJlZm9yZSBhbnkgcmVzdWx0IG9mIG0gKilcbiAgICB8IEFkZFRvIG9mICdhIGxpc3QgKiAnYSAqICdhIHQgKCogeWllbGQgeDo6bGlzdCwgdGhlbiBiYWNrIHRvIEFkZCh4LG0pICopXG4gIGFuZCAnYSB0ID0ge1xuICAgIG11dGFibGUgc3QgOiAnYSBzdGF0ZVxuICB9XG5lbmRcblxubGV0IHBvd2VyX3NldCBnID1cbiAgbGV0IG9wZW4gUG93ZXJTZXRTdGF0ZSBpblxuICBsZXQgcmVjIG1ha2Vfc3RhdGUgbCA9IG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4ge3N0PUJhc2V9XG4gICAgfCB4Ojp0YWlsIC0+XG4gICAgICAgIGxldCBtID0gbWFrZV9zdGF0ZSB0YWlsIGluXG4gICAgICAgIHtzdD1BZGQoeCxtKX1cbiAgYW5kIG5leHQgbSAoKSA9IG1hdGNoIG0uc3Qgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBCYXNlIC0+IG0uc3QgPC0gRG9uZTsgU29tZSBbXVxuICAgIHwgQWRkICh4LG0nKSAtPlxuICAgICAgICBiZWdpbiBtYXRjaCBuZXh0IG0nICgpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gbS5zdCA8LSBEb25lOyBOb25lXG4gICAgICAgICAgfCBTb21lIGwgYXMgcmVzIC0+IG0uc3QgPC0gQWRkVG8obCx4LG0nKTsgcmVzXG4gICAgICAgIGVuZFxuICAgIHwgQWRkVG8gKGwsIHgsIG0nKSAtPlxuICAgICAgICBtLnN0IDwtIEFkZCAoeCxtJyk7XG4gICAgICAgIFNvbWUgKHg6OmwpXG4gIGluXG4gIGxldCBsID0gZm9sZCAoZnVuIGFjYyB4LT54OjphY2MpIFtdIGcgaW5cbiAgbmV4dCAobWFrZV9zdGF0ZSBsKVxuXG4oKiRUXG4gIHBvd2VyX3NldCAoMS0tMykgfD4gbWFwIChMaXN0LnNvcnQgR2VuU2hpbXNfLlN0ZGxpYi5jb21wYXJlKSBcXFxuICAgIHw+IHRvX2xpc3QgfD4gTGlzdC5zb3J0IEdlblNoaW1zXy5TdGRsaWIuY29tcGFyZSA9IFxcXG4gICAgW1tdOyBbMV07IFsxOzJdOyBbMTsyOzNdOyBbMTszXTsgWzJdOyBbMjszXTsgWzNdXVxuICBwb3dlcl9zZXQgZW1wdHkgfD4gdG9fbGlzdCA9IFtbXV1cbiAgcG93ZXJfc2V0IChzaW5nbGV0b24gMSkgfD4gbWFwIChMaXN0LnNvcnQgR2VuU2hpbXNfLlN0ZGxpYi5jb21wYXJlKSBcXFxuICAgIHw+IHRvX2xpc3QgfD4gTGlzdC5zb3J0IEdlblNoaW1zXy5TdGRsaWIuY29tcGFyZSA9IFtbXTsgWzFdXVxuKilcblxuKCoqIHszIENvbnZlcnNpb259ICopXG5cbmxldCBvZl9saXN0IGwgPVxuICBsZXQgbCA9IHJlZiBsIGluXG4gIGZ1biAoKSAtPlxuICAgIG1hdGNoICFsIHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHg6OmwnIC0+IGwgOj0gbCc7IFNvbWUgeFxuXG5sZXQgdG9fcmV2X2xpc3QgZ2VuID1cbiAgZm9sZCAoZnVuIGFjYyB4IC0+IHggOjogYWNjKSBbXSBnZW5cblxuKCokUVxuICAoUS5saXN0IFEuc21hbGxfaW50KSAoZnVuIGwgLT4gXFxcbiAgICB0b19yZXZfbGlzdCAob2ZfbGlzdCBsKSA9IExpc3QucmV2IGwpXG4qKVxuXG5sZXQgdG9fbGlzdCBnZW4gPSBMaXN0LnJldiAodG9fcmV2X2xpc3QgZ2VuKVxuXG5sZXQgdG9fYXJyYXkgZ2VuID1cbiAgbGV0IGwgPSB0b19yZXZfbGlzdCBnZW4gaW5cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW3wgfF1cbiAgfCBfIC0+XG4gICAgICBsZXQgYSA9IEFycmF5Lm9mX2xpc3QgbCBpblxuICAgICAgbGV0IG4gPSBBcnJheS5sZW5ndGggYSBpblxuICAgICAgKCogcmV2ZXJzZSBhcnJheSAqKVxuICAgICAgZm9yIGkgPSAwIHRvIChuLTEpIC8gMiBkb1xuICAgICAgICBsZXQgdG1wID0gYS4oaSkgaW5cbiAgICAgICAgYS4oaSkgPC0gYS4obi1pLTEpO1xuICAgICAgICBhLihuLWktMSkgPC0gdG1wXG4gICAgICBkb25lO1xuICAgICAgYVxuXG5sZXQgb2ZfYXJyYXkgPyhzdGFydD0wKSA/bGVuIGEgPVxuICBsZXQgbGVuID0gbWF0Y2ggbGVuIHdpdGhcbiAgICB8IE5vbmUgLT4gQXJyYXkubGVuZ3RoIGEgLSBzdGFydFxuICAgIHwgU29tZSBuIC0+IGFzc2VydCAobiArIHN0YXJ0IDwgQXJyYXkubGVuZ3RoIGEpOyBuIGluXG4gIGxldCBpID0gcmVmIHN0YXJ0IGluXG4gIGZ1biAoKSAtPlxuICAgIGlmICFpID49IHN0YXJ0ICsgbGVuXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZSAobGV0IHggPSBhLighaSkgaW4gaW5jciBpOyBTb21lIHgpXG5cbigqJFFcbiAgKFEuYXJyYXkgUS5zbWFsbF9pbnQpIChmdW4gYSAtPiBcXFxuICAgIG9mX2FycmF5IGEgfD4gdG9fYXJyYXkgPSBhKVxuKilcblxubGV0IG9mX3N0cmluZyA/KHN0YXJ0PTApID9sZW4gcyA9XG4gIGxldCBsZW4gPSBtYXRjaCBsZW4gd2l0aFxuICAgIHwgTm9uZSAtPiBTdHJpbmcubGVuZ3RoIHMgLSBzdGFydFxuICAgIHwgU29tZSBuIC0+IGFzc2VydCAobiArIHN0YXJ0IDwgU3RyaW5nLmxlbmd0aCBzKTsgbiBpblxuICBsZXQgaSA9IHJlZiBzdGFydCBpblxuICBmdW4gKCkgLT5cbiAgICBpZiAhaSA+PSBzdGFydCArIGxlblxuICAgIHRoZW4gTm9uZVxuICAgIGVsc2UgKGxldCB4ID0gcy5bIWldIGluIGluY3IgaTsgU29tZSB4KVxuXG5sZXQgdG9fYnVmZmVyIGJ1ZiBnID1cbiAgaXRlciAoQnVmZmVyLmFkZF9jaGFyIGJ1ZikgZ1xuXG5sZXQgdG9fc3RyaW5nIHMgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAxNiBpblxuICB0b19idWZmZXIgYnVmIHM7XG4gIEJ1ZmZlci5jb250ZW50cyBidWZcblxubGV0IG9mX3NlcSBzZXEgOiBfIHQgPVxuICBsZXQgc2VxID0gcmVmIHNlcSBpblxuICBmdW4gKCkgLT5cbiAgICBtYXRjaCAhc2VxICgpIHdpdGhcbiAgICB8IFNlcS5OaWwgLT4gTm9uZVxuICAgIHwgU2VxLkNvbnMgKHgsdGwpIC0+XG4gICAgICAgIHNlcSA6PSB0bDtcbiAgICAgICAgU29tZSB4XG5cbmxldCByYW5kX2ludCBpID1cbiAgcmVwZWF0ZWRseSAoZnVuICgpIC0+IFJhbmRvbS5pbnQgaSlcblxubGV0IGludF9yYW5nZSA/KHN0ZXA9MSkgaSBqID1cbiAgaWYgc3RlcCA9IDAgdGhlbiByYWlzZSAoSW52YWxpZF9hcmd1bWVudCBcIkdlbi5pbnRfcmFuZ2VcIik7XG4gIGxldCAoPikgPSBpZiBzdGVwID4gMCB0aGVuICg+KSBlbHNlICg8KSBpblxuICBsZXQgciA9IHJlZiBpIGluXG4gIGZ1biAoKSAtPlxuICAgIGxldCB4ID0gIXIgaW5cbiAgICBpZiB4ID4gaiB0aGVuIE5vbmVcbiAgICBlbHNlIGJlZ2luXG4gICAgICByIDo9ICFyICsgc3RlcDtcbiAgICAgIFNvbWUgeFxuICAgIGVuZFxuXG4oKiQ9ICYgfnByaW50ZXI6US5QcmludC4obGlzdCBpbnQpXG4gIFsxOzI7Mzs0XSAoaW50X3JhbmdlIDEgNCB8PiB0b19saXN0KVxuICBbNDszOzI7MV0gKGludF9yYW5nZSB+c3RlcDp+LTEgNCAxIHw+IHRvX2xpc3QpXG4gIFs2OzQ7Ml0gKGludF9yYW5nZSA2IDEgfnN0ZXA6fi0yIHw+IHRvX2xpc3QpXG4gIFtdIChpbnRfcmFuZ2UgNCAxIHw+IHRvX2xpc3QpXG4qKVxuXG5sZXQgbGluZXMgZyA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDMyIGluXG4gIGxldCBzdG9wID0gcmVmIGZhbHNlIGluXG4gIGxldCByZWMgbmV4dCgpID1cbiAgICBpZiAhc3RvcCB0aGVuIE5vbmVcbiAgICBlbHNlIG1hdGNoIGcoKSB3aXRoXG4gICAgICB8IE5vbmUgLT4gc3RvcCA6PSB0cnVlO1xuICAgICAgICAgICgqIG9ubHkgcmV0dXJuIGEgbm9uLWVtcHR5IGxpbmUgKilcbiAgICAgICAgICBpZiBCdWZmZXIubGVuZ3RoIGJ1ZiA9MCB0aGVuIE5vbmUgZWxzZSBTb21lIChCdWZmZXIuY29udGVudHMgYnVmKVxuICAgICAgfCBTb21lICdcXG4nIC0+XG4gICAgICAgICAgbGV0IHMgPSBCdWZmZXIuY29udGVudHMgYnVmIGluXG4gICAgICAgICAgQnVmZmVyLmNsZWFyIGJ1ZjtcbiAgICAgICAgICBTb21lIHNcbiAgICAgIHwgU29tZSBjIC0+IEJ1ZmZlci5hZGRfY2hhciBidWYgYzsgbmV4dCAoKVxuICBpblxuICBuZXh0XG5cbigqJD0gJiB+cHJpbnRlcjpRLlByaW50LihsaXN0IHN0cmluZylcbiAgW1wiYWJjXCI7IFwiZGVcIjsgXCJcIl0gKGxpbmVzIChvZl9zdHJpbmcgXCJhYmNcXG5kZVxcblxcblwiKSB8PiB0b19saXN0KVxuKilcblxubGV0IHVubGluZXMgZyA9XG4gIGxldCBzdCA9IHJlZiBgTmV4dCBpblxuICBmdW4gKCkgLT4gbWF0Y2ggIXN0IHdpdGhcbiAgICB8IGBTdG9wIC0+IE5vbmVcbiAgICB8IGBOZXh0IC0+XG4gICAgICAgIGJlZ2luICBtYXRjaCBnKCkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBzdCA6PSBgU3RvcDsgTm9uZVxuICAgICAgICAgIHwgU29tZSBcIlwiIC0+IFNvbWUgJ1xcbicgKCogZW1wdHkgbGluZSAqKVxuICAgICAgICAgIHwgU29tZSBzIC0+IHN0IDo9IGBDb25zdW1lIChzLCAxKTsgU29tZSBzLlswXVxuICAgICAgICBlbmRcbiAgICB8IGBDb25zdW1lIChzLCBpKSB3aGVuIGk9U3RyaW5nLmxlbmd0aCBzIC0+XG4gICAgICAgIHN0IDo9IGBOZXh0O1xuICAgICAgICBTb21lICdcXG4nXG4gICAgfCBgQ29uc3VtZSAocywgaSkgLT5cbiAgICAgICAgc3QgOj0gYENvbnN1bWUgKHMsIGkrMSk7IFNvbWUgcy5baV1cblxuKCokUVxuICBRLnByaW50YWJsZV9zdHJpbmcgKGZ1biBzIC0+IFxcXG4gICAgb2Zfc3RyaW5nIHMgfD4gbGluZXMgfD4gdW5saW5lcyB8PiB0b19zdHJpbmcgfD4gU3RyaW5nLnRyaW0gPSBTdHJpbmcudHJpbSBzKVxuKilcblxubGV0IHBwID8oc3RhcnQ9XCJcIikgPyhzdG9wPVwiXCIpID8oc2VwPVwiLFwiKSA/KGhvcml6b250YWw9ZmFsc2UpIHBwX2VsZW0gZm9ybWF0dGVyIGdlbiA9XG4gIChpZiBob3Jpem9udGFsXG4gICB0aGVuIEZvcm1hdC5wcF9vcGVuX2hib3ggZm9ybWF0dGVyICgpXG4gICBlbHNlIEZvcm1hdC5wcF9vcGVuX2h2Ym94IGZvcm1hdHRlciAwKTtcbiAgRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmb3JtYXR0ZXIgc3RhcnQ7XG4gIGxldCByZWMgbmV4dCBpc19maXJzdCA9XG4gICAgbWF0Y2ggZ2VuKCkgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICAgIGlmIG5vdCBpc19maXJzdFxuICAgICAgICB0aGVuIGJlZ2luXG4gICAgICAgICAgRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmb3JtYXR0ZXIgc2VwO1xuICAgICAgICAgIEZvcm1hdC5wcF9wcmludF9zcGFjZSBmb3JtYXR0ZXIgKCk7XG4gICAgICAgICAgcHBfZWxlbSBmb3JtYXR0ZXIgeFxuICAgICAgICBlbmQgZWxzZSBwcF9lbGVtIGZvcm1hdHRlciB4O1xuICAgICAgICBuZXh0IGZhbHNlXG4gICAgfCBOb25lIC0+ICgpXG4gIGluXG4gIG5leHQgdHJ1ZTtcbiAgRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmb3JtYXR0ZXIgc3RvcDtcbiAgRm9ybWF0LnBwX2Nsb3NlX2JveCBmb3JtYXR0ZXIgKClcblxubW9kdWxlIEluZml4ID0gc3RydWN0XG4gIGxldCAoLS0pID0gaW50X3JhbmdlIH5zdGVwOjFcblxuICBsZXQgKD4+PSkgeCBmID0gZmxhdF9tYXAgZiB4XG4gIGxldCAoPj58KSB4IGYgPSBtYXAgZiB4XG4gIGxldCAoPnw9KSB4IGYgPSBtYXAgZiB4XG5lbmRcblxuaW5jbHVkZSBJbmZpeFxuXG5tb2R1bGUgUmVzdGFydCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSB1bml0IC0+ICdhIGdlblxuXG4gIHR5cGUgJ2EgcmVzdGFydGFibGUgPSAnYSB0XG5cbiAgbGV0IGxpZnQgZiBlID0gZiAoZSAoKSlcbiAgbGV0IGxpZnQyIGYgZTEgZTIgPSBmIChlMSAoKSkgKGUyICgpKVxuXG4gIGxldCBlbXB0eSAoKSA9IGVtcHR5XG5cbiAgbGV0IHNpbmdsZXRvbiB4ICgpID0gc2luZ2xldG9uIHhcblxuICBsZXQgcmV0dXJuID0gc2luZ2xldG9uXG5cbiAgbGV0IGl0ZXJhdGUgeCBmICgpID0gaXRlcmF0ZSB4IGZcblxuICBsZXQgcmVwZWF0IHggKCkgPSByZXBlYXQgeFxuXG4gIGxldCB1bmZvbGQgZiBhY2MgKCkgPSB1bmZvbGQgZiBhY2NcblxuICBsZXQgaW5pdCA/bGltaXQgZiAoKSA9IGluaXQgP2xpbWl0IGZcblxuICBsZXQgY3ljbGUgZW51bSA9XG4gICAgYXNzZXJ0IChub3QgKGlzX2VtcHR5IChlbnVtICgpKSkpO1xuICAgIGZ1biAoKSAtPlxuICAgICAgbGV0IGdlbiA9IHJlZiAoZW51bSAoKSkgaW4gICgqIHN0YXJ0IGN5Y2xlICopXG4gICAgICBsZXQgcmVjIG5leHQgKCkgPVxuICAgICAgICBtYXRjaCAoIWdlbikgKCkgd2l0aFxuICAgICAgICB8IChTb21lIF8pIGFzIHJlcyAtPiByZXNcbiAgICAgICAgfCBOb25lIC0+IGdlbiA6PSBlbnVtKCk7IG5leHQoKVxuICAgICAgaW4gbmV4dFxuXG4gIGxldCBpc19lbXB0eSBlID0gaXNfZW1wdHkgKGUgKCkpXG5cbiAgbGV0IGZvbGQgZiBhY2MgZSA9IGZvbGQgZiBhY2MgKGUgKCkpXG5cbiAgbGV0IHJlZHVjZSBmIGUgPSByZWR1Y2UgZiAoZSAoKSlcblxuICBsZXQgc2NhbiBmIGFjYyBlICgpID0gc2NhbiBmIGFjYyAoZSAoKSlcblxuICBsZXQgdW5mb2xkX3NjYW4gZiBhY2MgZSAoKSA9IHVuZm9sZF9zY2FuIGYgYWNjIChlKCkpXG5cbiAgbGV0IGl0ZXIgZiBlID0gaXRlciBmIChlICgpKVxuXG4gIGxldCBpdGVyaSBmIGUgPSBpdGVyaSBmIChlICgpKVxuXG4gIGxldCBsZW5ndGggZSA9IGxlbmd0aCAoZSAoKSlcblxuICBsZXQgbWFwIGYgZSAoKSA9IG1hcCBmIChlICgpKVxuXG4gIGxldCBtYXBpIGYgZSAoKSA9IG1hcGkgZiAoZSAoKSlcblxuICBsZXQgZm9sZF9tYXAgZiBzIGUgKCkgPSBmb2xkX21hcCBmIHMgKGUgKCkpXG5cbiAgbGV0IGFwcGVuZCBlMSBlMiAoKSA9IGFwcGVuZCAoZTEgKCkpIChlMiAoKSlcblxuICBsZXQgZmxhdHRlbiBlICgpID0gZmxhdHRlbiAoZSAoKSlcblxuICBsZXQgZmxhdF9tYXAgZiBlICgpID0gZmxhdF9tYXAgZiAoZSAoKSlcblxuICBsZXQgbWVtID9lcSB4IGUgPSBtZW0gP2VxIHggKGUgKCkpXG5cbiAgbGV0IHRha2UgbiBlICgpID0gdGFrZSBuIChlICgpKVxuXG4gIGxldCBkcm9wIG4gZSAoKSA9IGRyb3AgbiAoZSAoKSlcblxuICBsZXQgbnRoIG4gZSA9IG50aCBuIChlICgpKVxuXG4gIGxldCB0YWtlX250aCBuIGUgKCkgPSB0YWtlX250aCBuIChlICgpKVxuXG4gIGxldCBmaWx0ZXIgcCBlICgpID0gZmlsdGVyIHAgKGUgKCkpXG5cbiAgbGV0IHRha2Vfd2hpbGUgcCBlICgpID0gdGFrZV93aGlsZSBwIChlICgpKVxuXG4gIGxldCBmb2xkX3doaWxlIGYgcyBlID0gZm9sZF93aGlsZSBmIHMgKGUgKCkpXG5cbiAgbGV0IGRyb3Bfd2hpbGUgcCBlICgpID0gZHJvcF93aGlsZSBwIChlICgpKVxuXG4gIGxldCBmaWx0ZXJfbWFwIGYgZSAoKSA9IGZpbHRlcl9tYXAgZiAoZSAoKSlcblxuICBsZXQgemlwX3dpdGggZiBlMSBlMiAoKSA9IHppcF93aXRoIGYgKGUxICgpKSAoZTIgKCkpXG5cbiAgbGV0IHppcCBlMSBlMiAoKSA9IHppcCAoZTEgKCkpIChlMiAoKSlcblxuICBsZXQgemlwX2luZGV4IGUgKCkgPSB6aXBfaW5kZXggKGUgKCkpXG5cbiAgbGV0IHVuemlwIGUgPSBtYXAgZnN0IGUsIG1hcCBzbmQgZVxuXG4gIGxldCBwYXJ0aXRpb24gcCBlID1cbiAgICBmaWx0ZXIgcCBlLCBmaWx0ZXIgKGZ1biB4IC0+IG5vdCAocCB4KSkgZVxuXG4gIGxldCBmb3JfYWxsIHAgZSA9XG4gICAgZm9yX2FsbCBwIChlICgpKVxuXG4gIGxldCBleGlzdHMgcCBlID1cbiAgICBleGlzdHMgcCAoZSAoKSlcblxuICBsZXQgZm9yX2FsbDIgcCBlMSBlMiA9XG4gICAgZm9yX2FsbDIgcCAoZTEgKCkpIChlMiAoKSlcblxuICBsZXQgZXhpc3RzMiBwIGUxIGUyID1cbiAgICBleGlzdHMyIHAgKGUxICgpKSAoZTIgKCkpXG5cbiAgbGV0IG1hcDIgZiBlMSBlMiAoKSA9XG4gICAgbWFwMiBmIChlMSgpKSAoZTIoKSlcblxuICBsZXQgaXRlcjIgZiBlMSBlMiA9XG4gICAgaXRlcjIgZiAoZTEoKSkgKGUyKCkpXG5cbiAgbGV0IGZvbGQyIGYgYWNjIGUxIGUyID1cbiAgICBmb2xkMiBmIGFjYyAoZTEoKSkgKGUyKCkpXG5cbiAgbGV0IG1pbiA/bHQgZSA9IG1pbiA/bHQgKGUgKCkpXG5cbiAgbGV0IG1heCA/bHQgZSA9IG1heCA/bHQgKGUgKCkpXG5cbiAgbGV0IF9fX2VxID0gZXFcbiAgbGV0IGVxID9lcSBlMSBlMiA9IF9fX2VxID9lcSAoZTEgKCkpIChlMiAoKSlcblxuICBsZXQgbGV4aWNvID9jbXAgZTEgZTIgPSBsZXhpY28gP2NtcCAoZTEgKCkpIChlMiAoKSlcblxuICBsZXQgY29tcGFyZSA/Y21wIGUxIGUyID0gY29tcGFyZSA/Y21wIChlMSAoKSkgKGUyICgpKVxuXG4gIGxldCBzdW0gZSA9IHN1bSAoZSgpKVxuXG4gIGxldCBmaW5kIGYgZSA9IGZpbmQgZiAoZSgpKVxuXG4gIGxldCBtZXJnZSBlICgpID0gbWVyZ2UgKGUgKCkpXG5cbiAgbGV0IGludGVyc2VjdGlvbiA/Y21wIGUxIGUyICgpID1cbiAgICBpbnRlcnNlY3Rpb24gP2NtcCAoZTEgKCkpIChlMiAoKSlcblxuICBsZXQgc29ydGVkX21lcmdlID9jbXAgZTEgZTIgKCkgPVxuICAgIHNvcnRlZF9tZXJnZSA/Y21wIChlMSAoKSkgKGUyICgpKVxuXG4gIGxldCBzb3J0ZWRfbWVyZ2VfbiA/Y21wIGwgKCkgPVxuICAgIHNvcnRlZF9tZXJnZV9uID9jbXAgKExpc3QubWFwIChmdW4gZyAtPiBnKCkpIGwpXG5cbiAgbGV0IHRlZSA/biBlID0gdGVlID9uIChlICgpKVxuXG4gIGxldCByb3VuZF9yb2JpbiA/biBlID0gcm91bmRfcm9iaW4gP24gKGUgKCkpXG5cbiAgbGV0IGludGVybGVhdmUgZTEgZTIgKCkgPSBpbnRlcmxlYXZlIChlMSAoKSkgKGUyICgpKVxuXG4gIGxldCBpbnRlcnNwZXJzZSB4IGUgKCkgPSBpbnRlcnNwZXJzZSB4IChlICgpKVxuXG4gIGxldCBwcm9kdWN0IGUxIGUyICgpID0gcHJvZHVjdCAoZTEgKCkpIChlMiAoKSlcblxuICBsZXQgZ3JvdXAgP2VxIGUgKCkgPSBncm91cCA/ZXEgKGUgKCkpXG5cbiAgbGV0IHVuaXEgP2VxIGUgKCkgPSB1bmlxID9lcSAoZSAoKSlcblxuICBsZXQgc29ydCA/KGNtcD1HZW5TaGltc18uU3RkbGliLmNvbXBhcmUpIGVudW0gPVxuICAgIGZ1biAoKSAtPiBzb3J0IH5jbXAgKGVudW0gKCkpXG5cbiAgbGV0IHNvcnRfdW5pcSA/KGNtcD1HZW5TaGltc18uU3RkbGliLmNvbXBhcmUpIGUgPVxuICAgIGxldCBlJyA9IHNvcnQgfmNtcCBlIGluXG4gICAgdW5pcSB+ZXE6KGZ1biB4IHkgLT4gY21wIHggeSA9IDApIGUnXG5cbiAgbGV0IGNodW5rcyBuIGUgKCkgPSBjaHVua3MgbiAoZSgpKVxuXG4gIGxldCBwZXJtdXRhdGlvbnMgZyAoKSA9IHBlcm11dGF0aW9ucyAoZyAoKSlcblxuICBsZXQgcGVybXV0YXRpb25zX2hlYXAgZyAoKSA9IHBlcm11dGF0aW9uc19oZWFwIChnICgpKVxuXG4gIGxldCBjb21iaW5hdGlvbnMgbiBnICgpID0gY29tYmluYXRpb25zIG4gKGcoKSlcblxuICBsZXQgcG93ZXJfc2V0IGcgKCkgPSBwb3dlcl9zZXQgKGcoKSlcblxuICBsZXQgb2ZfbGlzdCBsICgpID0gb2ZfbGlzdCBsXG5cbiAgbGV0IHRvX3Jldl9saXN0IGUgPSB0b19yZXZfbGlzdCAoZSAoKSlcblxuICBsZXQgdG9fbGlzdCBlID0gdG9fbGlzdCAoZSAoKSlcblxuICBsZXQgdG9fYXJyYXkgZSA9IHRvX2FycmF5IChlICgpKVxuXG4gIGxldCBvZl9hcnJheSA/c3RhcnQgP2xlbiBhICgpID0gb2ZfYXJyYXkgP3N0YXJ0ID9sZW4gYVxuXG4gIGxldCBvZl9zdHJpbmcgP3N0YXJ0ID9sZW4gcyAoKSA9IG9mX3N0cmluZyA/c3RhcnQgP2xlbiBzXG5cbiAgbGV0IHRvX3N0cmluZyBzID0gdG9fc3RyaW5nIChzICgpKVxuXG4gIGxldCB0b19idWZmZXIgYnVmIHMgPSB0b19idWZmZXIgYnVmIChzICgpKVxuXG4gIGxldCB0b19pdGVyIHMgeWllbGQgPSBpdGVyIHlpZWxkIHNcblxuICBsZXQgcmFuZF9pbnQgaSAoKSA9IHJhbmRfaW50IGlcblxuICBsZXQgaW50X3JhbmdlID9zdGVwIGkgaiAoKSA9IGludF9yYW5nZSA/c3RlcCBpIGpcblxuICBsZXQgbGluZXMgZyAoKSA9IGxpbmVzIChnKCkpXG4gIGxldCB1bmxpbmVzIGcgKCkgPSB1bmxpbmVzIChnKCkpXG5cbiAgbW9kdWxlIEluZml4ID0gc3RydWN0XG4gICAgbGV0ICgtLSkgPSBpbnRfcmFuZ2UgfnN0ZXA6MVxuXG4gICAgbGV0ICg+Pj0pIHggZiA9IGZsYXRfbWFwIGYgeFxuICAgIGxldCAoPj58KSB4IGYgPSBtYXAgZiB4XG4gICAgbGV0ICg+fD0pIHggZiA9IG1hcCBmIHhcbiAgZW5kXG5cbiAgaW5jbHVkZSBJbmZpeFxuXG4gIGxldCBwcCA/c3RhcnQgP3N0b3AgP3NlcCA/aG9yaXpvbnRhbCBwcF9lbGVtIGZtdCBlID1cbiAgICBwcCA/c3RhcnQgP3N0b3AgP3NlcCA/aG9yaXpvbnRhbCBwcF9lbGVtIGZtdCAoZSAoKSlcblxuICBsZXQgb2ZfZ2VuID9jYWNoaW5nID9tYXhfY2h1bmtfc2l6ZSBnID1cbiAgICBsZXQgY2FjaGVkID0gcmVmIE5vbmUgaW5cbiAgICBmdW4gKCkgLT5cbiAgICAgIG1hdGNoICFjYWNoZWQgd2l0aFxuICAgICAgfCBTb21lIG1saXN0IC0+IEdlbk1MaXN0LnRvX2dlbiBtbGlzdFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgbGV0IG1saXN0ID0gR2VuTUxpc3Qub2ZfZ2VuX2xhenkgP21heF9jaHVua19zaXplID9jYWNoaW5nIGcgaW5cbiAgICAgICAgICBjYWNoZWQgOj0gU29tZSBtbGlzdDtcbiAgICAgICAgICBHZW5NTGlzdC50b19nZW4gbWxpc3RcblxuICBsZXQgb2Zfc2VxIHNlcSA6IF8gdCA9XG4gICAgZnVuICgpIC0+IG9mX3NlcSBzZXFcbmVuZFxuXG4oKiogezIgR2VuZXJhdG9yIGZ1bmN0aW9uc30gKilcblxubGV0IHN0YXJ0IGcgPSBnICgpXG5cbigqKiBTdG9yZSBjb250ZW50IG9mIHRoZSBnZW5lcmF0b3IgaW4gYW4gZW51bSAqKVxubGV0IHBlcnNpc3RlbnQgZ2VuID1cbiAgbGV0IGwgPSBHZW5NTGlzdC5vZl9nZW4gZ2VuIGluXG4gIGZ1biAoKSAtPiBHZW5NTGlzdC50b19nZW4gbFxuXG4oKiRpbmplY3RcbiAgbGV0IHJlYyBzZXFfdGFrZSBpIHNlcSAoKSA9XG4gICAgaWYgaT0wIHRoZW4gU2VxLk5pbFxuICAgIGVsc2UgbWF0Y2ggc2VxKCkgd2l0aFxuICAgICAgfCBTZXEuTmlsIC0+IFNlcS5OaWxcbiAgICAgIHwgU2VxLkNvbnMgKHgsdGwpIC0+IFNlcS5Db25zICh4LCBzZXFfdGFrZSAoaS0xKSB0bClcblxuICBsZXQgc2VxX3RvX2xpc3Qgc2VxID1cbiAgICBsZXQgcmVjIGF1eCBhY2MgcyA9IG1hdGNoIHMoKSB3aXRoXG4gICAgICB8IFNlcS5OaWwgLT4gTGlzdC5yZXYgYWNjXG4gICAgICB8IFNlcS5Db25zICh4LHRsKSAtPiBhdXggKHg6OmFjYykgdGxcbiAgICBpblxuICAgIGF1eCBbXSBzZXFcbiopXG5cbigqJFRcbiAgbGV0IGcgPSAxLS0xMCBpbiBsZXQgZycgPSBwZXJzaXN0ZW50IGcgaW4gXFxcbiAgICBSZXN0YXJ0LnRvX2xpc3QgZycgPSBSZXN0YXJ0LnRvX2xpc3QgZydcbiAgbGV0IGcgPSAxLS0xMCBpbiBsZXQgZycgPSBwZXJzaXN0ZW50IGcgaW4gXFxcbiAgICBSZXN0YXJ0LnRvX2xpc3QgZycgPSBbMTsyOzM7NDs1OzY7Nzs4Ozk7MTBdXG4qKVxuXG5sZXQgcGVyc2lzdGVudF90b19zZXEgZ2VuIDogXyBTZXEudCA9XG4gIGxldCBsID0gR2VuTUxpc3Qub2ZfZ2VuIGdlbiBpblxuICBHZW5NTGlzdC50b19zZXEgbFxuXG4oKiRUXG4gIGxldCBnID0gMS0tMTAwXzAwMCBpbiBcXFxuICBsZXQgc2VxID0gcGVyc2lzdGVudF90b19zZXEgZyBpbiBcXFxuICAgIChzZXEgfD4gc2VxX3Rha2UgMTAwIHw+IHNlcV90b19saXN0ID0gKDEtLTEwMCB8PiB0b19saXN0KSkgJiYgXFxcbiAgICAoc2VxIHw+IHNlcV90YWtlIDIwMCB8PiBzZXFfdG9fbGlzdCA9ICgxLS0yMDAgfD4gdG9fbGlzdCkpICYmIFxcXG4gICAgKHNlcSB8PiBzZXFfdGFrZSA4MF8wMDAgfD4gc2VxX3RvX2xpc3QgPSAoMS0tODBfMDAwIHw+IHRvX2xpc3QpKSAmJiBcXFxuICAgIChzZXEgfD4gc2VxX3Rha2UgNTBfMDAwIHw+IHNlcV90b19saXN0ID0gKDEtLTUwXzAwMCB8PiB0b19saXN0KSlcbiopXG5cbigqJFJcbiAgbGV0IGkgPSByZWYgMCBpblxuICBsZXQgZ2VuICgpID1cbiAgICBsZXQgaiA9ICFpIGluXG4gICAgaWYgaiA+IDUgdGhlbiBOb25lIGVsc2UgKGluY3IgaTsgU29tZSBqKVxuICBpblxuICBsZXQgZSA9IEdlbi5wZXJzaXN0ZW50IGdlbiBpblxuICBPVW5pdC5hc3NlcnRfZXF1YWwgWzA7MTsyOzM7NDs1XSAoUmVzdGFydC50b19saXN0IGUpO1xuICBPVW5pdC5hc3NlcnRfZXF1YWwgWzA7MTsyOzM7NDs1XSAoUmVzdGFydC50b19saXN0IGUpO1xuICBPVW5pdC5hc3NlcnRfZXF1YWwgWzA7MTsyOzM7NDs1XSAoUmVzdGFydC50b19saXN0IGUpO1xuKilcblxubGV0IHBlcnNpc3RlbnRfbGF6eSA/Y2FjaGluZyA/bWF4X2NodW5rX3NpemUgZ2VuID1cbiAgbGV0IGwgPSBHZW5NTGlzdC5vZl9nZW5fbGF6eSA/bWF4X2NodW5rX3NpemUgP2NhY2hpbmcgZ2VuIGluXG4gIGZ1biAoKSAtPiBHZW5NTGlzdC50b19nZW4gbFxuXG4oKiRUXG4gIGxldCBnID0gMS0tMV8wMDBfMDAwXzAwMCBpbiBsZXQgZycgPSBwZXJzaXN0ZW50X2xhenkgZyBpbiBcXFxuICAgIChnJyAoKSB8PiB0YWtlIDEwMCB8PiB0b19saXN0ID0gKDEtLTEwMCB8PiB0b19saXN0KSkgJiYgXFxcbiAgICAoZycgKCkgfD4gdGFrZSAyMDAgfD4gdG9fbGlzdCA9ICgxLS0yMDAgfD4gdG9fbGlzdCkpXG4qKVxuXG5sZXQgcGVyc2lzdGVudF9sYXp5X3RvX3NlcSA/Y2FjaGluZyA/bWF4X2NodW5rX3NpemUgZ2VuIDogXyBTZXEudCA9XG4gIGxldCBsID0gR2VuTUxpc3Qub2ZfZ2VuX2xhenkgP21heF9jaHVua19zaXplID9jYWNoaW5nIGdlbiBpblxuICBHZW5NTGlzdC50b19zZXEgbFxuXG4oKiRUXG4gIGxldCBnID0gMS0tMV8wMDBfMDAwXzAwMCBpbiBcXFxuICBsZXQgc2VxID0gcGVyc2lzdGVudF9sYXp5X3RvX3NlcSBnIGluIFxcXG4gICAgKHNlcSB8PiBzZXFfdGFrZSAxMDAgfD4gc2VxX3RvX2xpc3QgPSAoMS0tMTAwIHw+IHRvX2xpc3QpKSAmJiBcXFxuICAgIChzZXEgfD4gc2VxX3Rha2UgMjAwIHw+IHNlcV90b19saXN0ID0gKDEtLTIwMCB8PiB0b19saXN0KSkgJiYgXFxcbiAgICAoc2VxIHw+IHNlcV90YWtlIDgwXzAwMCB8PiBzZXFfdG9fbGlzdCA9ICgxLS04MF8wMDAgfD4gdG9fbGlzdCkpICYmIFxcXG4gICAgKHNlcSB8PiBzZXFfdGFrZSA1MF8wMDAgfD4gc2VxX3RvX2xpc3QgPSAoMS0tNTBfMDAwIHw+IHRvX2xpc3QpKVxuKilcblxubGV0IHRvX2l0ZXIgZyB5aWVsZCA9IGl0ZXIgeWllbGQgZ1xuXG5sZXQgcGVlayBnID1cbiAgbGV0IHN0YXRlID0gcmVmIGBTdGFydCBpblxuICBsZXQgcmVjIG5leHQoKSA9ICBtYXRjaCAhc3RhdGUgd2l0aFxuICAgIHwgYFN0b3AgLT4gTm9uZVxuICAgIHwgYEF0IHggLT5cbiAgICAgICAgYmVnaW4gbWF0Y2ggZygpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gc3RhdGUgOj0gYFN0b3A7IFNvbWUgKHgsTm9uZSlcbiAgICAgICAgICB8IFNvbWUgeSBhcyByZXMgLT4gc3RhdGUgOj0gYEF0IHk7IFNvbWUgKHgsIHJlcylcbiAgICAgICAgZW5kXG4gICAgfCBgU3RhcnQgLT5cbiAgICAgICAgYmVnaW4gbWF0Y2ggZygpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gc3RhdGUgOj0gYFN0b3A7IE5vbmVcbiAgICAgICAgICB8IFNvbWUgeCAtPiBzdGF0ZSA6PSBgQXQgeDsgbmV4dCgpXG4gICAgICAgIGVuZFxuICBpblxuICBuZXh0XG5cbigqJD0gJiB+cHJpbnRlcjpRLlByaW50LihsaXN0IChwYWlyIGludCAob3B0aW9uIGludCkpKVxuICBbXSAocGVlayAob2ZfbGlzdCBbXSkgfD4gdG9fbGlzdClcbiAgWzEsIFNvbWUgMjsgMiwgU29tZSAzOyAzLCBTb21lIDQ7IDQsIE5vbmVdIChwZWVrICgxIC0tIDQpIHw+IHRvX2xpc3QpXG4qKVxuXG4oKiRRXG4gIFEuKGxpc3QgaW50KSAoZnVuIGwgLT4gXFxcbiAgICBsID0gW10gfHwgKG9mX2xpc3QgbCB8PiBwZWVrIHw+IGZpbHRlcl9tYXAgc25kIHw+IHRvX2xpc3QgPSBMaXN0LnRsIGwpKVxuICAqKVxuXG5sZXQgcXVldWVfdG9fYXJyYXlfIHEgPVxuICBpZiBRdWV1ZS5pc19lbXB0eSBxIHRoZW4gW3x8XVxuICBlbHNlIChcbiAgICBsZXQgeCA9IFF1ZXVlLnBlZWsgcSBpblxuICAgIGxldCBhID0gQXJyYXkubWFrZSAoUXVldWUubGVuZ3RoIHEpIHggaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgUXVldWUuaXRlciAoZnVuIHggLT4gYS4oIWkpIDwtIHg7IGluY3IgaSkgcTtcbiAgICBhXG4gIClcblxubGV0IHBlZWtfbiBuIGcgPVxuICBpZiBuPDEgdGhlbiBpbnZhbGlkX2FyZyBcInBlZWtfblwiO1xuICBsZXQgc3RhdGUgPSByZWYgYFN0YXJ0IGluXG4gIGxldCBxID0gUXVldWUuY3JlYXRlKCkgaW5cbiAgbGV0IHJlYyBuZXh0ICgpID0gbWF0Y2ggIXN0YXRlIHdpdGhcbiAgICB8IGBTdGFydCAtPlxuICAgICAgICBmaWxsIG47XG4gICAgICAgIHN0YXRlIDo9IGlmIFF1ZXVlLmlzX2VtcHR5IHEgdGhlbiBgU3RvcCBlbHNlIGBDb250aW51ZTtcbiAgICAgICAgbmV4dCAoKVxuICAgIHwgYENvbnRpbnVlIC0+XG4gICAgICAgIGFzc2VydCAobm90IChRdWV1ZS5pc19lbXB0eSBxKSk7XG4gICAgICAgIGxldCB4ID0gUXVldWUucG9wIHEgaW5cbiAgICAgICAgZmlsbCAxO1xuICAgICAgICBzdGF0ZSA6PSBpZiBRdWV1ZS5pc19lbXB0eSBxIHRoZW4gYFN0b3AgZWxzZSBgQ29udGludWU7XG4gICAgICAgIFNvbWUgKHgsIHF1ZXVlX3RvX2FycmF5XyBxKVxuICAgIHwgYFN0b3AgLT4gTm9uZVxuICAoKiBhZGQgW25dIGVsZW1lbnRzIHRvIFtmXSBpZiBwb3NzaWJsZSAqKVxuICBhbmQgZmlsbCBpID1cbiAgICBhc3NlcnQgKGkgKyBRdWV1ZS5sZW5ndGggcSA8PSBuKTtcbiAgICBpZiBpPjAgdGhlbiBtYXRjaCBnKCkgd2l0aFxuICAgICAgfCBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgeCAtPlxuICAgICAgICAgIFF1ZXVlLnB1c2ggeCBxO1xuICAgICAgICAgIGZpbGwgKGktMSlcbiAgaW5cbiAgbmV4dFxuXG4oKiQ9ICYgfnByaW50ZXI6US5QcmludC4obGlzdCAocGFpciBpbnQgKGFycmF5IGludCkpKVxuICBbXSAocGVla19uIDEgKG9mX2xpc3QgW10pIHw+IHRvX2xpc3QpXG4gIFsxLCBbfDI7M3xdOyAyLCBbfDM7NHxdOyAzLCBbfDR8XTsgNCwgW3x8XV0gKHBlZWtfbiAyICgxIC0tIDQpIHw+IHRvX2xpc3QpXG4gIFsxLCBbfDI7Mzs0fF07IDIsIFt8Mzs0OzV8XTsgMywgW3w0OzV8XTsgNCwgW3w1fF07IDUsW3x8XV0gXFxcbiAgICAocGVla19uIDMgKDEgLS0gNSkgfD4gdG9fbGlzdClcbiopXG5cbigqJFFSXG4gIFEuKGxpc3Qgc21hbGxfaW50KVxuICAgIChmdW4gbCAtPlxuICAgICAgbGV0IGwnID1cbiAgICAgICAgb2ZfbGlzdCBsXG4gICAgICAgIHw+IHBlZWtfbiAxMFxuICAgICAgICB8PiBmaWx0ZXJfbWFwIChmdW4gKF8sYSkgLT4gaWYgYT1bfHxdIHRoZW4gTm9uZSBlbHNlIFNvbWUgYS4oMCkpXG4gICAgICAgIHw+IHRvX2xpc3RcbiAgICAgIGluXG4gICAgICBsID0gW10gfHwgbCcgPSBMaXN0LnRsIGwpXG4qKVxuXG4oKiogezIgQmFzaWMgSU99ICopXG5cbm1vZHVsZSBJTyA9IHN0cnVjdFxuICBsZXQgd2l0aF9maWxlX2luID8obW9kZT0wbzY0NCkgPyhmbGFncz1bXSkgZmlsZW5hbWUgZiA9XG4gICAgbGV0IGljID0gb3Blbl9pbl9nZW4gZmxhZ3MgbW9kZSBmaWxlbmFtZSBpblxuICAgIHRyeVxuICAgICAgbGV0IHggPSBmIGljIGluXG4gICAgICBjbG9zZV9pbl9ub2VyciBpYztcbiAgICAgIHhcbiAgICB3aXRoIGUgLT5cbiAgICAgIGNsb3NlX2luX25vZXJyIGljO1xuICAgICAgcmFpc2UgZVxuXG4gIGxldCB3aXRoX2luID9tb2RlID9mbGFncyBmaWxlbmFtZSBmID1cbiAgICB3aXRoX2ZpbGVfaW4gP21vZGUgP2ZsYWdzIGZpbGVuYW1lXG4gICAgICAoZnVuIGljIC0+XG4gICAgICAgICBsZXQgbmV4dCgpID1cbiAgICAgICAgICAgdHJ5IFNvbWUgKGlucHV0X2NoYXIgaWMpXG4gICAgICAgICAgIHdpdGggRW5kX29mX2ZpbGUgLT4gTm9uZVxuICAgICAgICAgaW5cbiAgICAgICAgIGYgbmV4dFxuICAgICAgKVxuXG4gIGxldCB3aXRoX2xpbmVzID9tb2RlID9mbGFncyBmaWxlbmFtZSBmID1cbiAgICB3aXRoX2ZpbGVfaW4gP21vZGUgP2ZsYWdzIGZpbGVuYW1lXG4gICAgICAoZnVuIGljIC0+XG4gICAgICAgICBsZXQgbmV4dCgpID1cbiAgICAgICAgICAgdHJ5IFNvbWUgKGlucHV0X2xpbmUgaWMpXG4gICAgICAgICAgIHdpdGggRW5kX29mX2ZpbGUgLT4gTm9uZVxuICAgICAgICAgaW5cbiAgICAgICAgIGYgbmV4dFxuICAgICAgKVxuXG4gIGxldCB3aXRoX2ZpbGVfb3V0ID8obW9kZT0wbzY0NCkgPyhmbGFncz1bT3Blbl9jcmVhdDtPcGVuX3dyb25seV0pIGZpbGVuYW1lIGYgPVxuICAgIGxldCBvYyA9IG9wZW5fb3V0X2dlbiBmbGFncyBtb2RlIGZpbGVuYW1lIGluXG4gICAgdHJ5XG4gICAgICBsZXQgeCA9IGYgb2MgaW5cbiAgICAgIGNsb3NlX291dCBvYztcbiAgICAgIHhcbiAgICB3aXRoIGUgLT5cbiAgICAgIGNsb3NlX291dF9ub2VyciBvYztcbiAgICAgIHJhaXNlIGVcblxuICBsZXQgd3JpdGVfc3RyID9tb2RlID9mbGFncyA/KHNlcD1cIlwiKSBmaWxlbmFtZSBnID1cbiAgICB3aXRoX2ZpbGVfb3V0ID9tb2RlID9mbGFncyBmaWxlbmFtZVxuICAgICAgKGZ1biBvYyAtPlxuICAgICAgICAgaXRlcmlcbiAgICAgICAgICAgKGZ1biBpIHMgLT5cbiAgICAgICAgICAgICAgaWYgaT4wIHRoZW4gb3V0cHV0X3N0cmluZyBvYyBzZXA7XG4gICAgICAgICAgICAgIG91dHB1dF9zdHJpbmcgb2Mgc1xuICAgICAgICAgICApIGdcbiAgICAgIClcblxuICBsZXQgd3JpdGUgP21vZGUgP2ZsYWdzIGZpbGVuYW1lIGcgPVxuICAgIHdpdGhfZmlsZV9vdXQgP21vZGUgP2ZsYWdzIGZpbGVuYW1lXG4gICAgICAoZnVuIG9jIC0+XG4gICAgICAgICBpdGVyIChmdW4gYyAtPiBvdXRwdXRfY2hhciBvYyBjKSBnXG4gICAgICApXG5cbiAgbGV0IHdyaXRlX2xpbmVzID9tb2RlID9mbGFncyBmaWxlbmFtZSBnID1cbiAgICB3aXRoX2ZpbGVfb3V0ID9tb2RlID9mbGFncyBmaWxlbmFtZVxuICAgICAgKGZ1biBvYyAtPlxuICAgICAgICAgaXRlciAoZnVuIHMgLT4gb3V0cHV0X3N0cmluZyBvYyBzOyBvdXRwdXRfY2hhciBvYyAnXFxuJykgZ1xuICAgICAgKVxuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9zcmNfZ2VuX21sIiwiY2FtbF9hcnJheV9tYWtlIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfY29tcGFyZSIsImNhbWxfZXF1YWwiLCJjYW1sX2xlc3N0aGFuIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfZ2V0IiwiY2FtbF90cmFtcG9saW5lIiwiY2FtbF90cmFtcG9saW5lX3JldHVybiIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiY2FtbF9jYWxsMyIsImEyIiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsInN0ZXAiLCJTdGRsaWIiLCJTdGRsaWJfUXVldWUiLCJBc3NlcnRfZmFpbHVyZSIsIkdlbk1MaXN0IiwiU3RkbGliX0xpc3QiLCJTdGRsaWJfRm9ybWF0IiwiU3RkbGliX0J1ZmZlciIsIlN0ZGxpYl9SYW5kb20iLCJTdGRsaWJfQXJyYXkiLCJjc3RfR2VuX2dldF9leG4iLCJjc3RfcmVkdWNlIiwiY3N0X21pbiIsImNzdF9tYXgiLCJjc3RfR2VuX2ludF9yYW5nZSIsImVtcHR5IiwicGFyYW0iLCJzaW5nbGV0b24iLCJ4IiwiZmlyc3QiLCJyZXBlYXQiLCJyZXBlYXRlZGx5IiwiaXRlcmF0ZSIsImN1ciIsIm5leHQiLCJnZW4iLCJnZXQiLCJnZXRfZXhuIiwibWF0Y2giLCJqdW5rIiwiZm9sZCIsImFjYyIsInJlZHVjZSIsImciLCJ1bmZvbGQiLCJpbml0Iiwib3B0IiwibGltaXQiLCJyIiwiaXRlciIsIml0ZXJpIiwiaSIsImlzX2VtcHR5IiwibGVuZ3RoIiwic2NhbiIsInN0YXRlIiwidW5mb2xkX3NjYW4iLCJ5IiwibWFwIiwic3RvcCIsIm1hcGkiLCJjbnQiLCJjbnRfbWFwIiwiZm9sZF9tYXAiLCJzIiwiYXBwZW5kIiwiZ2VuMSIsImdlbjIiLCJmbGF0dGVuIiwibmV4dF9nZW4iLCJjb3VudGVyIiwiZ2V0X25leHRfZ2VuIiwiZmxhdF9tYXAiLCJuZXh0X2VsZW0iLCJ2YWwiLCJlIiwibWVtIiwiZXEiLCJ0YWtlIiwibiIsImNvdW50IiwiZHJvcCIsImRyb3BwZWQiLCJudGgiLCJ0YWtlX250aCIsInJlcyIsImZpbHRlciIsInAiLCJ0YWtlX3doaWxlIiwiZm9sZF93aGlsZSIsImNvbnQiLCJkcm9wX3doaWxlIiwiZmlsdGVyX21hcCIsInppcF9pbmRleCIsInVuemlwIiwicTEiLCJxMiIsIm5leHRfbGVmdCIsIm5leHRfcmlnaHQiLCJwYXJ0aXRpb24iLCJxdHJ1ZSIsInFmYWxzZSIsIm5leHR0cnVlIiwibmV4dGZhbHNlIiwiZm9yX2FsbCIsImV4aXN0cyIsIm1pbiIsImx0IiwibWF4IiwieDIiLCJ4MSIsImxleGljbyIsImNtcCIsImMiLCJjb21wYXJlIiwiZmluZCIsInN1bSIsIm1hcDIiLCJlMSIsImUyIiwiaXRlcjIiLCJmb2xkMiIsImZvcl9hbGwyIiwiZXhpc3RzMiIsInppcF93aXRoIiwiYSIsImIiLCJ4YiIsInhhIiwiemlwIiwibWVyZ2UiLCJpbnRlcnNlY3Rpb24iLCJ5MiIsInkxIiwic29ydGVkX21lcmdlIiwiaCIsInVuaW9uIiwidDEiLCJ0MiIsInIyIiwibDIiLCJyMSIsImwxIiwiaW5zZXJ0IiwicG9wIiwibCIsInNvcnRlZF9tZXJnZV9uIiwidjIiLCJ2MSIsImhlYXAiLCJyb3VuZF9yb2JpbiIsInFzIiwicSIsImoiLCJ0ZWUiLCJmaW5pc2hlZCIsImludGVybGVhdmUiLCJnZW5fYSIsImdlbl9iIiwiZzIiLCJnMSIsImludGVyc3BlcnNlIiwicHJvZHVjdCIsImdlbmEiLCJnZW5iIiwiYWxsX2EiLCJhbGxfYiIsInZhcmlhbnQiLCJncm91cCIsIm5leHRfeCIsInVuaXEiLCJzb3J0Iiwic29ydF91bmlxIiwiY2h1bmtzIiwicGVybXV0YXRpb25zIiwibWFrZV9tYWNoaW5lIiwidGFpbCIsInN1YiIsInN0IiwibSIsImxlbiIsInBlcm11dGF0aW9uc19oZWFwIiwiaXMiLCJ0bXAiLCJjb21iaW5hdGlvbnMiLCJtYWtlX3N0YXRlIiwibTEiLCJtMiIsInBvd2VyX3NldCIsIm9mX2xpc3QiLCJ0b19yZXZfbGlzdCIsInRvX2xpc3QiLCJ0b19hcnJheSIsIm9mX2FycmF5Iiwic3RhcnQiLCJvZl9zdHJpbmciLCJ0b19idWZmZXIiLCJidWYiLCJ0b19zdHJpbmciLCJvZl9zZXEiLCJzZXEiLCJ0bCIsInJhbmRfaW50IiwiaW50X3JhbmdlIiwic3ltYm9sIiwibGluZXMiLCJ1bmxpbmVzIiwicHAiLCJwcF9lbGVtIiwiZm9ybWF0dGVyIiwic2VwIiwiaG9yaXpvbnRhbCIsImlzX2ZpcnN0Iiwic3ltYm9sX2JpbmQiLCJzeW1ib2xfbWFwIiwiSW5maXgiLCJsaWZ0IiwibGlmdDIiLCJjeWNsZSIsImVudW0kIiwidG9faXRlciIsInlpZWxkJCIsImNzdF9wZWVrX24iLCJmbXQiLCJvZl9nZW4iLCJjYWNoaW5nIiwibWF4X2NodW5rX3NpemUiLCJjYWNoZWQiLCJtbGlzdCIsInBlcnNpc3RlbnQiLCJwZXJzaXN0ZW50X3RvX3NlcSIsInBlcnNpc3RlbnRfbGF6eSIsInBlcnNpc3RlbnRfbGF6eV90b19zZXEiLCJwZWVrIiwicXVldWVfdG9fYXJyYXkiLCJwZWVrX24iLCJmaWxsIiwid2l0aF9maWxlX2luIiwiZmlsZW5hbWUiLCJtb2RlIiwiZmxhZ3MiLCJpYyIsIndpdGhfaW4iLCJleG4iLCJ3aXRoX2xpbmVzIiwid2l0aF9maWxlX291dCIsIm9jIiwid3JpdGVfc3RyIiwid3JpdGUiLCJ3cml0ZV9saW5lcyIsIkdlbiJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJ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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUR2MkRoQyIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0MDAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsImdsb2JhbF9kYXRhIiwiR2VuIiwiZ2V0IiwibmV4dCIsImdldF9leG4iLCJqdW5rIiwicmVwZWF0ZWRseSIsImVtcHR5Iiwic2luZ2xldG9uIiwicmV0dXJuJCIsInJlcGVhdCIsIml0ZXJhdGUiLCJ1bmZvbGQiLCJpbml0IiwiaXNfZW1wdHkiLCJmb2xkIiwicmVkdWNlIiwic2NhbiIsInVuZm9sZF9zY2FuIiwiaXRlciIsIml0ZXJpIiwibGVuZ3RoIiwibWFwIiwibWFwaSIsImZvbGRfbWFwIiwiYXBwZW5kIiwiZmxhdHRlbiIsImZsYXRfbWFwIiwibWVtIiwidGFrZSIsImRyb3AiLCJudGgiLCJ0YWtlX250aCIsImZpbHRlciIsInRha2Vfd2hpbGUiLCJmb2xkX3doaWxlIiwiZHJvcF93aGlsZSIsImZpbHRlcl9tYXAiLCJ6aXBfaW5kZXgiLCJ1bnppcCIsInBhcnRpdGlvbiIsImZvcl9hbGwiLCJleGlzdHMiLCJtaW4iLCJtYXgiLCJlcSIsImxleGljbyIsImNvbXBhcmUiLCJmaW5kIiwic3VtIiwibWFwMiIsIml0ZXIyIiwiZm9sZDIiLCJmb3JfYWxsMiIsImV4aXN0czIiLCJ6aXBfd2l0aCIsInppcCIsIm1lcmdlIiwiaW50ZXJzZWN0aW9uIiwic29ydGVkX21lcmdlIiwic29ydGVkX21lcmdlX24iLCJ0ZWUiLCJyb3VuZF9yb2JpbiIsImludGVybGVhdmUiLCJpbnRlcnNwZXJzZSIsInByb2R1Y3QiLCJncm91cCIsInVuaXEiLCJzb3J0Iiwic29ydF91bmlxIiwiY2h1bmtzIiwicGVybXV0YXRpb25zIiwicGVybXV0YXRpb25zX2hlYXAiLCJjb21iaW5hdGlvbnMiLCJwb3dlcl9zZXQiLCJvZl9saXN0IiwidG9fbGlzdCIsInRvX3Jldl9saXN0IiwidG9fYXJyYXkiLCJvZl9hcnJheSIsIm9mX3N0cmluZyIsInRvX3N0cmluZyIsInRvX2J1ZmZlciIsInJhbmRfaW50IiwiaW50X3JhbmdlIiwibGluZXMiLCJ1bmxpbmVzIiwiSW5maXgiLCJzeW1ib2wiLCJzeW1ib2xfYmluZCIsInN5bWJvbF9tYXAiLCJwcCIsIm9mX3NlcSIsInRvX2l0ZXIiLCJSZXN0YXJ0IiwicGVyc2lzdGVudCIsInBlcnNpc3RlbnRfbGF6eSIsInBlZWsiLCJwZWVrX24iLCJzdGFydCIsIklPIiwiR2VuTGFiZWxzIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxPQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLEtBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsTUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxhQUFBO0FBQUEsSUFBQUMsY0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLE9BQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxXQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFGLFdBQUE7QUFBQSxJQUFBRyxLQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFVBQUE7QUFBQSxJQUFBQyxVQUFBO0FBQUEsSUFBQUMsYUFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsT0FBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsS0FBQTtBQUFBLElBQUFDO0FBQUFBLE1BQUEiLCJpZ25vcmVMaXN0IjpbMF19fSx7Im9mZnNldCI6eyJsaW5lIjoyNzA4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6Imdlbi5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2ZhYmlhbi8ub3BhbS9kZWZhdWx0L2xpYi9nZW4vZ2VuQ2xvbmUubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJcbigqIFRoaXMgZmlsZSBpcyBmcmVlIHNvZnR3YXJlLCBwYXJ0IG9mIGdlbi4gU2VlIGZpbGUgXCJsaWNlbnNlXCIgZm9yIG1vcmUgZGV0YWlscy4gKilcblxuKCoqIHsxIENsb25hYmxlIEdlbmVyYXRvcnN9ICopXG5cbnR5cGUgJ2EgZ2VuID0gdW5pdCAtPiAnYSBvcHRpb25cblxuY2xhc3MgdmlydHVhbCBbJ2FdIHQgPSBvYmplY3RcbiAgbWV0aG9kIHZpcnR1YWwgZ2VuIDogJ2EgZ2VuICAoKiogR2VuZXJhdG9yIG9mIHZhbHVlcyB0aWVkIHRvIHRoaXMgY29weSAqKVxuXG4gIG1ldGhvZCB2aXJ0dWFsIGNsb25lIDogJ2EgdCAgKCoqIENsb25lIHRoZSBpbnRlcm5hbCBzdGF0ZSAqKVxuZW5kXG4oKiogQSBnZW5lcmF0b3IgdGhhdCBjYW4gYmUgY2xvbmVkIGFzIG1hbnkgdGltZXMgYXMgcmVxdWlyZWQuICopXG5cbnR5cGUgJ2EgY2xvbmFibGUgPSAnYSB0XG4oKiogQWxpYXMgdG8geyEnYSB0fSAqKVxuXG4oKiogezIgUHJlcGVuZCBtZXRob2R9ICopXG5cbnR5cGUgJ2EgcHJlcGVuZGFibGUgPSA8XG4gIGdlbiA6ICdhIGdlbjtcbiAgY2xvbmUgOiAnYSBwcmVwZW5kYWJsZTtcbiAgcHJlcGVuZCA6ICdhIC0+IHVuaXQgKCoqIEFkZCB2YWx1ZSBhdCBmcm9udCBwb3NpdGlvbiAqKVxuPlxuXG4oKiBoZWxwZXIgZnVuY3Rpb24gZm9yIHshdG9fcHJlcGVuZGFibGV9ICopXG5sZXQgcmVjIHRvX3ByZXBlbmRhYmxlIGMgPVxuICBsZXQgZyA9IGMjZ2VuIGluXG4gIGxldCBzdCA9IHJlZiBgRndkIGluICAoKiBzdGF0ZTogZm9yd2FyZCAqKVxuICBsZXQgbmV4dCAoKSA9IG1hdGNoICFzdCB3aXRoXG4gICAgfCBgRndkIC0+IGcoKVxuICAgIHwgYFlpZWxkIFtdIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgYFlpZWxkIFt4XSAtPiBzdCA6PSBgRndkOyBTb21lIHhcbiAgICB8IGBZaWVsZCAoeDo6bCkgLT4gc3QgOj0gYFlpZWxkIGw7IFNvbWUgeFxuICBpblxuICBvYmplY3RcbiAgICBtZXRob2QgZ2VuID0gbmV4dFxuICAgIG1ldGhvZCBjbG9uZSA9IHRvX3ByZXBlbmRhYmxlIChjI2Nsb25lKVxuICAgIG1ldGhvZCBwcmVwZW5kIHggPVxuICAgICAgc3QgOj0gbWF0Y2ggIXN0IHdpdGhcbiAgICAgICAgfCBgRndkIC0+IGBZaWVsZCBbeF1cbiAgICAgICAgfCBgWWllbGQgbCAtPiBgWWllbGQgKHg6OmwpXG4gIGVuZFxuXG4oKiogezIgTWlzY30gKilcblxubGV0IHJlYyBtYXAgZiBjID1cbiAgbGV0IGcgPSBjI2dlbiBpblxuICBsZXQgbmV4dCAoKSA9IG1hdGNoIGcoKSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgeCAtPiBTb21lIChmIHgpXG4gIGluXG4gIG9iamVjdFxuICAgIG1ldGhvZCBnZW4gPSBuZXh0XG4gICAgbWV0aG9kIGNsb25lID0gbWFwIGYgYyNjbG9uZVxuICBlbmRcblxuKCoqIHsyIEJhc2ljIElPfSAqKVxuXG5tb2R1bGUgSU8gPSBzdHJ1Y3RcbiAgbGV0IHdpdGhfaW4gPyhtb2RlPTBvNjQ0KSA/KGZsYWdzPVtdKSBmaWxlbmFtZSBmID1cbiAgICBsZXQgaWMgPSBvcGVuX2luX2dlbiBmbGFncyBtb2RlIGZpbGVuYW1lIGluXG4gICAgbGV0IHRpbWVzdGFtcCA9IHJlZiAwIGluXG4gICAgKCogbWFrZSBhIGdlbmVyYXRvciBhdCBvZmZzZXQgW2ldICopXG4gICAgbGV0IHJlYyBtYWtlIGkgOiBfIGNsb25hYmxlID1cbiAgICAgIGxldCBzdGF0ZSA9IHJlZiBgTm90X3N0YXJ0ZWQgaW5cbiAgICAgIGxldCByZWMgbmV4dCgpID1cbiAgICAgICAgbWF0Y2ggIXN0YXRlIHdpdGhcbiAgICAgICAgfCBgTm90X3N0YXJ0ZWQgLT5cbiAgICAgICAgICAgICgqIGluaXRpYWxpemUgYnkgcmVzdG9yaW5nIHN0YXRlICopXG4gICAgICAgICAgICBzZWVrX2luIGljIGk7XG4gICAgICAgICAgICBpbmNyIHRpbWVzdGFtcDtcbiAgICAgICAgICAgIHN0YXRlIDo9IGBTdGFydGVkICF0aW1lc3RhbXA7XG4gICAgICAgICAgICBuZXh0KClcbiAgICAgICAgfCBgU3RhcnRlZCB0IC0+XG4gICAgICAgICAgICAoKiBjaGVjayB3aGV0aGVyIGFub3RoZXIgaXRlcmF0b3Igd2FzIHVzZWQgbW9yZSByZWNlbnRseSAqKVxuICAgICAgICAgICAgaWYgdCA8ICF0aW1lc3RhbXAgdGhlbiBmYWlsd2l0aCBcImludmFsaWRhdGVkIGl0ZXJhdG9yXCI7XG4gICAgICAgICAgICB0cnkgU29tZSAoaW5wdXRfY2hhciBpYylcbiAgICAgICAgICAgIHdpdGggRW5kX29mX2ZpbGUgLT4gTm9uZVxuICAgICAgaW5cbiAgICAgIG9iamVjdFxuICAgICAgICBtZXRob2QgY2xvbmUgPVxuICAgICAgICAgIGxldCBpID0gcG9zX2luIGljIGluXG4gICAgICAgICAgbWFrZSBpXG4gICAgICAgIG1ldGhvZCBnZW4gPSBuZXh0XG4gICAgICBlbmRcbiAgICBpblxuICAgIHRyeVxuICAgICAgbGV0IHggPSBmIChtYWtlIDApIGluXG4gICAgICBjbG9zZV9pbl9ub2VyciBpYztcbiAgICAgIHhcbiAgICB3aXRoIGUgLT5cbiAgICAgIGNsb3NlX2luX25vZXJyIGljO1xuICAgICAgcmFpc2UgZVxuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9jbG9uZSIsImNzdF9nZW4iLCJjc3RfcHJlcGVuZCIsImNhbWxfZ2V0X2NhY2hlZF9tZXRob2QiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX29vX2NhY2hlX2lkIiwiY2FtbF91cGRhdGVfZHVtbXkiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImdsb2JhbF9kYXRhIiwic2hhcmVkIiwiQ2FtbGludGVybmFsT08iLCJBc3NlcnRfZmFpbHVyZSIsIlN0ZGxpYiIsImNhY2hlX2lkIiwidG9fcHJlcGVuZGFibGUiLCJjIiwiZyIsInN0IiwibmV4dCIsInBhcmFtIiwibWF0Y2giLCJ4IiwibCIsInNlbGZfMiIsImVudiIsImxldHJlY19mdW5jdGlvbl9jb250ZXh0IiwibWFwIiwic2VsZl8zIiwiY3N0X2ludmFsaWRhdGVkX2l0ZXJhdG9yIiwid2l0aF9pbiIsIm9wdCIsImZpbGVuYW1lIiwibW9kZSIsImZsYWdzIiwiaWMiLCJ0aW1lc3RhbXAiLCJtYWtlIiwiaSIsInN0YXRlIiwidCIsImV4biIsInNlbGZfNCIsImUiLCJJTyIsIkdlbkNsb25lIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFFBQUE7QUFBQSxJQUFBQyxZQUFBO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQWhCLE1BQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBO0FBQUEsSUFBQWlCLFNBQUE7QUFBQSxJQUFBQyxpQkFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsU0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQSxhQUFBO0FBQUEsSUFBQUEsYUFBQTtBQUFBLElBQUFBLGFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFB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
