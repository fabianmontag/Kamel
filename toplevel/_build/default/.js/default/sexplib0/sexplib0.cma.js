// Generated by js_of_ocaml
//# buildInfo:effects=disabled, kind=cma, use-js-string=true, version=6.2.0

//# unitInfo: Provides: Sexplib0__
//# shape: Sexplib0__:[[]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Sexplib0 = [0],
    Sexplib0$0 = [0, Sexplib0];
   runtime.caml_register_global(0, Sexplib0$0, "Sexplib0__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp
//# unitInfo: Requires: Stdlib__Buffer, Stdlib__Bytes, Stdlib__BytesLabels, Stdlib__Char, Stdlib__Format, Stdlib__ListLabels, Stdlib__StringLabels
//# shape: Sexplib0__Sexp:[F(1)*,F(1)*,F(2),F(2),N,N,F(2),N,F(2),F(3),F(2),F(2),F(2),F(1),F(1),N,N,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$11 = "(",
    cst$12 = "()",
    cst$13 = ")",
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$2 = cst$11,
    cst$3 = cst$12,
    cst$4 = cst$13,
    cst$5 = " ",
    cst$6 = cst$11,
    cst$7 = cst$12,
    cst$8 = cst$13,
    cst$10 = cst$12,
    cst$9 = cst$12,
    cst = "\\",
    cst$0 = ' "',
    cst$1 = '"',
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes;
   function sexp_of_t(t){return t;}
   function t_of_sexp(t){return t;}
   function compare(a$0, b$0){
    if(a$0 === b$0) return 0;
    if(0 === a$0[0]){
     var a$1 = a$0[1];
     if(0 !== b$0[0]) return -1;
     var b$1 = b$0[1];
     return caml_call2(Stdlib_StringLabels[10], a$1, b$1);
    }
    var a$2 = a$0[1];
    if(0 === b$0[0]) return 1;
    var b$2 = b$0[1], a = a$2, b = b$2;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var ys = b[2], y = b[1], xs = a[2], x = a[1], res = compare(x, y);
     if(0 !== res) return res;
     a = xs;
     b = ys;
    }
   }
   function equal(a, b){
    var c = a === b ? 1 : 0;
    if(c)
     var d = c;
    else{
     if(0 === a[0]){
      var a$0 = a[1];
      if(0 === b[0]){
       var b$0 = b[1];
       return caml_call2(Stdlib_StringLabels[9], a$0, b$0);
      }
     }
     else{
      var a$1 = a[1];
      if(0 !== b[0]){
       var b$1 = b[1];
       return caml_call3(Stdlib_ListLabels[16], equal, a$1, b$1);
      }
     }
     var d = 0;
    }
    return d;
   }
   var
    Not_found_s = [248, "Sexplib0__Sexp.Not_found_s", caml_fresh_oo_id(0)],
    Of_sexp_error = [248, "Sexplib0__Sexp.Of_sexp_error", caml_fresh_oo_id(0)],
    default_indent = [0, 1],
    cst_n = "\\n",
    a = [0, 0, 0],
    b = [0, [15, [17, 2, 0]], "%a@?"];
   function must_escape(str){
    var len = caml_ml_string_length(str), a = 0 === len ? 1 : 0;
    if(a) return a;
    var ix$1 = len - 1 | 0, ix = ix$1;
    for(;;){
     var match = caml_string_get(str, ix);
     a:
     {
      b:
      {
       if(92 <= match){
        var switcher = match - 93 | 0;
        if(33 < switcher >>> 0){if(0 <= switcher) break b; break a;}
        if(31 === switcher){
         var b = 0 < ix ? 1 : 0;
         if(b){
          var
           next = ix - 1 | 0,
           i = caml_string_get(str, next),
           c = caml_call2(Stdlib_Char[6], i, 35);
          if(! c){ix = next; continue;}
          var d = c;
         }
         else
          var d = b;
         return d;
        }
       }
       else
        if(42 <= match){
         if(59 === match) break a;
        }
        else{
         if(33 > match) break b;
         switch(match - 33 | 0){
           case 2:
            var f = 0 < ix ? 1 : 0;
            if(f){
             var
              next$0 = ix - 1 | 0,
              j = caml_string_get(str, next$0),
              g = caml_call2(Stdlib_Char[6], j, 124);
             if(! g){ix = next$0; continue;}
             var h = g;
            }
            else
             var h = f;
            return h;
           case 1:
           case 7:
           case 8:
            break a;
         }
        }
       var e = 0 < ix ? 1 : 0;
       if(! e) return e;
       var ix$0 = ix - 1 | 0;
       ix = ix$0;
       continue;
      }
      return 1;
     }
     return 1;
    }
   }
   function escaped(s){
    var n = [0, 0], d = caml_ml_string_length(s) - 1 | 0, f = 0;
    if(d >= 0){
     var i$0 = f;
     for(;;){
      var match = caml_string_unsafe_get(s, i$0);
      a:
      {
       b:
       {
        c:
        {
         if(32 <= match){
          var a = match - 34 | 0;
          if(58 < a >>> 0){
           if(93 <= a) break c;
          }
          else if(56 < a - 1 >>> 0) break b;
          var b = 1;
          break a;
         }
         if(11 <= match){
          if(13 === match) break b;
         }
         else if(8 <= match) break b;
        }
        var b = 4;
        break a;
       }
       var b = 2;
      }
      n[1] = n[1] + b | 0;
      var m = i$0 + 1 | 0;
      if(d === i$0) break;
      i$0 = m;
     }
    }
    if(n[1] === caml_ml_string_length(s)) return s;
    var s$0 = caml_create_bytes(n[1]);
    n[1] = 0;
    var e = caml_ml_string_length(s) - 1 | 0, g = 0;
    if(e >= 0){
     var i = g;
     for(;;){
      var c = caml_string_unsafe_get(s, i);
      a:
      {
       b:
       {
        c:
        {
         if(35 <= c){
          if(92 !== c){if(127 <= c) break b; break c;}
         }
         else{
          if(32 > c){
           if(14 <= c) break b;
           switch(c){
             case 8:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 98);
              break a;
             case 9:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 116);
              break a;
             case 10:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 110);
              break a;
             case 13:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 114);
              break a;
             default: break b;
           }
          }
          if(34 > c) break c;
         }
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], c);
         break a;
        }
        caml_bytes_unsafe_set(s$0, n[1], c);
        break a;
       }
       caml_bytes_unsafe_set(s$0, n[1], 92);
       n[1]++;
       var j = caml_call1(Stdlib_Char[1], 48 + (c / 100 | 0) | 0);
       caml_bytes_unsafe_set(s$0, n[1], j);
       n[1]++;
       var k = caml_call1(Stdlib_Char[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
       caml_bytes_unsafe_set(s$0, n[1], k);
       n[1]++;
       var l = caml_call1(Stdlib_Char[1], 48 + (c % 10 | 0) | 0);
       caml_bytes_unsafe_set(s$0, n[1], l);
      }
      n[1]++;
      var h = i + 1 | 0;
      if(e === i) break;
      i = h;
     }
    }
    return caml_call1(Stdlib_BytesLabels[44], s$0);
   }
   function esc_str(str){
    var
     estr = escaped(str),
     elen = caml_ml_string_length(estr),
     res = caml_create_bytes(elen + 2 | 0);
    caml_call5(Stdlib_Bytes[12], estr, 0, res, 1, elen);
    caml_bytes_unsafe_set(res, 0, 34);
    caml_bytes_unsafe_set(res, elen + 1 | 0, 34);
    return caml_call1(Stdlib_BytesLabels[44], res);
   }
   function index_of_newline(str, start){
    return caml_call3(Stdlib_StringLabels[33], str, start, 10);
   }
   function mach_maybe_esc_str(str){
    return must_escape(str) ? esc_str(str) : str;
   }
   function pp_hum_indent(indent, ppf, param){
    if(0 === param[0]){
     var str = param[1];
     if(! must_escape(str)) return caml_call2(Stdlib_Format[13], ppf, str);
     var match = index_of_newline(str, 0);
     if(match)
      var
       index = match[1],
       a = (index + 1 | 0) === caml_ml_string_length(str) ? 1 : 0;
     else
      var a = 1;
     if(a){
      var b = esc_str(str);
      return caml_call2(Stdlib_Format[13], ppf, b);
     }
     caml_call2(Stdlib_Format[1], ppf, 0);
     caml_call2(Stdlib_Format[13], ppf, cst$0);
     var index$0 = 0;
     for(;;){
      var next_newline = index_of_newline(str, index$0);
      if(next_newline)
       var end_pos = next_newline[1], end_pos$0 = end_pos;
      else
       var end_pos$0 = caml_ml_string_length(str);
      var
       next_line =
         caml_call3
          (Stdlib_StringLabels[16], str, index$0, end_pos$0 - index$0 | 0),
       c = escaped(next_line);
      caml_call2(Stdlib_Format[13], ppf, c);
      if(! next_newline){
       caml_call2(Stdlib_Format[13], ppf, cst$1);
       return caml_call2(Stdlib_Format[3], ppf, 0);
      }
      var newline_index = next_newline[1];
      caml_call2(Stdlib_Format[13], ppf, cst);
      caml_call2(Stdlib_Format[39], ppf, 0);
      caml_call2(Stdlib_Format[13], ppf, cst_n);
      var index$1 = newline_index + 1 | 0;
      index$0 = index$1;
     }
    }
    else{
     var match$0 = param[1];
     if(! match$0) return caml_call2(Stdlib_Format[13], ppf, cst$3);
     var t = match$0[2], h = match$0[1];
     caml_call2(Stdlib_Format[1], ppf, indent);
     caml_call2(Stdlib_Format[13], ppf, cst$2);
     pp_hum_indent(indent, ppf, h);
     var param$0 = t;
     for(;;){
      if(! param$0){
       caml_call2(Stdlib_Format[13], ppf, cst$4);
       return caml_call2(Stdlib_Format[3], ppf, 0);
      }
      var t$0 = param$0[2], h$0 = param$0[1];
      caml_call2(Stdlib_Format[32], ppf, 0);
      pp_hum_indent(indent, ppf, h$0);
      param$0 = t$0;
     }
    }
   }
   function pp_mach_internal(may_need_space, ppf, param){
    if(0 === param[0]){
     var
      str = param[1],
      str$0 = mach_maybe_esc_str(str),
      new_may_need_space = str$0 === str ? 1 : 0,
      new_may_need_space$0 =
        may_need_space ? new_may_need_space : may_need_space;
     if(new_may_need_space$0) caml_call2(Stdlib_Format[13], ppf, cst$5);
     caml_call2(Stdlib_Format[13], ppf, str$0);
     return new_may_need_space;
    }
    var match = param[1];
    if(! match){caml_call2(Stdlib_Format[13], ppf, cst$7); return 0;}
    var t = match[2], h = match[1];
    caml_call2(Stdlib_Format[13], ppf, cst$6);
    var
     may_need_space$0 = pp_mach_internal(0, ppf, h),
     may_need_space$1 = may_need_space$0,
     param$0 = t;
    for(;;){
     if(! param$0){caml_call2(Stdlib_Format[13], ppf, cst$8); return 0;}
     var
      t$0 = param$0[2],
      h$0 = param$0[1],
      may_need_space$2 = pp_mach_internal(may_need_space$1, ppf, h$0);
     may_need_space$1 = may_need_space$2;
     param$0 = t$0;
    }
   }
   function pp_hum(ppf, sexp){
    return pp_hum_indent(default_indent[1], ppf, sexp);
   }
   function pp_mach(ppf, sexp){pp_mach_internal(0, ppf, sexp); return 0;}
   function size_loop(acc, param){
    var c = acc[2], v = acc[1];
    if(0 === param[0]){
     var str = param[1];
     return [0, v + 1 | 0, c + caml_ml_string_length(str) | 0];
    }
    var lst = param[1];
    return caml_call3(Stdlib_ListLabels[26], size_loop, acc, lst);
   }
   function size(sexp){return size_loop(a, sexp);}
   function to_buffer_hum(buf, opt, sexp){
    var
     indent = opt ? opt[1] : default_indent[1],
     ppf = caml_call1(Stdlib_Format[120], buf);
    return caml_call4
            (Stdlib_Format[143],
             ppf,
             b,
             function(a, b){return pp_hum_indent(indent, a, b);},
             sexp);
   }
   function to_buffer_mach(buf, sexp){
    function loop(may_need_space, param){
     if(0 === param[0]){
      var
       str = param[1],
       str$0 = mach_maybe_esc_str(str),
       new_may_need_space = str$0 === str ? 1 : 0,
       new_may_need_space$0 =
         may_need_space ? new_may_need_space : may_need_space;
      if(new_may_need_space$0) caml_call2(Stdlib_Buffer[12], buf, 32);
      caml_call2(Stdlib_Buffer[16], buf, str$0);
      return new_may_need_space;
     }
     var match = param[1];
     if(! match){caml_call2(Stdlib_Buffer[16], buf, cst$9); return 0;}
     var t = match[2], h = match[1];
     caml_call2(Stdlib_Buffer[12], buf, 40);
     var
      may_need_space$0 = loop(0, h),
      may_need_space$1 = may_need_space$0,
      param$0 = t;
     for(;;){
      if(! param$0){caml_call2(Stdlib_Buffer[12], buf, 41); return 0;}
      var
       t$0 = param$0[2],
       h$0 = param$0[1],
       may_need_space$2 = loop(may_need_space$1, h$0);
      may_need_space$1 = may_need_space$2;
      param$0 = t$0;
     }
    }
    loop(0, sexp);
    return 0;
   }
   function to_buffer_gen(buf, add_char, add_string, sexp){
    function loop(may_need_space, param){
     if(0 === param[0]){
      var
       str = param[1],
       str$0 = mach_maybe_esc_str(str),
       new_may_need_space = str$0 === str ? 1 : 0,
       new_may_need_space$0 =
         may_need_space ? new_may_need_space : may_need_space;
      if(new_may_need_space$0) caml_call2(add_char, buf, 32);
      caml_call2(add_string, buf, str$0);
      return new_may_need_space;
     }
     var match = param[1];
     if(! match){caml_call2(add_string, buf, cst$10); return 0;}
     var t = match[2], h = match[1];
     caml_call2(add_char, buf, 40);
     var
      may_need_space$0 = loop(0, h),
      may_need_space$1 = may_need_space$0,
      param$0 = t;
     for(;;){
      if(! param$0){caml_call2(add_char, buf, 41); return 0;}
      var
       t$0 = param$0[2],
       h$0 = param$0[1],
       may_need_space$2 = loop(may_need_space$1, h$0);
      may_need_space$1 = may_need_space$2;
      param$0 = t$0;
     }
    }
    loop(0, sexp);
    return 0;
   }
   function buffer(param){return caml_call1(Stdlib_Buffer[1], 1024);}
   function to_string_hum(indent, sexp){
    if(0 === sexp[0]){
     var str = sexp[1], a = index_of_newline(str, 0) ? 0 : 1;
     if(a) return mach_maybe_esc_str(str);
    }
    var buf = buffer(0);
    to_buffer_hum(buf, indent, sexp);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function to_string_mach(sexp){
    if(0 === sexp[0]){var str = sexp[1]; return mach_maybe_esc_str(str);}
    var buf = buffer(0);
    to_buffer_mach(buf, sexp);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   var of_float_style = [0, 1009018843], of_int_style = [0, 1009018843];
   function message(name, fields){
    function conv_fields(param){
     if(! param) return 0;
     var
      rest = param[2],
      match = param[1],
      fsexp = match[2],
      fname = match[1];
     return fname !== ""
             ? [0, [1, [0, [0, fname], [0, fsexp, 0]]], conv_fields(rest)]
             : [0, fsexp, conv_fields(rest)];
    }
    return [1, [0, [0, name], conv_fields(fields)]];
   }
   var
    Sexplib0_Sexp =
      [0,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp_mach,
       to_string_hum,
       to_string_mach,
       to_string_mach,
       of_float_style,
       of_int_style,
       [0,
        size,
        buffer,
        to_buffer_mach,
        to_buffer_hum,
        to_buffer_mach,
        to_buffer_gen,
        mach_maybe_esc_str,
        must_escape,
        esc_str]];
   runtime.caml_register_global(25, Sexplib0_Sexp, "Sexplib0__Sexp");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_grammar
//# shape: Sexplib0__Sexp_grammar:[F(1)*,F(3)*,N,N,N,N,N,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    doc_comment_tag = "sexp_grammar.doc_comment",
    type_name_tag = "sexp_grammar.type_name",
    assoc_tag = "sexp_grammar.assoc",
    assoc_key_tag = "sexp_grammar.assoc.key",
    assoc_value_tag = "sexp_grammar.assoc.value",
    completion_suggested = "sexp_grammar.completion-suggested";
   function coerce(t){return t;}
   function tag(param, key, value){return [5, [0, key, value, param]];}
   var
    Sexplib0_Sexp_grammar =
      [0,
       coerce,
       tag,
       doc_comment_tag,
       type_name_tag,
       assoc_tag,
       assoc_key_tag,
       assoc_value_tag,
       completion_suggested];
   runtime.caml_register_global
    (6, Sexplib0_Sexp_grammar, "Sexplib0__Sexp_grammar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_grammar
//# unitInfo: Requires: Sexplib0__Sexp_grammar, Stdlib__ListLabels
//# shape: Sexplib0__Sexp_conv_grammar:[F(2),F(2),N,N,N,N,N,N,N,N,N,N,N,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,N,N]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    unit_sexp_grammar = [2, 0],
    sexp_t_sexp_grammar = [0, "Sexp.t"],
    empty_sexp_grammar = [4, 0],
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels;
   function sexp_grammar_with_tags(grammar, tags){
    return caml_call3
            (Stdlib_ListLabels[27],
             function(param, grammar){
              var value = param[2], key = param[1];
              return [5, [0, key, value, grammar]];
             },
             tags,
             grammar);
   }
   function sexp_grammar_with_tag_list(x, tags){
    return caml_call3
            (Stdlib_ListLabels[27],
             function(param, grammar){
              var value = param[2], key = param[1];
              return [0, [0, key, value, grammar]];
             },
             tags,
             x);
   }
   function ref_sexp_grammar(grammar){
    return Sexplib0_Sexp_grammar[1].call(null, grammar);
   }
   function lazy_t_sexp_grammar(grammar){
    return Sexplib0_Sexp_grammar[1].call(null, grammar);
   }
   function option_sexp_grammar(param){return [1, param];}
   function list_sexp_grammar(param){return [2, [1, param]];}
   function array_sexp_grammar(param){return [2, [1, param]];}
   var
    Sexplib0_Sexp_conv_grammar =
      [0,
       sexp_grammar_with_tags,
       sexp_grammar_with_tag_list,
       unit_sexp_grammar,
       0,
       4,
       4,
       1,
       2,
       3,
       2,
       2,
       2,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       empty_sexp_grammar,
       empty_sexp_grammar];
   runtime.caml_register_global
    (5, Sexplib0_Sexp_conv_grammar, "Sexplib0__Sexp_conv_grammar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv
//# unitInfo: Requires: CamlinternalLazy, Sexplib0__Sexp, Sexplib0__Sexp_conv_grammar, Stdlib, Stdlib__Arg, Stdlib__ArrayLabels, Stdlib__BytesLabels, Stdlib__Ephemeron, Stdlib__Int32, Stdlib__Int64, Stdlib__Lazy, Stdlib__ListLabels, Stdlib__MoreLabels, Stdlib__Nativeint, Stdlib__Obj, Stdlib__Parsing, Stdlib__Printexc, Stdlib__Printf, Stdlib__Queue, Stdlib__Scanf, Stdlib__Stack, Stdlib__StringLabels, Stdlib__Sys
//# shape: Sexplib0__Sexp_conv:[N,N,N,F(2),F(1)*,F(1),F(1)*,F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(2),F(2),F(2),F(3),F(4),F(2),F(2),F(3),F(1)*,F(1)*,N,N,F(2),F(2),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(1),F(2),F(2),F(2),F(3),F(4),F(2),F(2),F(3),F(1),F(1),F(2),F(2),N,N,N,N,N,N,N,N,N,N,N,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,N,N,F(1),F(1),F(1),N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Assert_failure$0 = "Assert_failure",
    cst_None = "None",
    cst_Some = "Some",
    cst_none = "none",
    cst_option_of_sexp_only_none_c$1 = "option_of_sexp: only none can be atom",
    cst_some = "some",
    cst_src_sexp_conv_ml = "src/sexp_conv.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_format_float = runtime.caml_format_float,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Sexplib0_Sexp = global_data.Sexplib0__Sexp,
    Stdlib_Arg = global_data.Stdlib__Arg,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Stdlib_Parsing = global_data.Stdlib__Parsing,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Stdlib_Stack = global_data.Stdlib__Stack,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Obj = global_data.Stdlib__Obj,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_Ephemeron = global_data.Stdlib__Ephemeron,
    Sexplib0_Sexp_conv_grammar = global_data.Sexplib0__Sexp_conv_grammar,
    default_string_of_float =
      [0,
       function(x){
        var y = caml_format_float("%.15G", x);
        return caml_float_of_string(y) === x
                ? y
                : caml_format_float("%.17G", x);
       }],
    read_old_option_format = [0, 1],
    write_old_option_format = [0, 1],
    a = [1, 0],
    b = [0, cst_some],
    c = [1, 0],
    d = [0, cst_none],
    e = [0, "<opaque>"],
    f = [0, "<fun>"];
   function list_map(f, l){return caml_call2(Stdlib_ListLabels[20], f, l);}
   function sexp_of_unit(param){return a;}
   function sexp_of_bool(b){return [0, caml_call1(Stdlib[30], b)];}
   function sexp_of_string(str){return [0, str];}
   function sexp_of_bytes(bytes){
    return [0, caml_call1(Stdlib_BytesLabels[6], bytes)];
   }
   function sexp_of_char(c){
    return [0, caml_call2(Stdlib_StringLabels[1], 1, c)];
   }
   function sexp_of_int(n){return [0, caml_call1(Stdlib[33], n)];}
   function sexp_of_float(n){
    return [0, caml_call1(default_string_of_float[1], n)];
   }
   function sexp_of_int32(n){return [0, caml_call1(Stdlib_Int32[14], n)];}
   function sexp_of_int64(n){return [0, caml_call1(Stdlib_Int64[14], n)];}
   function sexp_of_nativeint(n){
    return [0, caml_call1(Stdlib_Nativeint[15], n)];
   }
   function sexp_of_ref(sexp_of_a, rf){return caml_call1(sexp_of_a, rf[1]);}
   function sexp_of_lazy_t(sexp_of_a, lv){
    var a = runtime.caml_obj_tag(lv);
    a:
    if(250 === a)
     var b = lv[1];
    else{
     if(246 !== a && 244 !== a){var b = lv; break a;}
     var b = caml_call1(CamlinternalLazy[2], lv);
    }
    return caml_call1(sexp_of_a, b);
   }
   function sexp_of_option(sexp_of_a, param){
    if(! param) return write_old_option_format[1] ? c : d;
    var x = param[1];
    return write_old_option_format[1]
            ? [1, [0, caml_call1(sexp_of_a, x), 0]]
            : [1, [0, b, [0, caml_call1(sexp_of_a, x), 0]]];
   }
   function sexp_of_pair(sexp_of_a, sexp_of_b, param){
    var b = param[2], a = param[1], c = [0, caml_call1(sexp_of_b, b), 0];
    return [1, [0, caml_call1(sexp_of_a, a), c]];
   }
   function sexp_of_triple(sexp_of_a, sexp_of_b, sexp_of_c, param){
    var
     c = param[3],
     b = param[2],
     a = param[1],
     d = [0, caml_call1(sexp_of_c, c), 0],
     e = [0, caml_call1(sexp_of_b, b), d];
    return [1, [0, caml_call1(sexp_of_a, a), e]];
   }
   function sexp_of_list(sexp_of_a, lst){
    return [1, caml_call2(Stdlib_ListLabels[20], sexp_of_a, lst)];
   }
   function sexp_of_array(sexp_of_a, ar){
    var lst_ref = [0, 0], a = ar.length - 2 | 0;
    if(a >= 0){
     var i = a;
     for(;;){
      var b = lst_ref[1];
      lst_ref[1] =
       [0, caml_call1(sexp_of_a, caml_check_bound(ar, i)[i + 1]), b];
      var c = i - 1 | 0;
      if(0 === i) break;
      i = c;
     }
    }
    return [1, lst_ref[1]];
   }
   function sexp_of_hashtbl(sexp_of_key, sexp_of_val, htbl){
    function coll(k, v, acc){
     var a = [0, caml_call1(sexp_of_val, v), 0];
     return [0, [1, [0, caml_call1(sexp_of_key, k), a]], acc];
    }
    return [1, caml_call3(Stdlib_MoreLabels[1][14], coll, htbl, 0)];
   }
   function sexp_of_opaque(param){return e;}
   function sexp_of_fun(param){return f;}
   function equal(b, a){return b === a ? 1 : 0;}
   var
    hash = Stdlib_Obj[22][3],
    Exn_table = caml_call1(Stdlib_Ephemeron[1][3], [0, equal, hash]),
    the_exn_table = caml_call1(Exn_table[1], 17);
   function add(opt, param, extension_constructor, sexp_of_exn){
    var printexc = opt ? opt[1] : 1;
    return caml_call3
            (Exn_table[5],
             the_exn_table,
             extension_constructor,
             [0, sexp_of_exn, printexc]);
   }
   function find_auto(for_printexc, exn){
    var
     extension_constructor = caml_call1(Stdlib_Obj[22][1], exn),
     match = caml_call2(Exn_table[8], the_exn_table, extension_constructor);
    if(! match) return 0;
    var match$0 = match[1], printexc = match$0[2], sexp_of_exn = match$0[1];
    if(for_printexc && ! printexc) return 0;
    return [0, caml_call1(sexp_of_exn, exn)];
   }
   function size(param){return caml_call1(Exn_table[18], the_exn_table)[1];}
   var For_unit_tests_only = [0, size], g = [0, 2];
   function sexp_of_exn_opt(exn){return find_auto(0, exn);}
   function sexp_of_exn(exn){
    var match = sexp_of_exn_opt(exn);
    if(! match) return [1, [0, [0, caml_call1(Stdlib_Printexc[1], exn)], 0]];
    var sexp = match[1];
    return sexp;
   }
   function exn_to_string(e){
    var a = sexp_of_exn(e);
    return Sexplib0_Sexp[13].call(null, 0, a);
   }
   caml_call1
    (Stdlib_Printexc[9],
     function(exn){
      var match = find_auto(1, exn);
      if(! match) return 0;
      var sexp = match[1];
      return [0, Sexplib0_Sexp[13].call(null, g, sexp)];
     });
   var h = [0, 2];
   function printexc_prefer_sexp(exn){
    var match = sexp_of_exn_opt(exn);
    if(! match) return caml_call1(Stdlib_Printexc[1], exn);
    var sexp = match[1];
    return Sexplib0_Sexp[13].call(null, h, sexp);
   }
   var
    Of_sexp_error = Sexplib0_Sexp[6],
    record_check_extra_fields = [0, 1],
    cst_unit_of_sexp_empty_list_ne = "unit_of_sexp: empty list needed",
    cst_bool_of_sexp_unknown_strin = "bool_of_sexp: unknown string",
    cst_bool_of_sexp_atom_needed = "bool_of_sexp: atom needed",
    cst_string_of_sexp_atom_needed = "string_of_sexp: atom needed",
    cst_bytes_of_sexp_atom_needed = "bytes_of_sexp: atom needed",
    cst_char_of_sexp_atom_string_m =
      "char_of_sexp: atom string must contain one character only",
    cst_char_of_sexp_atom_needed = "char_of_sexp: atom needed",
    cst_int_of_sexp = "int_of_sexp: ",
    cst_int_of_sexp_atom_needed = "int_of_sexp: atom needed",
    cst_float_of_sexp = "float_of_sexp: ",
    cst_float_of_sexp_atom_needed = "float_of_sexp: atom needed",
    cst_int32_of_sexp = "int32_of_sexp: ",
    cst_int32_of_sexp_atom_needed = "int32_of_sexp: atom needed",
    cst_int64_of_sexp = "int64_of_sexp: ",
    cst_int64_of_sexp_atom_needed = "int64_of_sexp: atom needed",
    cst_nativeint_of_sexp = "nativeint_of_sexp: ",
    cst_nativeint_of_sexp_atom_nee = "nativeint_of_sexp: atom needed",
    cst_option_of_sexp_only_none_c = cst_option_of_sexp_only_none_c$1,
    cst_option_of_sexp_list_must_r =
      "option_of_sexp: list must represent optional value",
    cst_option_of_sexp_only_none_c$0 = cst_option_of_sexp_only_none_c$1,
    cst_option_of_sexp_list_must_b = "option_of_sexp: list must be (some el)",
    cst_pair_of_sexp_list_needed = "pair_of_sexp: list needed",
    cst_pair_of_sexp_list_must_con =
      "pair_of_sexp: list must contain exactly two elements only",
    cst_triple_of_sexp_list_needed = "triple_of_sexp: list needed",
    cst_triple_of_sexp_list_must_c =
      "triple_of_sexp: list must contain exactly three elements only",
    cst_list_of_sexp_list_needed = "list_of_sexp: list needed",
    cst_array_of_sexp_list_needed = "array_of_sexp: list needed",
    cst_hashtbl_of_sexp_list_neede = "hashtbl_of_sexp: list needed",
    cst_hashtbl_of_sexp_tuple_list = "hashtbl_of_sexp: tuple list needed",
    cst_opaque_of_sexp_cannot_conv =
      "opaque_of_sexp: cannot convert opaque values",
    cst_fun_of_sexp_cannot_convert =
      "fun_of_sexp: cannot convert function values";
   function of_sexp_error_exn(exc, sexp){
    throw caml_maybe_attach_backtrace([0, Of_sexp_error, exc, sexp], 1);
   }
   function of_sexp_error(what, sexp){
    throw caml_maybe_attach_backtrace
           ([0, Of_sexp_error, [0, Stdlib[7], what], sexp], 1);
   }
   function unit_of_sexp(sexp){
    if(0 !== sexp[0] && ! sexp[1]) return 0;
    return of_sexp_error(cst_unit_of_sexp_empty_list_ne, sexp);
   }
   function bool_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_bool_of_sexp_atom_needed, sexp);
    var match = sexp[1];
    a:
    if(match !== "False"){
     if(match !== "True"){
      if(match === "false") break a;
      if(match !== "true")
       return of_sexp_error(cst_bool_of_sexp_unknown_strin, sexp);
     }
     return 1;
    }
    return 0;
   }
   function string_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_string_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    return str;
   }
   function bytes_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_bytes_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    return caml_call1(Stdlib_BytesLabels[5], str);
   }
   function char_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_char_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    if(1 !== runtime.caml_ml_string_length(str))
     of_sexp_error(cst_char_of_sexp_atom_string_m, sexp);
    return runtime.caml_string_get(str, 0);
   }
   function int_of_sexp(sexp){
    if(0 !== sexp[0]) return of_sexp_error(cst_int_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var b = caml_int_of_string(str); return b;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), a = exn_to_string(exc);
     return of_sexp_error(caml_call2(Stdlib[28], cst_int_of_sexp, a), sexp);
    }
   }
   function float_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_float_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var b = caml_float_of_string(str); return b;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), a = exn_to_string(exc);
     return of_sexp_error(caml_call2(Stdlib[28], cst_float_of_sexp, a), sexp);
    }
   }
   function int32_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_int32_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var b = caml_int_of_string(str); return b;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), a = exn_to_string(exc);
     return of_sexp_error(caml_call2(Stdlib[28], cst_int32_of_sexp, a), sexp);
    }
   }
   function int64_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_int64_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var b = runtime.caml_int64_of_string(str); return b;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), a = exn_to_string(exc);
     return of_sexp_error(caml_call2(Stdlib[28], cst_int64_of_sexp, a), sexp);
    }
   }
   function nativeint_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_nativeint_of_sexp_atom_nee, sexp);
    var str = sexp[1];
    try{var b = caml_int_of_string(str); return b;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), a = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_nativeint_of_sexp, a), sexp);
    }
   }
   function ref_of_sexp(a_of_sexp, sexp){
    return [0, caml_call1(a_of_sexp, sexp)];
   }
   function lazy_t_of_sexp(a_of_sexp, sexp){
    var a = caml_call1(a_of_sexp, sexp);
    return caml_call1(Stdlib_Lazy[4], a);
   }
   function option_of_sexp(a_of_sexp, sexp){
    if(! read_old_option_format[1]){
     if(0 === sexp[0]){
      var match$0 = sexp[1];
      if(match$0 !== cst_None && match$0 !== cst_none)
       return of_sexp_error(cst_option_of_sexp_only_none_c$0, sexp);
      return 0;
     }
     var match$1 = sexp[1];
     a:
     if(match$1){
      var f = match$1[1];
      if(0 === f[0]){
       var g = f[1];
       if(g !== cst_Some && g !== cst_some) break a;
       var c = match$1[2];
       if(c && ! c[2]){
        var el$0 = c[1];
        return [0, caml_call1(a_of_sexp, el$0)];
       }
      }
     }
     return of_sexp_error(cst_option_of_sexp_list_must_b, sexp);
    }
    if(0 === sexp[0]){
     var match = sexp[1];
     if(match !== cst_None && match !== cst_none)
      return of_sexp_error(cst_option_of_sexp_only_none_c, sexp);
    }
    else{
     var a = sexp[1];
     if(a){
      var b = a[1];
      a:
      {
       if(a[2]){
        b:
        if(0 === b[0]){
         var d = b[1];
         if(d !== cst_Some && d !== cst_some) break b;
         var e = a[2];
         if(! e[2]){var el = e[1]; break a;}
        }
        return of_sexp_error(cst_option_of_sexp_list_must_r, sexp);
       }
       var el = b;
      }
      return [0, caml_call1(a_of_sexp, el)];
     }
    }
    return 0;
   }
   function pair_of_sexp(a_of_sexp, b_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_pair_of_sexp_list_needed, sexp);
    var match = sexp[1];
    if(match){
     var c = match[2];
     if(c && ! c[2]){
      var
       b_sexp = c[1],
       a_sexp = match[1],
       a = caml_call1(a_of_sexp, a_sexp),
       b = caml_call1(b_of_sexp, b_sexp);
      return [0, a, b];
     }
    }
    return of_sexp_error(cst_pair_of_sexp_list_must_con, sexp);
   }
   function triple_of_sexp(a_of_sexp, b_of_sexp, c_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_triple_of_sexp_list_needed, sexp);
    var match = sexp[1];
    if(match){
     var d = match[2];
     if(d){
      var e = d[2];
      if(e && ! e[2]){
       var
        c_sexp = e[1],
        b_sexp = d[1],
        a_sexp = match[1],
        a = caml_call1(a_of_sexp, a_sexp),
        b = caml_call1(b_of_sexp, b_sexp),
        c = caml_call1(c_of_sexp, c_sexp);
       return [0, a, b, c];
      }
     }
    }
    return of_sexp_error(cst_triple_of_sexp_list_must_c, sexp);
   }
   function list_of_sexp(a_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_list_of_sexp_list_needed, sexp);
    var lst = sexp[1];
    return caml_call2(Stdlib_ListLabels[20], a_of_sexp, lst);
   }
   function array_of_sexp(a_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_array_of_sexp_list_needed, sexp);
    var match = sexp[1];
    if(! match) return [0];
    var
     t = match[2],
     h = match[1],
     len = caml_call1(Stdlib_ListLabels[1], t) + 1 | 0,
     res = runtime.caml_array_make(len, caml_call1(a_of_sexp, h)),
     i = 1,
     param = t;
    for(;;){
     if(! param) return res;
     var t$0 = param[2], h$0 = param[1], a = caml_call1(a_of_sexp, h$0);
     caml_check_bound(res, i)[i + 1] = a;
     var i$0 = i + 1 | 0;
     i = i$0;
     param = t$0;
    }
   }
   function hashtbl_of_sexp(key_of_sexp, val_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_hashtbl_of_sexp_list_neede, sexp);
    var lst = sexp[1], htbl = caml_call2(Stdlib_MoreLabels[1][1], 0, 0);
    function act(param){
     if(0 !== param[0]){
      var a = param[1];
      if(a){
       var b = a[2];
       if(b && ! b[2]){
        var
         v_sexp = b[1],
         k_sexp = a[1],
         c = caml_call1(val_of_sexp, v_sexp),
         d = caml_call1(key_of_sexp, k_sexp);
        return caml_call3(Stdlib_MoreLabels[1][5], htbl, d, c);
       }
      }
     }
     return of_sexp_error(cst_hashtbl_of_sexp_tuple_list, sexp);
    }
    caml_call2(Stdlib_ListLabels[18], act, lst);
    return htbl;
   }
   function opaque_of_sexp(sexp){
    return of_sexp_error(cst_opaque_of_sexp_cannot_conv, sexp);
   }
   function fun_of_sexp(sexp){
    return of_sexp_error(cst_fun_of_sexp_cannot_convert, sexp);
   }
   var
    sexp_grammar_with_tags = Sexplib0_Sexp_conv_grammar[1],
    sexp_grammar_with_tag_list = Sexplib0_Sexp_conv_grammar[2],
    unit_sexp_grammar = Sexplib0_Sexp_conv_grammar[3],
    bool_sexp_grammar = Sexplib0_Sexp_conv_grammar[4],
    string_sexp_grammar = Sexplib0_Sexp_conv_grammar[5],
    bytes_sexp_grammar = Sexplib0_Sexp_conv_grammar[6],
    char_sexp_grammar = Sexplib0_Sexp_conv_grammar[7],
    int_sexp_grammar = Sexplib0_Sexp_conv_grammar[8],
    float_sexp_grammar = Sexplib0_Sexp_conv_grammar[9],
    int32_sexp_grammar = Sexplib0_Sexp_conv_grammar[10],
    int64_sexp_grammar = Sexplib0_Sexp_conv_grammar[11],
    nativeint_sexp_grammar = Sexplib0_Sexp_conv_grammar[12],
    sexp_t_sexp_grammar = Sexplib0_Sexp_conv_grammar[13],
    ref_sexp_grammar = Sexplib0_Sexp_conv_grammar[14],
    lazy_t_sexp_grammar = Sexplib0_Sexp_conv_grammar[15],
    option_sexp_grammar = Sexplib0_Sexp_conv_grammar[16],
    list_sexp_grammar = Sexplib0_Sexp_conv_grammar[17],
    array_sexp_grammar = Sexplib0_Sexp_conv_grammar[18],
    opaque_sexp_grammar = Sexplib0_Sexp_conv_grammar[19],
    fun_sexp_grammar = Sexplib0_Sexp_conv_grammar[20],
    i =
      [0,
       [2,
        0,
        [12, 32, [2, 0, [12, 58, [4, 0, 0, 0, [12, 58, [4, 0, 0, 0, 0]]]]]]],
       "%s %s:%d:%d"];
   function get_flc_error(name, param){
    var chr = param[3], line = param[2], file = param[1];
    return [0, caml_call5(Stdlib_Printf[4], i, name, file, line, chr)];
   }
   var
    j = [0, "Sys.Break"],
    k = [0, cst_src_sexp_conv_ml, 394, 15],
    l = [0, "Stack.Empty"],
    m = [0, cst_src_sexp_conv_ml, 390, 15],
    n = [0, "Scanf.Scan_failure"],
    o = [0, cst_src_sexp_conv_ml, 386, 15],
    p = [0, "Queue.Empty"],
    q = [0, cst_src_sexp_conv_ml, 382, 15],
    r = [0, "Parsing.Parse_error"],
    s = [0, cst_src_sexp_conv_ml, 378, 15],
    t = [0, "Lazy.Undefined"],
    u = [0, cst_src_sexp_conv_ml, 374, 15],
    v = [0, "Arg.Bad"],
    w = [0, cst_src_sexp_conv_ml, 370, 15],
    x = [0, "Arg.Help"],
    y = [0, cst_src_sexp_conv_ml, 366, 15],
    z = [0, "Sys_error"],
    A = [0, cst_src_sexp_conv_ml, 362, 15],
    B = [0, "Not_found_s"],
    C = [0, cst_src_sexp_conv_ml, 358, 15],
    cst_Match_failure = "Match_failure",
    D = [0, cst_src_sexp_conv_ml, 354, 15],
    E = [0, "Invalid_argument"],
    F = [0, cst_src_sexp_conv_ml, 350, 15],
    G = [0, "Not_found"],
    H = [0, cst_src_sexp_conv_ml, 346, 15],
    I = [0, "Failure"],
    J = [0, cst_src_sexp_conv_ml, 342, 15],
    K = [0, "End_of_file"],
    L = [0, cst_src_sexp_conv_ml, 338, 15],
    M = [0, "Exit"],
    N = [0, cst_src_sexp_conv_ml, 334, 15],
    cst_Assert_failure = cst_Assert_failure$0,
    O = [0, cst_src_sexp_conv_ml, 330, 15],
    P = [0, 0],
    Q = [0, 0];
   caml_call2
    (Stdlib_ListLabels[18],
     function(param){
      var handler = param[2], extension_constructor = param[1];
      return add(Q, P, extension_constructor, handler);
     },
     [0,
      [0,
       Stdlib[5],
       function(param){
        var tag = param[1];
        if(tag !== Stdlib[5])
         throw caml_maybe_attach_backtrace([0, Assert_failure, O], 1);
        var arg = param[2];
        return get_flc_error(cst_Assert_failure, arg);
       }],
      [0,
       [0,
        Stdlib[3],
        function(param){
         if(param === Stdlib[3]) return M;
         throw caml_maybe_attach_backtrace([0, Assert_failure, N], 1);
        }],
       [0,
        [0,
         Stdlib[12],
         function(param){
          if(param === Stdlib[12]) return K;
          throw caml_maybe_attach_backtrace([0, Assert_failure, L], 1);
         }],
        [0,
         [0,
          Stdlib[7],
          function(param){
           var tag = param[1];
           if(tag !== Stdlib[7])
            throw caml_maybe_attach_backtrace([0, Assert_failure, J], 1);
           var arg = param[2];
           return [1, [0, I, [0, [0, arg], 0]]];
          }],
         [0,
          [0,
           Stdlib[8],
           function(param){
            if(param === Stdlib[8]) return G;
            throw caml_maybe_attach_backtrace([0, Assert_failure, H], 1);
           }],
          [0,
           [0,
            Stdlib[6],
            function(param){
             var tag = param[1];
             if(tag !== Stdlib[6])
              throw caml_maybe_attach_backtrace([0, Assert_failure, F], 1);
             var arg = param[2];
             return [1, [0, E, [0, [0, arg], 0]]];
            }],
           [0,
            [0,
             Stdlib[4],
             function(param){
              var tag = param[1];
              if(tag !== Stdlib[4])
               throw caml_maybe_attach_backtrace([0, Assert_failure, D], 1);
              var arg = param[2];
              return get_flc_error(cst_Match_failure, arg);
             }],
            [0,
             [0,
              Sexplib0_Sexp[5],
              function(param){
               var tag = param[1];
               if(tag !== Sexplib0_Sexp[5])
                throw caml_maybe_attach_backtrace([0, Assert_failure, C], 1);
               var arg = param[2];
               return [1, [0, B, [0, arg, 0]]];
              }],
             [0,
              [0,
               Stdlib[11],
               function(param){
                var tag = param[1];
                if(tag !== Stdlib[11])
                 throw caml_maybe_attach_backtrace([0, Assert_failure, A], 1);
                var arg = param[2];
                return [1, [0, z, [0, [0, arg], 0]]];
               }],
              [0,
               [0,
                Stdlib_Arg[7],
                function(param){
                 var tag = param[1];
                 if(tag !== Stdlib_Arg[7])
                  throw caml_maybe_attach_backtrace([0, Assert_failure, y], 1);
                 var arg = param[2];
                 return [1, [0, x, [0, [0, arg], 0]]];
                }],
               [0,
                [0,
                 Stdlib_Arg[8],
                 function(param){
                  var tag = param[1];
                  if(tag !== Stdlib_Arg[8])
                   throw caml_maybe_attach_backtrace([0, Assert_failure, w], 1);
                  var arg = param[2];
                  return [1, [0, v, [0, [0, arg], 0]]];
                 }],
                [0,
                 [0,
                  Stdlib_Lazy[1],
                  function(param){
                   if(param === Stdlib_Lazy[1]) return t;
                   throw caml_maybe_attach_backtrace([0, Assert_failure, u], 1);
                  }],
                 [0,
                  [0,
                   Stdlib_Parsing[10],
                   function(param){
                    if(param === Stdlib_Parsing[10]) return r;
                    throw caml_maybe_attach_backtrace([0, Assert_failure, s], 1);
                   }],
                  [0,
                   [0,
                    Stdlib_Queue[1],
                    function(param){
                     if(param === Stdlib_Queue[1]) return p;
                     throw caml_maybe_attach_backtrace([0, Assert_failure, q], 1);
                    }],
                   [0,
                    [0,
                     Stdlib_Scanf[2],
                     function(param){
                      var tag = param[1];
                      if(tag !== Stdlib_Scanf[2])
                       throw caml_maybe_attach_backtrace([0, Assert_failure, o], 1);
                      var arg = param[2];
                      return [1, [0, n, [0, [0, arg], 0]]];
                     }],
                    [0,
                     [0,
                      Stdlib_Stack[1],
                      function(param){
                       if(param === Stdlib_Stack[1]) return l;
                       throw caml_maybe_attach_backtrace([0, Assert_failure, m], 1);
                      }],
                     [0,
                      [0,
                       Stdlib_Sys[44],
                       function(param){
                        if(param === Stdlib_Sys[44]) return j;
                        throw caml_maybe_attach_backtrace([0, Assert_failure, k], 1);
                       }],
                      0]]]]]]]]]]]]]]]]]);
   var
    R = [0, "Sexplib.Conv.Of_sexp_error"],
    S = [0, cst_src_sexp_conv_ml, 406, 15],
    T = [0, 0],
    U = [0, 1];
   caml_call2
    (Stdlib_ListLabels[18],
     function(param){
      var handler = param[2], extension_constructor = param[1];
      return add(U, T, extension_constructor, handler);
     },
     [0,
      [0,
       Of_sexp_error,
       function(param){
        var tag = param[1];
        if(tag !== Of_sexp_error)
         throw caml_maybe_attach_backtrace([0, Assert_failure, S], 1);
        var sexp = param[3], exc = param[2];
        return [1, [0, R, [0, sexp_of_exn(exc), [0, sexp, 0]]]];
       }],
      0]);
   var
    Sexplib0_Sexp_conv =
      [0,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       sexp_grammar_with_tags,
       sexp_grammar_with_tag_list,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       [0, add, For_unit_tests_only]];
   runtime.caml_register_global
    (117, Sexplib0_Sexp_conv, "Sexplib0__Sexp_conv");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_error
//# unitInfo: Requires: Sexplib0__Sexp_conv, Stdlib__ListLabels, Stdlib__Printf, Stdlib__StringLabels
//# shape: Sexplib0__Sexp_conv_error:[N,F(3),F(3),F(3),F(3),F(4),F(2),F(3),F(2),F(2),F(2),F(2),F(2),F(2),F(4),F(3),F(3),F(2),F(3),F(2),F(2),N,F(1),F(2),F(2),F(3),F(2),F(2),F(2),F(2)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = " ",
    cst_has_incorrect_number_of_ar = " has incorrect number of arguments",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    msg = "this constructor does not take arguments",
    msg$0 = "this constructor requires arguments",
    msg$1 = "expected a variant type, saw a nested list",
    msg$2 = "expected a variant type, saw an empty list",
    msg$3 = "unexpected variant constructor",
    msg$4 = "record conversion: a [sexp.bool] field was given a payload.",
    msg$5 =
      "record conversion: only pairs expected, their first element must be an atom",
    msg$6 = "list instead of atom for record expected",
    msg$7 =
      "cannot convert values of types resulting from polymorphic record fields",
    msg$8 = "no matching variant found",
    msg$9 = "polymorphic variant does not take arguments",
    msg$10 = "polymorphic variant tag takes an argument",
    msg$11 = "a nested list is an invalid polymorphic variant",
    msg$12 = "the empty list is an invalid polymorphic variant",
    msg$13 = "trying to convert an empty type",
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Of_sexp_error = Sexplib0_Sexp_conv[25],
    a = [0, [2, 0, [11, "_of_sexp: ", [2, 0, 0]]], "%s_of_sexp: %s"],
    b =
      [0,
       [11, "tuple of size ", [4, 0, 0, 0, [11, " expected", 0]]],
       "tuple of size %d expected"],
    c =
      [0,
       [2,
        0,
        [11, "_of_sexp: expected a pair beginning with label ", [2, 0, 0]]],
       "%s_of_sexp: expected a pair beginning with label %s"],
    d =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: incorrect label for element ",
         [2, 0, [11, " at position ", [4, 3, 0, 0, 0]]]]],
       "%s_of_sexp: incorrect label for element %s at position %i"],
    e =
      [0,
       [11, "sum tag ", [3, 0, [11, cst_has_incorrect_number_of_ar, 0]]],
       "sum tag %S has incorrect number of arguments"],
    f = [0, [2, 0, [11, ": ", [2, 0, 0]]], "%s: %s"],
    cst_duplicate_fields = "duplicate fields",
    cst_extra_fields = "extra fields",
    g =
      [0,
       [11, "the following record elements were undefined: ", [2, 0, 0]],
       "the following record elements were undefined: %s"];
   function error(loc, sexp, msg){
    var b = caml_call3(Stdlib_Printf[4], a, loc, msg);
    return Sexplib0_Sexp_conv[27].call(null, b, sexp);
   }
   function simple_error(msg, loc, sexp){return error(loc, sexp, msg);}
   function tuple_of_size_n_expected(loc, n, sexp){
    return error(loc, sexp, caml_call2(Stdlib_Printf[4], b, n));
   }
   function tuple_pair_expected(loc, name, sexp){
    var msg = caml_call3(Stdlib_Printf[4], c, loc, name);
    return Sexplib0_Sexp_conv[27].call(null, msg, sexp);
   }
   function tuple_incorrect_label(loc, name, pos, sexp){
    var msg = caml_call4(Stdlib_Printf[4], d, loc, name, pos);
    return Sexplib0_Sexp_conv[27].call(null, msg, sexp);
   }
   function stag_no_args(loc, sexp){return error(loc, sexp, msg);}
   function stag_incorrect_n_args(loc, tag, sexp){
    return error(loc, sexp, caml_call2(Stdlib_Printf[4], e, tag));
   }
   function stag_takes_args(loc, sexp){return error(loc, sexp, msg$0);}
   function nested_list_invalid_sum(loc, sexp){return error(loc, sexp, msg$1);
   }
   function empty_list_invalid_sum(loc, sexp){return error(loc, sexp, msg$2);}
   function unexpected_stag(loc, sexp){return error(loc, sexp, msg$3);}
   function record_sexp_bool_with_payload(loc, sexp){return error(loc, sexp, msg$4);
   }
   function record_only_pairs_expected(loc, sexp){return error(loc, sexp, msg$5);
   }
   function record_invalid_fields(what, loc, fld_names, sexp){
    var fld_names_str = caml_call2(Stdlib_StringLabels[7], cst, fld_names);
    return error
            (loc, sexp, caml_call3(Stdlib_Printf[4], f, what, fld_names_str));
   }
   function record_duplicate_fields(loc, fld_names, sexp){
    return record_invalid_fields(cst_duplicate_fields, loc, fld_names, sexp);
   }
   function record_extra_fields(loc, fld_names, sexp){
    return record_invalid_fields(cst_extra_fields, loc, fld_names, sexp);
   }
   function record_get_undefined_loop(fields$1, param$0){
    var fields = fields$1, param = param$0;
    for(;;){
     if(! param){
      var b = caml_call1(Stdlib_ListLabels[10], fields);
      return caml_call2(Stdlib_StringLabels[7], cst$0, b);
     }
     var a = param[1];
     if(a[1]){
      var rest = param[2], field = a[2], fields$0 = [0, field, fields];
      fields = fields$0;
      param = rest;
     }
     else{var rest$0 = param[2]; param = rest$0;}
    }
   }
   function record_undefined_elements(loc, sexp, lst){
    var
     undefined$ = record_get_undefined_loop(0, lst),
     msg = caml_call2(Stdlib_Printf[4], g, undefined$);
    return error(loc, sexp, msg);
   }
   function record_list_instead_atom(loc, sexp){return error(loc, sexp, msg$6);
   }
   function record_poly_field_value(loc, sexp){return error(loc, sexp, msg$7);
   }
   var
    No_variant_match =
      [248,
       "Sexplib0__Sexp_conv_error.No_variant_match",
       runtime.caml_fresh_oo_id(0)],
    h =
      [0,
       [11,
        "polymorphic variant tag ",
        [3, 0, [11, cst_has_incorrect_number_of_ar, 0]]],
       "polymorphic variant tag %S has incorrect number of arguments"];
   function no_variant_match(param){
    throw caml_maybe_attach_backtrace(No_variant_match, 1);
   }
   function no_matching_variant_found(loc, sexp){return error(loc, sexp, msg$8);
   }
   function ptag_no_args(loc, sexp){return error(loc, sexp, msg$9);}
   function ptag_incorrect_n_args(loc, cnstr, sexp){
    return error(loc, sexp, caml_call2(Stdlib_Printf[4], h, cnstr));
   }
   function ptag_takes_args(loc, sexp){return error(loc, sexp, msg$10);}
   function nested_list_invalid_poly_var(loc, sexp){return error(loc, sexp, msg$11);
   }
   function empty_list_invalid_poly_var(loc, sexp){return error(loc, sexp, msg$12);
   }
   function empty_type(loc, sexp){return error(loc, sexp, msg$13);}
   var
    Sexplib0_Sexp_conv_error =
      [0,
       Of_sexp_error,
       error,
       simple_error,
       tuple_of_size_n_expected,
       tuple_pair_expected,
       tuple_incorrect_label,
       stag_no_args,
       stag_incorrect_n_args,
       stag_takes_args,
       nested_list_invalid_sum,
       empty_list_invalid_sum,
       unexpected_stag,
       record_sexp_bool_with_payload,
       record_only_pairs_expected,
       record_invalid_fields,
       record_duplicate_fields,
       record_extra_fields,
       record_get_undefined_loop,
       record_undefined_elements,
       record_list_instead_atom,
       record_poly_field_value,
       No_variant_match,
       no_variant_match,
       no_matching_variant_found,
       ptag_no_args,
       ptag_incorrect_n_args,
       ptag_takes_args,
       nested_list_invalid_poly_var,
       empty_list_invalid_poly_var,
       empty_type];
   runtime.caml_register_global
    (32, Sexplib0_Sexp_conv_error, "Sexplib0__Sexp_conv_error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_labeled_tuple
//# unitInfo: Requires: Sexplib0__Sexp_conv_error, Stdlib__String
//# shape: Sexplib0__Sexp_conv_labeled_tuple:[N,F(4)]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_String = global_data.Stdlib__String,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error;
   function labeled_tuple_of_sexp(caller, fields$2, create, original_sexp){
    var t = fields$2, acc = 0;
    for(;;){
     if(! t) break;
     var acc$0 = acc + 1 | 0, t$0 = t[3];
     t = t$0;
     acc = acc$0;
    }
    if(0 === original_sexp[0])
     return Sexplib0_Sexp_conv_error[4].call(null, caller, acc, original_sexp);
    var list$2 = original_sexp[1];
    a:
    {
     var pos$1 = 0;
     if(fields$2){
      var fields = fields$2[3], conv = fields$2[2], name = fields$2[1];
      if(list$2){
       var list = list$2[2], sexp = list$2[1];
       if(0 !== sexp[0]){
        var b = sexp[1];
        if(b){
         var f = b[1];
         if(0 === f[0]){
          var c = b[2];
          if(c && ! c[2]){
           var sexp$0 = c[1], atom = f[1];
           if(! caml_call2(Stdlib_String[9], atom, name)){
            var
             a =
               Sexplib0_Sexp_conv_error[6].call
                (null, caller, name, pos$1, original_sexp);
            break a;
           }
           var
            block = [0, caml_call1(conv, sexp$0), 24029],
            dst = block,
            offset = 1,
            fields$0 = fields,
            pos = 1,
            list$0 = list;
           for(;;){
            if(! fields$0){
             if(list$0){
              dst[offset + 1] =
               Sexplib0_Sexp_conv_error[4].call
                (null, caller, acc, original_sexp);
              var a = block;
              break a;
             }
             dst[offset + 1] = 0;
             var a = block;
             break a;
            }
            var
             fields$1 = fields$0[3],
             conv$0 = fields$0[2],
             name$0 = fields$0[1];
            if(! list$0){
             dst[offset + 1] =
              Sexplib0_Sexp_conv_error[4].call
               (null, caller, acc, original_sexp);
             var a = block;
             break a;
            }
            var list$1 = list$0[2], sexp$1 = list$0[1];
            if(0 !== sexp$1[0]){
             var d = sexp$1[1];
             if(d){
              var g = d[1];
              if(0 === g[0]){
               var e = d[2];
               if(e && ! e[2]){
                var sexp$2 = e[1], atom$0 = g[1];
                if(caml_call2(Stdlib_String[9], atom$0, name$0)){
                 var dst$0 = [0, caml_call1(conv$0, sexp$2), 24029];
                 dst[offset + 1] = dst$0;
                 var pos$0 = pos + 1 | 0;
                 dst = dst$0;
                 offset = 1;
                 fields$0 = fields$1;
                 pos = pos$0;
                 list$0 = list$1;
                 continue;
                }
                dst[offset + 1] =
                 Sexplib0_Sexp_conv_error[6].call
                  (null, caller, name$0, pos, original_sexp);
                var a = block;
                break a;
               }
              }
             }
            }
            dst[offset + 1] =
             Sexplib0_Sexp_conv_error[5].call(null, caller, name$0, sexp$1);
            var a = block;
            break a;
           }
          }
         }
        }
       }
       var a = Sexplib0_Sexp_conv_error[5].call(null, caller, name, sexp);
      }
      else
       var
        a = Sexplib0_Sexp_conv_error[4].call(null, caller, acc, original_sexp);
     }
     else
      var
       a =
         list$2
          ? Sexplib0_Sexp_conv_error[4].call(null, caller, acc, original_sexp)
          : 0;
    }
    return caml_call1(create, a);
   }
   var Sexplib0_Sexp_conv_labeled_tup = [0, [0], labeled_tuple_of_sexp];
   runtime.caml_register_global
    (2, Sexplib0_Sexp_conv_labeled_tup, "Sexplib0__Sexp_conv_labeled_tuple");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_record
//# unitInfo: Requires: Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Stdlib, Stdlib__ArrayLabels, Stdlib__ListLabels, Stdlib__Option, Stdlib__StringLabels
//# shape: Sexplib0__Sexp_conv_record:[[],N,F(6),F(7)]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    absent = [0, ""],
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib = global_data.Stdlib,
    Kind = [0];
   function combine(a, b){
    a:
    if(typeof a !== "number"){
     b:
     {
      c:
      {
       switch(a[0]){
         case 0:
          var a$0 = a[1];
          if(typeof b === "number") break b;
          switch(b[0]){
            case 0:
             var b$0 = b[1]; return [0, caml_call2(Stdlib[37], a$0, b$0)];
            case 3:
             break b;
            case 1:
             var t = b; break c;
            default: var t$0 = a;
          }
          break;
         case 1:
          var a$1 = a[1];
          if(typeof b === "number") break b;
          switch(b[0]){
            case 1:
             var b$1 = b[1]; return [1, caml_call2(Stdlib[37], a$1, b$1)];
            case 3:
             break b;
            default: var t = a; break c;
          }
         case 2:
          var a$2 = a[1];
          if(typeof b === "number") break b;
          switch(b[0]){
            case 2:
             var b$2 = b[1]; return [2, caml_call2(Stdlib[37], a$2, b$2)];
            case 3:
             break b;
            case 1:
             var t = b; break c;
            default: var t$0 = b;
          }
          break;
         default: break a;
       }
       return t$0;
      }
      return t;
     }
     return b;
    }
    return a;
   }
   var
    Malformed =
      [248,
       "Sexplib0__Sexp_conv_record.Malformed",
       runtime.caml_fresh_oo_id(0)],
    a = [1, 0],
    b = [3, 0],
    dummy = 0;
   function parse_value_malformed(malformed, fields, state, pos){
    try{
     parse_values(fields[4], state, pos + 1 | 0);
     var malformed$0 = malformed;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag !== Malformed) throw caml_maybe_attach_backtrace(exn, 0);
     var other = exn[2], malformed$0 = combine(malformed, other);
    }
    throw caml_maybe_attach_backtrace([0, Malformed, malformed$0], 1);
   }
   function parse_values(fields, state, pos){
    if(! fields) return 0;
    var
     rest = fields[4],
     conv = fields[3],
     kind = fields[2],
     name = fields[1],
     sexp$5 = state[pos + 1];
    a:
    {
     if(typeof kind === "number")
      switch(kind){
        case 0:
         if(0 === sexp$5[0]){var value = caml_call1(conv, a); break a;}
         var i = sexp$5[1];
         if(i){
          var c = i[2];
          if(c && ! c[2]){
           var sexp = c[1], value = caml_call1(conv, sexp);
           break a;
          }
         }
         break;
        case 1:
         if(0 === sexp$5[0]){
          var
           value =
             parse_value_malformed([2, [0, name, 0]], fields, state, pos);
          break a;
         }
         var k = sexp$5[1];
         if(k){
          var d = k[2];
          if(d && ! d[2]){
           var sexp$0 = d[1], value = caml_call1(conv, sexp$0);
           break a;
          }
         }
         break;
        case 2:
         if(0 === sexp$5[0]){var value = [0]; break a;}
         var l = sexp$5[1];
         if(l){
          var e = l[2];
          if(e && ! e[2]){
           var
            sexp$1 = e[1],
            value = Sexplib0_Sexp_conv[45].call(null, conv, sexp$1);
           break a;
          }
         }
         break;
        case 3:
         if(0 === sexp$5[0]){var value = 0; break a;}
         var m = sexp$5[1];
         if(m && ! m[2]){var value = 1; break a;}
         var value = parse_value_malformed(0, fields, state, pos);
         break a;
        case 4:
         if(0 === sexp$5[0]){var value = 0; break a;}
         var n = sexp$5[1];
         if(n){
          var f = n[2];
          if(f && ! f[2]){
           var
            sexp$2 = f[1],
            value = Sexplib0_Sexp_conv[44].call(null, conv, sexp$2);
           break a;
          }
         }
         break;
        default:
         if(0 === sexp$5[0]){var value = 0; break a;}
         var o = sexp$5[1];
         if(o){
          var g = o[2];
          if(g && ! g[2]){
           var sexp$3 = g[1], value = [0, caml_call1(conv, sexp$3)];
           break a;
          }
         }
      }
     else{
      var default$ = kind[1];
      if(0 === sexp$5[0]){var value = caml_call1(default$, 0); break a;}
      var p = sexp$5[1];
      if(p){
       var h = p[2];
       if(h && ! h[2]){
        var sexp$4 = h[1], value = caml_call1(conv, sexp$4);
        break a;
       }
      }
     }
     var j = sexp$5[1];
     if(j && j[2]){
      var value = parse_value_malformed([3, [0, sexp$5]], fields, state, pos);
      break a;
     }
     var value = parse_value_malformed(b, fields, state, pos);
    }
    return [0, value, parse_values(rest, state, pos + 1 | 0)];
   }
   function parse_spine_malformed
   (malformed, index, extra, seen, state, len, sexps){
    try{
     parse_spine_slow(index, extra, seen, state, len, sexps);
     var malformed$0 = malformed;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag !== Malformed) throw caml_maybe_attach_backtrace(exn, 0);
     var other = exn[2], malformed$0 = combine(malformed, other);
    }
    throw caml_maybe_attach_backtrace([0, Malformed, malformed$0], 1);
   }
   function parse_spine_slow(index, extra, seen, state, len, sexps$2){
    var sexps = sexps$2;
    for(;;){
     if(! sexps) return;
     var field = sexps[1];
     if(0 !== field[0]){
      var a = field[1];
      if(a){
       var match = a[1];
       if(0 === match[0]){
        var
         sexps$1 = sexps[2],
         name = match[1],
         i = caml_call1(index, name),
         b = seen <= i ? 1 : 0,
         match$0 = b ? i < len ? 1 : 0 : b;
        if(match$0){
         var pos = i - seen | 0;
         if(0 !== state[pos + 1][0])
          return parse_spine_malformed
                  ([1, [0, name, 0]], index, extra, seen, state, len, sexps$1);
         state[pos + 1] = field;
         sexps = sexps$1;
         continue;
        }
        var c = 0 <= i ? 1 : 0, match$1 = c ? i < seen ? 1 : 0 : c;
        if(match$1)
         return parse_spine_malformed
                 ([1, [0, name, 0]], index, extra, seen, state, len, sexps$1);
        if(! extra)
         return parse_spine_malformed
                 ([0, [0, name, 0]], index, extra, seen, state, len, sexps$1);
        sexps = sexps$1;
        continue;
       }
      }
     }
     var sexps$0 = sexps[2];
     return parse_spine_malformed
             ([3, [0, field]], index, extra, seen, state, len, sexps$0);
    }
   }
   function parse_record_slow(fields, index, extra, seen, sexps){
    var t = fields, unseen = 0;
    for(;;){
     if(! t){
      var
       state = runtime.caml_array_make(unseen, absent),
       len = seen + unseen | 0;
      parse_spine_slow(index, extra, seen, state, len, sexps);
      return parse_values(fields, state, 0);
     }
     var rest = t[4], acc = unseen + 1 | 0;
     t = rest;
     unseen = acc;
    }
   }
   function parse_spine_fast(fields, index, extra, seen, sexps){
    if(! fields)
     return sexps ? parse_record_slow(fields, index, extra, seen, sexps) : 0;
    var
     rest = fields[4],
     conv = fields[3],
     kind = fields[2],
     name = fields[1];
    if(sexps){
     var b = sexps[1];
     if(0 !== b[0]){
      var a = b[1];
      if(a){
       var match = a[1];
       if(0 === match[0]){
        var others = sexps[2], args = a[2], atom = match[1];
        if(caml_call2(Stdlib_StringLabels[9], atom, name)){
         if(typeof kind === "number")
          switch(kind){
            case 0:
             if(args && ! args[2]){
              var
               sexp = args[1],
               c = parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0, caml_call1(conv, sexp), c];
             }
             break;
            case 1:
             if(args && ! args[2]){
              var
               sexp$0 = args[1],
               d = parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0, caml_call1(conv, sexp$0), d];
             }
             break;
            case 2:
             if(args && ! args[2]){
              var
               sexp$1 = args[1],
               e = parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0, Sexplib0_Sexp_conv[45].call(null, conv, sexp$1), e];
             }
             break;
            case 3:
             if(! args)
              return [0,
                      1,
                      parse_spine_fast(rest, index, extra, seen + 1 | 0, others)];
             break;
            case 4:
             if(args && ! args[2]){
              var
               sexp$2 = args[1],
               f = parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0, Sexplib0_Sexp_conv[44].call(null, conv, sexp$2), f];
             }
             break;
            default:
             if(args && ! args[2]){
              var
               sexp$3 = args[1],
               g = parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0, [0, caml_call1(conv, sexp$3)], g];
             }
          }
         else if(args && ! args[2]){
          var
           sexp$4 = args[1],
           h = parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
          return [0, caml_call1(conv, sexp$4), h];
         }
         return parse_record_slow(fields, index, extra, seen, sexps);
        }
       }
      }
     }
    }
    return parse_record_slow(fields, index, extra, seen, sexps);
   }
   function record_of_sexps
   (caller,
    context$0,
    fields,
    index_of_field,
    allow_extra_fields,
    create,
    sexps){
    var
     allow_extra_fields$0 =
       allow_extra_fields || 1 - Sexplib0_Sexp_conv[26][1];
    try{
     var
      value =
        parse_spine_fast
         (fields, index_of_field, allow_extra_fields$0, 0, sexps);
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag !== Malformed) throw caml_maybe_attach_backtrace(exn, 0);
     var malformed = exn[2];
     if(typeof malformed === "number")
      return Sexplib0_Sexp_conv_error[13].call(null, caller, context$0);
     switch(malformed[0]){
       case 0:
        var names = malformed[1];
        return Sexplib0_Sexp_conv_error[17].call
                (null, caller, names, context$0);
       case 1:
        var names$0 = malformed[1];
        return Sexplib0_Sexp_conv_error[16].call
                (null, caller, names$0, context$0);
       case 2:
        var
         names$1 = malformed[1],
         a =
           caml_call2
            (Stdlib_ListLabels[20],
             function(name){return [0, 1, name];},
             names$1);
        return Sexplib0_Sexp_conv_error[19].call(null, caller, context$0, a);
       default:
        var
         maybe_context = malformed[1],
         context = caml_call2(Stdlib_Option[3], maybe_context, context$0);
        return Sexplib0_Sexp_conv_error[14].call(null, caller, context);
     }
    }
    return caml_call1(create, value);
   }
   function record_of_sexp
   (caller, fields, index_of_field, allow_extra_fields, create, sexp){
    if(0 === sexp[0])
     return Sexplib0_Sexp_conv_error[20].call(null, caller, sexp);
    var sexps = sexp[1];
    return record_of_sexps
            (caller,
             sexp,
             fields,
             index_of_field,
             allow_extra_fields,
             create,
             sexps);
   }
   var
    Sexplib0_Sexp_conv_record =
      [0, Kind, [0], record_of_sexp, record_of_sexps];
   runtime.caml_register_global
    (10, Sexplib0_Sexp_conv_record, "Sexplib0__Sexp_conv_record");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexpable
//# shape: Sexplib0__Sexpable:[]
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0_Sexpable = [0];
   runtime.caml_register_global(0, Sexplib0_Sexpable, "Sexplib0__Sexpable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0
//# shape: Sexplib0:[]
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0 = [0];
   runtime.caml_register_global(0, Sexplib0, "Sexplib0");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V4cGxpYjAuY21hLmpzIiwic2VjdGlvbnMiOlt7Im9mZnNldCI6eyJsaW5lIjo5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InNleHBsaWIwLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiXSwibmFtZXMiOlsicnVudGltZSIsIlNleHBsaWIwIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQSxhQUFBIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MjQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V4cGxpYjAuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9mYWJpYW4vLm9wYW0vZGVmYXVsdC9saWIvc2V4cGxpYjAvc2V4cC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cblxuKCogYmxpdF9zdHJpbmcgZG9lc24ndCBleGlzdCBpbiBbU3RkTGFiZWxzLkJ5dGVzXS4uLiAgKilcbmxldCBieXRlc19ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbiA9XG4gIEJ5dGVzLmJsaXRfc3RyaW5nIHNyYyBzcmNfcG9zIGRzdCBkc3RfcG9zIGxlblxuOztcblxub3BlbiBTdGRMYWJlbHNcbm9wZW4gRm9ybWF0XG5cbigqKiBUeXBlIG9mIFMtZXhwcmVzc2lvbnMgKilcbnR5cGUgdCA9XG4gIHwgQXRvbSBvZiBzdHJpbmdcbiAgfCBMaXN0IG9mIHQgbGlzdFxuXG5sZXQgc2V4cF9vZl90IHQgPSB0XG5sZXQgdF9vZl9zZXhwIHQgPSB0XG5cbmxldCByZWMgY29tcGFyZV9saXN0IGEgYiA9XG4gIG1hdGNoIGEsIGIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgeCA6OiB4cywgeSA6OiB5cyAtPlxuICAgIGxldCByZXMgPSBjb21wYXJlIHggeSBpblxuICAgIGlmIHJlcyA8PiAwIHRoZW4gcmVzIGVsc2UgY29tcGFyZV9saXN0IHhzIHlzXG5cbmFuZCBjb21wYXJlIGEgYiA9XG4gIGlmIGEgPT0gYlxuICB0aGVuIDBcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgfCBBdG9tIGEsIEF0b20gYiAtPiBTdHJpbmcuY29tcGFyZSBhIGJcbiAgICB8IEF0b20gXywgXyAtPiAtMVxuICAgIHwgXywgQXRvbSBfIC0+IDFcbiAgICB8IExpc3QgYSwgTGlzdCBiIC0+IGNvbXBhcmVfbGlzdCBhIGIpXG47O1xuXG5sZXQgcmVjIGVxdWFsIGEgYiA9XG4gIGEgPT0gYlxuICB8fFxuICBtYXRjaCBhLCBiIHdpdGhcbiAgfCBBdG9tIGEsIEF0b20gYiAtPiBTdHJpbmcuZXF1YWwgYSBiXG4gIHwgQXRvbSBfLCBfIHwgXywgQXRvbSBfIC0+IGZhbHNlXG4gIHwgTGlzdCBhLCBMaXN0IGIgLT4gTGlzdC5lcXVhbCB+ZXE6ZXF1YWwgYSBiXG47O1xuXG5leGNlcHRpb24gTm90X2ZvdW5kX3Mgb2YgdFxuZXhjZXB0aW9uIE9mX3NleHBfZXJyb3Igb2YgZXhuICogdFxuXG5tb2R1bGUgUHJpbnRpbmcgPSBzdHJ1Y3RcbiAgKCogRGVmYXVsdCBpbmRlbnRhdGlvbiBsZXZlbCBmb3IgaHVtYW4tcmVhZGFibGUgY29udmVyc2lvbnMgKilcblxuICBsZXQgZGVmYXVsdF9pbmRlbnQgPSByZWYgMVxuXG4gICgqIEVzY2FwaW5nIG9mIHN0cmluZ3MgdXNlZCBhcyBhdG9tcyBpbiBTLWV4cHJlc3Npb25zICopXG5cbiAgbGV0IG11c3RfZXNjYXBlIHN0ciA9XG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgbGVuID0gMFxuICAgIHx8XG4gICAgbGV0IHJlYyBsb29wIHN0ciBpeCA9XG4gICAgICBtYXRjaCBzdHIuW2l4XSB3aXRoXG4gICAgICB8ICdcIicgfCAnKCcgfCAnKScgfCAnOycgfCAnXFxcXCcgLT4gdHJ1ZVxuICAgICAgfCAnfCcgLT5cbiAgICAgICAgaXggPiAwXG4gICAgICAgICYmXG4gICAgICAgIGxldCBuZXh0ID0gaXggLSAxIGluXG4gICAgICAgIENoYXIuZXF1YWwgc3RyLltuZXh0XSAnIycgfHwgbG9vcCBzdHIgbmV4dFxuICAgICAgfCAnIycgLT5cbiAgICAgICAgaXggPiAwXG4gICAgICAgICYmXG4gICAgICAgIGxldCBuZXh0ID0gaXggLSAxIGluXG4gICAgICAgIENoYXIuZXF1YWwgc3RyLltuZXh0XSAnfCcgfHwgbG9vcCBzdHIgbmV4dFxuICAgICAgfCAnXFwwMDAnIC4uICdcXDAzMicgfCAnXFwxMjcnIC4uICdcXDI1NScgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGl4ID4gMCAmJiBsb29wIHN0ciAoaXggLSAxKVxuICAgIGluXG4gICAgbG9vcCBzdHIgKGxlbiAtIDEpXG4gIDs7XG5cbiAgbGV0IGVzY2FwZWQgcyA9XG4gICAgbGV0IG4gPSByZWYgMCBpblxuICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICBuXG4gICAgICAgIDo9ICFuXG4gICAgICAgICAgICtcbiAgICAgICAgICAgbWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICAgICAgfCAnXFxcIicgfCAnXFxcXCcgfCAnXFxuJyB8ICdcXHQnIHwgJ1xccicgfCAnXFxiJyAtPiAyXG4gICAgICAgICAgIHwgJyAnIC4uICd+JyAtPiAxXG4gICAgICAgICAgIHwgXyAtPiA0XG4gICAgZG9uZTtcbiAgICBpZiAhbiA9IFN0cmluZy5sZW5ndGggc1xuICAgIHRoZW4gc1xuICAgIGVsc2UgKFxuICAgICAgbGV0IHMnID0gQnl0ZXMuY3JlYXRlICFuIGluXG4gICAgICBuIDo9IDA7XG4gICAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgICAobWF0Y2ggU3RyaW5nLnVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICAgIHwgKCdcXFwiJyB8ICdcXFxcJykgYXMgYyAtPlxuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuICdcXFxcJztcbiAgICAgICAgICAgaW5jciBuO1xuICAgICAgICAgICBCeXRlcy51bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnbidcbiAgICAgICAgIHwgJ1xcdCcgLT5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAndCdcbiAgICAgICAgIHwgJ1xccicgLT5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAncidcbiAgICAgICAgIHwgJ1xcYicgLT5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnYidcbiAgICAgICAgIHwgJyAnIC4uICd+JyBhcyBjIC0+IEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gY1xuICAgICAgICAgfCBjIC0+XG4gICAgICAgICAgIGxldCBhID0gQ2hhci5jb2RlIGMgaW5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAoQ2hhci5jaHIgKDQ4ICsgKGEgLyAxMDApKSk7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAoQ2hhci5jaHIgKDQ4ICsgKGEgLyAxMCBtb2QgMTApKSk7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAoQ2hhci5jaHIgKDQ4ICsgKGEgbW9kIDEwKSkpKTtcbiAgICAgICAgaW5jciBuXG4gICAgICBkb25lO1xuICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzJylcbiAgOztcblxuICBsZXQgZXNjX3N0ciBzdHIgPVxuICAgIGxldCBlc3RyID0gZXNjYXBlZCBzdHIgaW5cbiAgICBsZXQgZWxlbiA9IFN0cmluZy5sZW5ndGggZXN0ciBpblxuICAgIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgKGVsZW4gKyAyKSBpblxuICAgIGJ5dGVzX2JsaXRfc3RyaW5nIH5zcmM6ZXN0ciB+c3JjX3BvczowIH5kc3Q6cmVzIH5kc3RfcG9zOjEgfmxlbjplbGVuO1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzIDAgJ1wiJztcbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlcyAoZWxlbiArIDEpICdcIic7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgOztcblxuICBsZXQgaW5kZXhfb2ZfbmV3bGluZSBzdHIgc3RhcnQgPSBTdHJpbmcuaW5kZXhfZnJvbV9vcHQgc3RyIHN0YXJ0ICdcXG4nXG5cbiAgbGV0IGdldF9zdWJzdHJpbmcgc3RyIGluZGV4IGVuZF9wb3Nfb3B0ID1cbiAgICBsZXQgZW5kX3BvcyA9XG4gICAgICBtYXRjaCBlbmRfcG9zX29wdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gU3RyaW5nLmxlbmd0aCBzdHJcbiAgICAgIHwgU29tZSBlbmRfcG9zIC0+IGVuZF9wb3NcbiAgICBpblxuICAgIFN0cmluZy5zdWIgc3RyIH5wb3M6aW5kZXggfmxlbjooZW5kX3BvcyAtIGluZGV4KVxuICA7O1xuXG4gIGxldCBpc19vbmVfbGluZSBzdHIgPVxuICAgIG1hdGNoIGluZGV4X29mX25ld2xpbmUgc3RyIDAgd2l0aFxuICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgfCBTb21lIGluZGV4IC0+IGluZGV4ICsgMSA9IFN0cmluZy5sZW5ndGggc3RyXG4gIDs7XG5cbiAgbGV0IHBwX2h1bV9tYXliZV9lc2Nfc3RyIHBwZiBzdHIgPVxuICAgIGlmIG5vdCAobXVzdF9lc2NhcGUgc3RyKVxuICAgIHRoZW4gcHBfcHJpbnRfc3RyaW5nIHBwZiBzdHJcbiAgICBlbHNlIGlmIGlzX29uZV9saW5lIHN0clxuICAgIHRoZW4gcHBfcHJpbnRfc3RyaW5nIHBwZiAoZXNjX3N0ciBzdHIpXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcmVjIGxvb3AgaW5kZXggPVxuICAgICAgICBsZXQgbmV4dF9uZXdsaW5lID0gaW5kZXhfb2ZfbmV3bGluZSBzdHIgaW5kZXggaW5cbiAgICAgICAgbGV0IG5leHRfbGluZSA9IGdldF9zdWJzdHJpbmcgc3RyIGluZGV4IG5leHRfbmV3bGluZSBpblxuICAgICAgICBwcF9wcmludF9zdHJpbmcgcHBmIChlc2NhcGVkIG5leHRfbGluZSk7XG4gICAgICAgIG1hdGNoIG5leHRfbmV3bGluZSB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICB8IFNvbWUgbmV3bGluZV9pbmRleCAtPlxuICAgICAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCJcXFxcXCI7XG4gICAgICAgICAgcHBfZm9yY2VfbmV3bGluZSBwcGYgKCk7XG4gICAgICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIlxcXFxuXCI7XG4gICAgICAgICAgbG9vcCAobmV3bGluZV9pbmRleCArIDEpXG4gICAgICBpblxuICAgICAgcHBfb3Blbl9ib3ggcHBmIDA7XG4gICAgICAoKiB0aGUgbGVhZGluZyBzcGFjZSBpcyB0byBsaW5lIHVwIHRoZSBsaW5lcyAqKVxuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIiBcXFwiXCI7XG4gICAgICBsb29wIDA7XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiXFxcIlwiO1xuICAgICAgcHBfY2xvc2VfYm94IHBwZiAoKSlcbiAgOztcblxuICBsZXQgbWFjaF9tYXliZV9lc2Nfc3RyIHN0ciA9IGlmIG11c3RfZXNjYXBlIHN0ciB0aGVuIGVzY19zdHIgc3RyIGVsc2Ugc3RyXG5cbiAgKCogT3V0cHV0IG9mIFMtZXhwcmVzc2lvbnMgdG8gZm9ybWF0dGVycyAqKVxuXG4gIGxldCByZWMgcHBfaHVtX2luZGVudCBpbmRlbnQgcHBmID0gZnVuY3Rpb25cbiAgICB8IEF0b20gc3RyIC0+IHBwX2h1bV9tYXliZV9lc2Nfc3RyIHBwZiBzdHJcbiAgICB8IExpc3QgKGggOjogdCkgLT5cbiAgICAgIHBwX29wZW5fYm94IHBwZiBpbmRlbnQ7XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiKFwiO1xuICAgICAgcHBfaHVtX2luZGVudCBpbmRlbnQgcHBmIGg7XG4gICAgICBwcF9odW1fcmVzdCBpbmRlbnQgcHBmIHRcbiAgICB8IExpc3QgW10gLT4gcHBfcHJpbnRfc3RyaW5nIHBwZiBcIigpXCJcblxuICBhbmQgcHBfaHVtX3Jlc3QgaW5kZW50IHBwZiA9IGZ1bmN0aW9uXG4gICAgfCBoIDo6IHQgLT5cbiAgICAgIHBwX3ByaW50X3NwYWNlIHBwZiAoKTtcbiAgICAgIHBwX2h1bV9pbmRlbnQgaW5kZW50IHBwZiBoO1xuICAgICAgcHBfaHVtX3Jlc3QgaW5kZW50IHBwZiB0XG4gICAgfCBbXSAtPlxuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIilcIjtcbiAgICAgIHBwX2Nsb3NlX2JveCBwcGYgKClcbiAgOztcblxuICBsZXQgcmVjIHBwX21hY2hfaW50ZXJuYWwgbWF5X25lZWRfc3BhY2UgcHBmID0gZnVuY3Rpb25cbiAgICB8IEF0b20gc3RyIC0+XG4gICAgICBsZXQgc3RyJyA9IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHIgaW5cbiAgICAgIGxldCBuZXdfbWF5X25lZWRfc3BhY2UgPSBzdHInID09IHN0ciBpblxuICAgICAgaWYgbWF5X25lZWRfc3BhY2UgJiYgbmV3X21heV9uZWVkX3NwYWNlIHRoZW4gcHBfcHJpbnRfc3RyaW5nIHBwZiBcIiBcIjtcbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgc3RyJztcbiAgICAgIG5ld19tYXlfbmVlZF9zcGFjZVxuICAgIHwgTGlzdCAoaCA6OiB0KSAtPlxuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIihcIjtcbiAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IHBwX21hY2hfaW50ZXJuYWwgZmFsc2UgcHBmIGggaW5cbiAgICAgIHBwX21hY2hfcmVzdCBtYXlfbmVlZF9zcGFjZSBwcGYgdDtcbiAgICAgIGZhbHNlXG4gICAgfCBMaXN0IFtdIC0+XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiKClcIjtcbiAgICAgIGZhbHNlXG5cbiAgYW5kIHBwX21hY2hfcmVzdCBtYXlfbmVlZF9zcGFjZSBwcGYgPSBmdW5jdGlvblxuICAgIHwgaCA6OiB0IC0+XG4gICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBwcF9tYWNoX2ludGVybmFsIG1heV9uZWVkX3NwYWNlIHBwZiBoIGluXG4gICAgICBwcF9tYWNoX3Jlc3QgbWF5X25lZWRfc3BhY2UgcHBmIHRcbiAgICB8IFtdIC0+IHBwX3ByaW50X3N0cmluZyBwcGYgXCIpXCJcbiAgOztcblxuICBsZXQgcHBfaHVtIHBwZiBzZXhwID0gcHBfaHVtX2luZGVudCAhZGVmYXVsdF9pbmRlbnQgcHBmIHNleHBcbiAgbGV0IHBwX21hY2ggcHBmIHNleHAgPSBpZ25vcmUgKHBwX21hY2hfaW50ZXJuYWwgZmFsc2UgcHBmIHNleHApXG4gIGxldCBwcCA9IHBwX21hY2hcblxuICAoKiBTZXhwIHNpemUgKilcblxuICBsZXQgcmVjIHNpemVfbG9vcCAoKHYsIGMpIGFzIGFjYykgPSBmdW5jdGlvblxuICAgIHwgQXRvbSBzdHIgLT4gdiArIDEsIGMgKyBTdHJpbmcubGVuZ3RoIHN0clxuICAgIHwgTGlzdCBsc3QgLT4gTGlzdC5mb2xkX2xlZnQgbHN0IH5pbml0OmFjYyB+ZjpzaXplX2xvb3BcbiAgOztcblxuICBsZXQgc2l6ZSBzZXhwID0gc2l6ZV9sb29wICgwLCAwKSBzZXhwXG5cbiAgKCogQnVmZmVyIGNvbnZlcnNpb25zICopXG5cbiAgbGV0IHRvX2J1ZmZlcl9odW0gfmJ1ZiA/KGluZGVudCA9ICFkZWZhdWx0X2luZGVudCkgc2V4cCA9XG4gICAgbGV0IHBwZiA9IEZvcm1hdC5mb3JtYXR0ZXJfb2ZfYnVmZmVyIGJ1ZiBpblxuICAgIEZvcm1hdC5mcHJpbnRmIHBwZiBcIiVhQD9cIiAocHBfaHVtX2luZGVudCBpbmRlbnQpIHNleHBcbiAgOztcblxuICBsZXQgdG9fYnVmZmVyX21hY2ggfmJ1ZiBzZXhwID1cbiAgICBsZXQgcmVjIGxvb3AgbWF5X25lZWRfc3BhY2UgPSBmdW5jdGlvblxuICAgICAgfCBBdG9tIHN0ciAtPlxuICAgICAgICBsZXQgc3RyJyA9IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHIgaW5cbiAgICAgICAgbGV0IG5ld19tYXlfbmVlZF9zcGFjZSA9IHN0cicgPT0gc3RyIGluXG4gICAgICAgIGlmIG1heV9uZWVkX3NwYWNlICYmIG5ld19tYXlfbmVlZF9zcGFjZSB0aGVuIEJ1ZmZlci5hZGRfY2hhciBidWYgJyAnO1xuICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgc3RyJztcbiAgICAgICAgbmV3X21heV9uZWVkX3NwYWNlXG4gICAgICB8IExpc3QgKGggOjogdCkgLT5cbiAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnKCc7XG4gICAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IGxvb3AgZmFsc2UgaCBpblxuICAgICAgICBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgdDtcbiAgICAgICAgZmFsc2VcbiAgICAgIHwgTGlzdCBbXSAtPlxuICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgXCIoKVwiO1xuICAgICAgICBmYWxzZVxuICAgIGFuZCBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgPSBmdW5jdGlvblxuICAgICAgfCBoIDo6IHQgLT5cbiAgICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gbG9vcCBtYXlfbmVlZF9zcGFjZSBoIGluXG4gICAgICAgIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSB0XG4gICAgICB8IFtdIC0+IEJ1ZmZlci5hZGRfY2hhciBidWYgJyknXG4gICAgaW5cbiAgICBpZ25vcmUgKGxvb3AgZmFsc2Ugc2V4cClcbiAgOztcblxuICBsZXQgdG9fYnVmZmVyID0gdG9fYnVmZmVyX21hY2hcblxuICBsZXQgdG9fYnVmZmVyX2dlbiB+YnVmIH5hZGRfY2hhciB+YWRkX3N0cmluZyBzZXhwID1cbiAgICBsZXQgcmVjIGxvb3AgbWF5X25lZWRfc3BhY2UgPSBmdW5jdGlvblxuICAgICAgfCBBdG9tIHN0ciAtPlxuICAgICAgICBsZXQgc3RyJyA9IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHIgaW5cbiAgICAgICAgbGV0IG5ld19tYXlfbmVlZF9zcGFjZSA9IHN0cicgPT0gc3RyIGluXG4gICAgICAgIGlmIG1heV9uZWVkX3NwYWNlICYmIG5ld19tYXlfbmVlZF9zcGFjZSB0aGVuIGFkZF9jaGFyIGJ1ZiAnICc7XG4gICAgICAgIGFkZF9zdHJpbmcgYnVmIHN0cic7XG4gICAgICAgIG5ld19tYXlfbmVlZF9zcGFjZVxuICAgICAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgICAgIGFkZF9jaGFyIGJ1ZiAnKCc7XG4gICAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IGxvb3AgZmFsc2UgaCBpblxuICAgICAgICBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgdDtcbiAgICAgICAgZmFsc2VcbiAgICAgIHwgTGlzdCBbXSAtPlxuICAgICAgICBhZGRfc3RyaW5nIGJ1ZiBcIigpXCI7XG4gICAgICAgIGZhbHNlXG4gICAgYW5kIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSA9IGZ1bmN0aW9uXG4gICAgICB8IGggOjogdCAtPlxuICAgICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBsb29wIG1heV9uZWVkX3NwYWNlIGggaW5cbiAgICAgICAgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlIHRcbiAgICAgIHwgW10gLT4gYWRkX2NoYXIgYnVmICcpJ1xuICAgIGluXG4gICAgaWdub3JlIChsb29wIGZhbHNlIHNleHApXG4gIDs7XG5cbiAgKCogVGhlIG1heGltdW0gc2l6ZSBvZiBhIHRoaW5nIG9uIHRoZSBtaW5vciBoZWFwIGlzIDI1NiB3b3Jkcy5cbiAgICAgUHJldmlvdXNseSwgdGhpcyBzaXplIG9mIHRoZSByZXR1cm5lZCBidWZmZXIgaGVyZSB3YXMgNDA5NiBieXRlcywgd2hpY2hcbiAgICAgY2F1c2VkIHRoZSBCdWZmZXIgdG8gYmUgYWxsb2NhdGVkIG9uIHRoZSAqbWFqb3IqIGhlYXAgZXZlcnkgdGltZS5cblxuICAgICBBY2NvcmRpbmcgdG8gYSBzaW1wbGUgYmVuY2htYXJrIGJ5IFJvbiwgd2UgY2FuIGltcHJvdmUgcGVyZm9ybWFuY2UgZm9yXG4gICAgIHNtYWxsIHMtZXhwcmVzc2lvbnMgYnkgYSBmYWN0b3Igb2YgfjQgaWYgd2Ugb25seSBhbGxvY2F0ZSAxMDI0IGJ5dGVzXG4gICAgICgxMjggd29yZHMgKyBzb21lIHNtYWxsIG92ZXJoZWFkKSB3b3J0aCBvZiBidWZmZXIgaW5pdGlhbGx5LiAgQW5kIG9uZVxuICAgICBjYW4gYXJndWUgdGhhdCBpZiBpdCdzIGZyZWUgdG8gYWxsb2NhdGUgc3RyaW5ncyBzbWFsbGVyIHRoYW4gMjU2IHdvcmRzLFxuICAgICBsYXJnZSBzLWV4cHJlc3Npb25zIHJlcXVpcmluZyBsYXJnZXIgZXhwZW5zaXZlIGJ1ZmZlcnMgd29uJ3Qgbm90aWNlXG4gICAgIHRoZSBleHRyYSB0d28gZG91YmxpbmdzIGZyb20gMTAyNCBieXRlcyB0byAyMDQ4IGFuZCA0MDk2LiBBbmQgZXNwZWNpYWxseVxuICAgICBwZXJmb3JtYW5jZS1zZW5zaXRpdmUgYXBwbGljYXRpb25zIHRvIGFsd2F5cyBwYXNzIGluIGEgbGFyZ2VyIGJ1ZmZlciB0b1xuICAgICB1c2UuICopXG4gIGxldCBidWZmZXIgKCkgPSBCdWZmZXIuY3JlYXRlIDEwMjRcblxuICAoKiBTdHJpbmcgY29udmVyc2lvbnMgKilcblxuICBsZXQgdG9fc3RyaW5nX2h1bSA/aW5kZW50ID0gZnVuY3Rpb25cbiAgICB8IEF0b20gc3RyXG4gICAgICB3aGVuIG1hdGNoIGluZGV4X29mX25ld2xpbmUgc3RyIDAgd2l0aFxuICAgICAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgICAgICB8IFNvbWUgXyAtPiBmYWxzZSAtPiBtYWNoX21heWJlX2VzY19zdHIgc3RyXG4gICAgfCBzZXhwIC0+XG4gICAgICBsZXQgYnVmID0gYnVmZmVyICgpIGluXG4gICAgICB0b19idWZmZXJfaHVtID9pbmRlbnQgc2V4cCB+YnVmO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICA7O1xuXG4gIGxldCB0b19zdHJpbmdfbWFjaCA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0ciAtPiBtYWNoX21heWJlX2VzY19zdHIgc3RyXG4gICAgfCBzZXhwIC0+XG4gICAgICBsZXQgYnVmID0gYnVmZmVyICgpIGluXG4gICAgICB0b19idWZmZXJfbWFjaCBzZXhwIH5idWY7XG4gICAgICBCdWZmZXIuY29udGVudHMgYnVmXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ19tYWNoXG5lbmRcblxuaW5jbHVkZSBQcmludGluZ1xuXG5sZXQgb2ZfZmxvYXRfc3R5bGUgOiBbIGBVbmRlcnNjb3JlcyB8IGBOb191bmRlcnNjb3JlcyBdIHJlZiA9IHJlZiBgTm9fdW5kZXJzY29yZXNcbmxldCBvZl9pbnRfc3R5bGUgOiBbIGBVbmRlcnNjb3JlcyB8IGBOb191bmRlcnNjb3JlcyBdIHJlZiA9IHJlZiBgTm9fdW5kZXJzY29yZXNcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmludGluZ1xuZW5kXG5cbmxldCBtZXNzYWdlIG5hbWUgZmllbGRzID1cbiAgbGV0IHJlYyBjb252X2ZpZWxkcyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgKGZuYW1lLCBmc2V4cCkgOjogcmVzdCAtPlxuICAgICAgKG1hdGNoIGZuYW1lIHdpdGhcbiAgICAgICB8IFwiXCIgLT4gZnNleHAgOjogY29udl9maWVsZHMgcmVzdFxuICAgICAgIHwgXyAtPiBMaXN0IFsgQXRvbSBmbmFtZTsgZnNleHAgXSA6OiBjb252X2ZpZWxkcyByZXN0KVxuICBpblxuICBMaXN0IChBdG9tIG5hbWUgOjogY29udl9maWVsZHMgZmllbGRzKVxuOztcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY2FtbF9ieXRlc191bnNhZmVfc2V0IiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfZ2V0IiwiY2FtbF9zdHJpbmdfdW5zYWZlX2dldCIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJnbG9iYWxfZGF0YSIsIlN0ZGxpYl9TdHJpbmdMYWJlbHMiLCJTdGRsaWJfTGlzdExhYmVscyIsIlN0ZGxpYl9Gb3JtYXQiLCJTdGRsaWJfQnVmZmVyIiwiU3RkbGliX0J5dGVzTGFiZWxzIiwiU3RkbGliX0NoYXIiLCJTdGRsaWJfQnl0ZXMiLCJzZXhwX29mX3QiLCJ0IiwidF9vZl9zZXhwIiwiY29tcGFyZSIsImEiLCJiIiwieXMiLCJ5IiwieHMiLCJ4IiwicmVzIiwiZXF1YWwiLCJOb3RfZm91bmRfcyIsIk9mX3NleHBfZXJyb3IiLCJkZWZhdWx0X2luZGVudCIsImNzdF9uIiwibXVzdF9lc2NhcGUiLCJzdHIiLCJsZW4iLCJpeCIsIm1hdGNoIiwic3dpdGNoZXIiLCJuZXh0IiwiZXNjYXBlZCIsInMiLCJuIiwiaSIsImMiLCJlc2Nfc3RyIiwiZXN0ciIsImVsZW4iLCJpbmRleF9vZl9uZXdsaW5lIiwic3RhcnQiLCJtYWNoX21heWJlX2VzY19zdHIiLCJwcF9odW1faW5kZW50IiwiaW5kZW50IiwicHBmIiwicGFyYW0iLCJpbmRleCIsIm5leHRfbmV3bGluZSIsImVuZF9wb3MiLCJuZXh0X2xpbmUiLCJuZXdsaW5lX2luZGV4IiwiaCIsInBwX21hY2hfaW50ZXJuYWwiLCJtYXlfbmVlZF9zcGFjZSIsIm5ld19tYXlfbmVlZF9zcGFjZSIsInBwX2h1bSIsInNleHAiLCJwcF9tYWNoIiwic2l6ZV9sb29wIiwiYWNjIiwidiIsImxzdCIsInNpemUiLCJ0b19idWZmZXJfaHVtIiwiYnVmIiwib3B0IiwidG9fYnVmZmVyX21hY2giLCJsb29wIiwidG9fYnVmZmVyX2dlbiIsImFkZF9jaGFyIiwiYWRkX3N0cmluZyIsImJ1ZmZlciIsInRvX3N0cmluZ19odW0iLCJ0b19zdHJpbmdfbWFjaCIsIm9mX2Zsb2F0X3N0eWxlIiwib2ZfaW50X3N0eWxlIiwibWVzc2FnZSIsIm5hbWUiLCJmaWVsZHMiLCJjb252X2ZpZWxkcyIsInJlc3QiLCJmc2V4cCIsImZuYW1lIiwiU2V4cGxpYjBfU2V4cCJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMseUJBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJ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QUFBLFNBQ0wsOEJBSU87QUFBQSxRQUFBdUMsTUFGVDtBQUFBLElBQ1Y7QUFBQSxJQUF3Qix3Q0FDTDtBQUFBO0FBQUEsT0FBQVUsaUJEaFZ6QixpQkFBQUMsZUFBQTtBQUFBLFlBQUFDLFFBQUFDLE1BQUFDO0FBQUFBLGFBQUFDLFlBQUFsQztBQUFBQSxLQ2dXd0IsWUFDWjtBQUFBO0FBQUEsTUFBQW1DLE9BRFk7QUFBQSxNQUFBcEQsUUFBQTtBQUFBLE1BQUFxRCxRQUFBO0FBQUEsTUFBQUMsUUFBQTtBQUFBLEtBR2xCO0FBQUEsd0RBRXNDO0FBQUEsMEJBRHBCLGtCQUNxQztBQUFBO0FBQUEsSUFFeEMsK0NBQWtCO0FBQUEsR0FBQztBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUR2V3hDIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NTgwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InNleHBsaWIwLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZmFiaWFuLy5vcGFtL2RlZmF1bHQvbGliL3NleHBsaWIwL3NleHBfZ3JhbW1hci5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIigqKiBSZXByZXNlbnRhdGlvbiBvZiBTLWV4cHJlc3Npb24gZ3JhbW1hcnMgKilcblxuKCoqIFRoaXMgbW9kdWxlIGRlZmluZXMgYSByZXByZXNlbnRhdGlvbiBmb3Igcy1leHByZXNzaW9uIGdyYW1tYXJzLiBVc2luZyBwcHhfc2V4cF9jb252XG4gICAgYW5kIFtbQEBkZXJpdmluZyBzZXhwX2dyYW1tYXJdXSBwcm9kdWNlcyBhIGdyYW1tYXIgdGhhdCBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGRlcml2ZWRcbiAgICBbb2Zfc2V4cF0gZm9yIGEgZ2l2ZW4gdHlwZS5cblxuICAgIEFzIHdpdGggb3RoZXIgZGVyaXZlZCBkZWZpbml0aW9ucywgcG9seW1vcnBoaWMgdHlwZXMgZGVyaXZlIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhXG4gICAgZ3JhbW1hciBmb3IgZWFjaCB0eXBlIGFyZ3VtZW50IGFuZCBwcm9kdWNlcyBhIGdyYW1tYXIgZm9yIHRoZSBtb25vbW9ycGhpemVkIHR5cGUuXG5cbiAgICBNb25vbW9ycGhpYyB0eXBlcyBkZXJpdmUgYSBncmFtbWFyIGRpcmVjdGx5LiBUbyBhdm9pZCB0b3AtbGV2ZWwgc2lkZSBlZmZlY3RzLFxuICAgIFtbQEBkZXJpdmluZyBzZXhwX2dyYW1tYXJdXSB3cmFwcyBncmFtbWFycyBpbiB0aGUgW0xhenldIGNvbnN0cnVjdG9yIGFzIG5lZWRlZC5cblxuICAgIFRoaXMgdHlwZSBtYXkgY2hhbmdlIG92ZXIgdGltZSBhcyBvdXIgbmVlZHMgZm9yIGV4cHJlc3NpdmUgZ3JhbW1hcnMgY2hhbmdlLiBXZSB3aWxsXG4gICAgYXR0ZW1wdCB0byBtYWtlIGNoYW5nZXMgYmFja3dhcmQtY29tcGF0aWJsZSwgb3IgYXQgbGVhc3QgcHJvdmlkZSBhIHJlYXNvbmFibGUgdXBncmFkZVxuICAgIHBhdGguICopXG5cbltAQEB3YXJuaW5nIFwiLTMwXCJdICgqIGFsbG93IGR1cGxpY2F0ZSBmaWVsZCBuYW1lcyAqKVxuXG4oKiogR3JhbW1hciBvZiBhIHNleHAuICopXG50eXBlIGdyYW1tYXIgPVxuICB8IEFueSBvZiBzdHJpbmcgKCoqIGFjY2VwdHMgYW55IHNleHA7IHN0cmluZyBpcyBhIHR5cGUgbmFtZSBmb3IgaHVtYW4gcmVhZGFiaWxpdHkgKilcbiAgfCBCb29sICgqKiBhY2NlcHRzIHRoZSBhdG9tcyBcInRydWVcIiBvciBcImZhbHNlXCIsIG1vZHVsbyBjYXBpdGFsaXphdGlvbiAqKVxuICB8IENoYXIgKCoqIGFjY2VwdHMgYW55IHNpbmdsZS1jaGFyYWN0ZXIgYXRvbSAqKVxuICB8IEludGVnZXIgKCoqIGFjY2VwdHMgYW55IGF0b20gbWF0Y2hpbmcgb2NhbWwgaW50ZWdlciBzeW50YXgsIHJlZ2FyZGxlc3Mgb2YgYml0IHdpZHRoICopXG4gIHwgRmxvYXQgKCoqIGFjY2VwdHMgYW55IGF0b20gbWF0Y2hpbmcgb2NhbWwgZmxvYXQgc3ludGF4ICopXG4gIHwgU3RyaW5nICgqKiBhY2NlcHRzIGFueSBhdG9tICopXG4gIHwgT3B0aW9uIG9mIGdyYW1tYXIgKCoqIGFjY2VwdHMgYW4gb3B0aW9uLCBib3RoIFtOb25lXSB2cyBbU29tZSBfXSBhbmQgWygpXSB2cyBbKF8pXS4gKilcbiAgfCBMaXN0IG9mIGxpc3RfZ3JhbW1hciAoKiogYWNjZXB0cyBhIGxpc3QgKilcbiAgfCBWYXJpYW50IG9mIHZhcmlhbnQgKCoqIGFjY2VwdHMgY2xhdXNlcyBrZXllZCBieSBhIGxlYWRpbmcgb3Igc29sZSBhdG9tICopXG4gIHwgVW5pb24gb2YgZ3JhbW1hciBsaXN0ICgqKiBhY2NlcHRzIGEgc2V4cCBpZiBhbnkgb2YgdGhlIGxpc3RlZCBncmFtbWFycyBhY2NlcHRzIGl0ICopXG4gIHwgVGFnZ2VkIG9mIGdyYW1tYXIgd2l0aF90YWdcbiAgICAgICgqKiBhbm5vdGF0ZXMgYSBncmFtbWFyIHdpdGggYSBjbGllbnQtc3BlY2lmaWMga2V5L3ZhbHVlIHBhaXIgKilcbiAgfCBUeXZhciBvZiBzdHJpbmdcbiAgICAgICgqKiBOYW1lIG9mIGEgdHlwZSB2YXJpYWJsZSwgZS5nLiBbVHl2YXIgXCJhXCJdIGZvciBbJ2FdLiBPbmx5IG1lYW5pbmdmdWwgd2hlbiB0aGUgYm9keSBvZlxuICAgICAgdGhlIGlubmVybW9zdCBlbmNsb3NpbmcgW2RlZm5dIGRlZmluZXMgYSBjb3JyZXNwb25kaW5nIHR5cGUgdmFyaWFibGUuICopXG4gIHwgVHljb24gb2Ygc3RyaW5nICogZ3JhbW1hciBsaXN0ICogZGVmbiBsaXN0XG4gICAgICAoKiogVHlwZSBjb25zdHJ1Y3RvciBhcHBsaWVkIHRvIGFyZ3VtZW50cywgYW5kIGl0cyBkZWZpbml0aW9uLlxuXG4gICAgICBGb3IgZXhhbXBsZSwgd3JpdGluZyBbVHljb24gKFwidHJlZVwiLCBbIEludGVnZXIgXSwgZGVmbnMpXSByZXByZXNlbnRzIFtpbnQgdHJlZV0sIGZvclxuICAgICAgd2hhdGV2ZXIgW3RyZWVdIGlzIGRlZmluZWQgYXMgaW4gW2RlZm5zXS4gVGhlIGZvbGxvd2luZyBkZWZpbmVzIFt0cmVlXSBhcyBhIGJpbmFyeVxuICAgICAgdHJlZSB3aXRoIHRoZSBwYXJhbWV0ZXIgdHlwZSBzdG9yZWQgYXQgdGhlIGxlYXZlcy5cblxuICAgICAge1tcbiAgICAgICAgbGV0IGRlZm5zID1cbiAgICAgICAgICBbIHsgdHljb24gPSBcInRyZWVcIlxuICAgICAgICAgICAgOyB0eXZhcnMgPSBbXCJhXCJdXG4gICAgICAgICAgICA7IGdyYW1tYXIgPVxuICAgICAgICAgICAgICAgIFZhcmlhbnRcbiAgICAgICAgICAgICAgICAgIHsgbmFtZV9raW5kID0gQ2FwaXRhbGl6ZWRcbiAgICAgICAgICAgICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgWyB7IG5hbWUgPSBcIk5vZGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOyBhcmdzID0gQ29ucyAoUmVjdXJzaXZlIChcIm5vZGVcIiwgW1R5dmFyIFwiYVwiXSksIEVtcHR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIDsgeyBuYW1lID0gXCJMZWFmXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDsgYXJncyA9IENvbnMgKFJlY3Vyc2l2ZSAoXCJsZWFmXCIsIFtUeXZhciBcImFcIl0pLCBFbXB0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgOyB7IHR5Y29uID0gXCJub2RlXCJcbiAgICAgICAgICAgIDsgdHl2YXJzID0gW1wiYVwiXVxuICAgICAgICAgICAgOyBncmFtbWFyID0gTGlzdCAoTWFueSAoUmVjdXJzaXZlIFwidHJlZVwiLCBbVHl2YXIgXCJhXCJdKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA7IHsgdHljb24gPSBcImxlYWZcIlxuICAgICAgICAgICAgOyB0eXZhcnMgPSBbXCJhXCJdXG4gICAgICAgICAgICA7IGdyYW1tYXIgPSBbVHl2YXIgXCJhXCJdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICA7O1xuICAgICAgXX1cblxuICAgICAgVG8gaWxsdXN0cmF0ZSB0aGUgbWVhbmluZyBvZiBbVHljb25dIHdpdGggcmVzcGVjdCB0byBbZGVmbnNdLCBhbmQgdG8gZGVtb25zdHJhdGUgb25lXG4gICAgICB3YXkgdG8gYWNjZXNzIHRoZW0sIGl0IGlzIGVxdWl2YWxlbnQgdG8gZXhwYW5kIHRoZSBkZWZpbml0aW9uIG9mIFwidHJlZVwiIG9uZSBsZXZlbFxuICAgICAgYW5kIG1vdmUgdGhlIFtkZWZuc10gdG8gZW5jbG9zZWQgcmVjdXJzaXZlIHJlZmVyZW5jZXM6XG5cbiAgICAgIHtbXG4gICAgICAgIFR5Y29uIChcInRyZWVcIiwgWyBJbnRlZ2VyIF0sIGRlZm5zKVxuICAgICAgICAtLT5cbiAgICAgICAgVmFyaWFudFxuICAgICAgICAgIHsgbmFtZV9raW5kID0gQ2FwaXRhbGl6ZWRcbiAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICBbIHsgbmFtZSA9IFwiTm9kZVwiXG4gICAgICAgICAgICAgICAgOyBhcmdzID0gQ29ucyAoVHljb24gKFwibm9kZVwiLCBbVHl2YXIgXCJhXCJdLCBkZWZucyksIEVtcHR5KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgOyB7IG5hbWUgPSBcIkxlYWZcIlxuICAgICAgICAgICAgICAgIDsgYXJncyA9IENvbnMgKFR5Y29uIChcImxlYWZcIiwgW1R5dmFyIFwiYVwiXSwgZGVmbnMpLCBFbXB0eSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICBdfVxuXG4gICAgICBUaGlzIHRyYW5zZm9ybWF0aW9uIGV4cG9zZXMgdGhlIHN0cnVjdHVyZSBvZiBhIGdyYW1tYXIgd2l0aCByZWN1cnNpdmUgcmVmZXJlbmNlcyxcbiAgICAgIHdoaWxlIHByZXNlcnZpbmcgdGhlIG1lYW5pbmcgb2YgcmVjdXJzaXZlbHktZGVmaW5lZCBlbGVtZW50cy4gKilcbiAgfCBSZWN1cnNpdmUgb2Ygc3RyaW5nICogZ3JhbW1hciBsaXN0XG4gICAgICAoKiogVHlwZSBjb25zdHJ1Y3RvciBhcHBsaWVkIHRvIGFyZ3VtZW50cy4gVXNlZCB0byBkZW5vdGUgcmVjdXJzaXZlIHR5cGUgcmVmZXJlbmNlcy5cbiAgICAgIE9ubHkgbWVhbmluZ2Z1bCB3aGVuIHVzZWQgaW5zaWRlIHRoZSBbZGVmbl1zIG9mIGEgW1R5Y29uXSBncmFtbWFyLCB0byByZWZlciB0byBhXG4gICAgICB0eXBlIGNvbnN0cnVjdG9yIGluIHRoZSBuZWFyZXN0IGVuY2xvc2luZyBbZGVmbl0gbGlzdC4gKilcbiAgfCBMYXp5IG9mIGdyYW1tYXIgbGF6eV90XG4gICAgICAoKiogTGF6aWx5IGNvbXB1dGVkIGdyYW1tYXIuIFVzZSBbTGF6eV0gdG8gYXZvaWQgdG9wLWxldmVsIHNpZGUgZWZmZWN0cy4gVG8gZGVmaW5lXG4gICAgICByZWN1cnNpdmUgZ3JhbW1hcnMsIHVzZSBbUmVjdXJzaXZlXSBpbnN0ZWFkLiAqKVxuXG4oKiogR3JhbW1hciBvZiBhIGxpc3Qgb2Ygc2V4cHMuICopXG5hbmQgbGlzdF9ncmFtbWFyID1cbiAgfCBFbXB0eSAoKiogYWNjZXB0cyBhbiBlbXB0eSBsaXN0IG9mIHNleHBzICopXG4gIHwgQ29ucyBvZiBncmFtbWFyICogbGlzdF9ncmFtbWFyXG4gICAgICAoKiogYWNjZXB0cyBhIG5vbi1lbXB0eSBsaXN0IHdpdGggaGVhZCBhbmQgdGFpbCBtYXRjaGluZyB0aGUgZ2l2ZW4gZ3JhbW1hcnMgKilcbiAgfCBNYW55IG9mIGdyYW1tYXIgKCoqIGFjY2VwdHMgemVybyBvciBtb3JlIHNleHBzLCBlYWNoIG1hdGNoaW5nIHRoZSBnaXZlbiBncmFtbWFyICopXG4gIHwgRmllbGRzIG9mIHJlY29yZCAoKiogYWNjZXB0cyBzZXhwcyByZXByZXNlbnRpbmcgZmllbGRzIG9mIGEgcmVjb3JkICopXG5cbigqKiBDYXNlIHNlbnNpdGl2aXR5IG9wdGlvbnMgZm9yIG5hbWVzIG9mIHZhcmlhbnQgY29uc3RydWN0b3JzLiAqKVxuYW5kIGNhc2Vfc2Vuc2l0aXZpdHkgPVxuICB8IENhc2VfaW5zZW5zaXRpdmUgKCoqIENvbXBhcmlzb24gaXMgY2FzZSBpbnNlbnNpdGl2ZS4gVXNlZCBmb3IgY3VzdG9tIHBhcnNlcnMuICopXG4gIHwgQ2FzZV9zZW5zaXRpdmUgKCoqIENvbXBhcmlzb24gaXMgY2FzZSBzZW5zaXRpdmUuIFVzZWQgZm9yIHBvbHltb3JwaGljIHZhcmlhbnRzLiAqKVxuICB8IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICgqKiBDb21wYXJpc29uIGlzIGNhc2UgaW5zZW5zaXRpdmUgZm9yIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGNhc2Ugc2Vuc2l0aXZlIGFmdGVyd2FyZC5cbiAgICAgIFVzZWQgZm9yIHJlZ3VsYXIgdmFyaWFudHMuICopXG5cbigqKiBHcmFtbWFyIG9mIHZhcmlhbnRzLiBBY2NlcHRzIGFueSBzZXhwIG1hdGNoaW5nIG9uZSBvZiB0aGUgY2xhdXNlcy4gKilcbmFuZCB2YXJpYW50ID1cbiAgeyBjYXNlX3NlbnNpdGl2aXR5IDogY2FzZV9zZW5zaXRpdml0eVxuICA7IGNsYXVzZXMgOiBjbGF1c2Ugd2l0aF90YWdfbGlzdCBsaXN0XG4gIH1cblxuKCoqIEdyYW1tYXIgb2YgYSBzaW5nbGUgdmFyaWFudCBjbGF1c2UuIEFjY2VwdHMgc2V4cHMgYmFzZWQgb24gdGhlIFtjbGF1c2Vfa2luZF0uICopXG5hbmQgY2xhdXNlID1cbiAgeyBuYW1lIDogc3RyaW5nXG4gIDsgY2xhdXNlX2tpbmQgOiBjbGF1c2Vfa2luZFxuICB9XG5cbigqKiBHcmFtbWFyIG9mIGEgc2luZ2xlIHZhcmlhbnQgY2xhdXNlJ3MgY29udGVudHMuIFtBdG9tX2NsYXVzZV0gYWNjZXB0cyBhbiBhdG9tIG1hdGNoaW5nXG4gICAgdGhlIGNsYXVzZSdzIG5hbWUuIFtMaXN0X2NsYXVzZV0gYWNjZXB0cyBhIGxpc3Qgd2hvc2UgaGVhZCBpcyBhbiBhdG9tIG1hdGNoaW5nIHRoZVxuICAgIGNsYXVzZSdzIG5hbWUgYW5kIHdob3NlIHRhaWwgbWF0Y2hlcyBbYXJnc10uIFRoZSBjbGF1c2UncyBuYW1lIGlzIG1hdGNoZWQgbW9kdWxvIHRoZVxuICAgIHZhcmlhbnQncyBbbmFtZV9raW5kXS4gKilcbmFuZCBjbGF1c2Vfa2luZCA9XG4gIHwgQXRvbV9jbGF1c2VcbiAgfCBMaXN0X2NsYXVzZSBvZiB7IGFyZ3MgOiBsaXN0X2dyYW1tYXIgfVxuXG4oKiogR3JhbW1hciBvZiBhIHJlY29yZC4gQWNjZXB0cyBhbnkgbGlzdCBvZiBzZXhwcyBzcGVjaWZ5aW5nIGVhY2ggb2YgdGhlIGZpZWxkcyxcbiAgICByZWdhcmRsZXNzIG9mIG9yZGVyLiBJZiBbYWxsb3dfZXh0cmFfZmllbGRzXSBpcyBzcGVjaWZpZWQsIGlnbm9yZXMgc2V4cHMgd2l0aCBuYW1lc1xuICAgIG5vdCBmb3VuZCBpbiBbZmllbGRzXS4gKilcbmFuZCByZWNvcmQgPVxuICB7IGFsbG93X2V4dHJhX2ZpZWxkcyA6IGJvb2xcbiAgOyBmaWVsZHMgOiBmaWVsZCB3aXRoX3RhZ19saXN0IGxpc3RcbiAgfVxuXG4oKiogR3JhbW1hciBvZiBhIHJlY29yZCBmaWVsZC4gQSBmaWVsZCBtdXN0IHNob3cgdXAgZXhhY3RseSBvbmNlIGluIGEgcmVjb3JkIGlmXG4gICAgW3JlcXVpcmVkXSwgb3IgYXQgbW9zdCBvbmNlIG90aGVyd2lzZS4gQWNjZXB0cyBhIGxpc3QgaGVhZGVkIGJ5IFtuYW1lXSBhcyBhbiBhdG9tLFxuICAgIGZvbGxvd2VkIGJ5IHNleHBzIG1hdGNoaW5nIFthcmdzXS4gKilcbmFuZCBmaWVsZCA9XG4gIHsgbmFtZSA6IHN0cmluZ1xuICA7IHJlcXVpcmVkIDogYm9vbFxuICA7IGFyZ3MgOiBsaXN0X2dyYW1tYXJcbiAgfVxuXG4oKiogR3JhbW1hciB0YWdnZWQgd2l0aCBjbGllbnQtc3BlY2lmaWMga2V5L3ZhbHVlIHBhaXIuICopXG5hbmQgJ2Egd2l0aF90YWcgPVxuICB7IGtleSA6IHN0cmluZ1xuICA7IHZhbHVlIDogU2V4cC50XG4gIDsgZ3JhbW1hciA6ICdhXG4gIH1cblxuYW5kICdhIHdpdGhfdGFnX2xpc3QgPVxuICB8IFRhZyBvZiAnYSB3aXRoX3RhZ19saXN0IHdpdGhfdGFnXG4gIHwgTm9fdGFnIG9mICdhXG5cbigqKiBHcmFtbWFyIG9mIGEgcmVjdXJzaXZlIHR5cGUgZGVmaW5pdGlvbi4gTmFtZXMgdGhlIFt0eWNvbl0gYmVpbmcgZGVmaW5lZCwgYW5kIHRoZVxuICAgIFt0eXZhcnNdIGl0IHRha2VzIGFzIHBhcmFtZXRlcnMuIFNwZWNpZmllcyB0aGUgW2dyYW1tYXJdIG9mIHRoZSBbdHljb25dLiBUaGUgZ3JhbW1hclxuICAgIG1heSByZWZlciB0byBhbnkgb2YgdGhlIFt0eXZhcnNdLCBhbmQgdG8gYW55IG9mIHRoZSBbdHljb25dcyBmcm9tIHRoZSBzYW1lIHNldCBvZlxuICAgIFtSZWN1cnNpdmVdIGRlZmluaXRpb25zLiAqKVxuYW5kIGRlZm4gPVxuICB7IHR5Y29uIDogc3RyaW5nXG4gIDsgdHl2YXJzIDogc3RyaW5nIGxpc3RcbiAgOyBncmFtbWFyIDogZ3JhbW1hclxuICB9XG5cbigqKiBUb3AtbGV2ZWwgZ3JhbW1hciB0eXBlLiBIYXMgYSBwaGFudG9tIHR5cGUgcGFyYW1ldGVyIHRvIGFzc29jaWF0ZSBlYWNoIGdyYW1tYXIgd2l0aFxuICAgIHRoZSB0eXBlIGl0cyBzZXhwcyByZXByZXNlbnQuIFRoaXMgbWFrZXMgaXQgaGFyZGVyIHRvIGFwcGx5IGdyYW1tYXJzIHRvIHRoZSB3cm9uZ1xuICAgIHR5cGUsIHdoaWxlIGdyYW1tYXJzIGNhbiBzdGlsbCBiZSBlYXNpbHkgY29lcmNlZCB0byBhIG5ldyB0eXBlIGlmIG5lZWRlZC4gKilcbnR5cGUgXyB0ID0geyB1bnR5cGVkIDogZ3JhbW1hciB9IFtAQHVuYm94ZWRdXG5cbmxldCBjb2VyY2UgKHR5cGUgYSBiKSAoeyB1bnR5cGVkID0gXyB9IGFzIHQgOiBhIHQpIDogYiB0ID0gdFxuXG5sZXQgdGFnICh0eXBlIGEpICh7IHVudHlwZWQgPSBncmFtbWFyIH0gOiBhIHQpIH5rZXkgfnZhbHVlIDogYSB0ID1cbiAgeyB1bnR5cGVkID0gVGFnZ2VkIHsga2V5OyB2YWx1ZTsgZ3JhbW1hciB9IH1cbjs7XG5cbigqKiBUaGlzIHJlc2VydmVkIGtleSBpcyB1c2VkIGZvciBhbGwgdGFncyBnZW5lcmF0ZWQgZnJvbSBkb2MgY29tbWVudHMuICopXG5sZXQgZG9jX2NvbW1lbnRfdGFnID0gXCJzZXhwX2dyYW1tYXIuZG9jX2NvbW1lbnRcIlxuXG4oKiogVGhpcyByZXNlcnZlZCBrZXkgY2FuIGJlIHVzZWQgdG8gYXNzb2NpYXRlIGEgdHlwZSBuYW1lIHdpdGggYSBncmFtbWFyLiAqKVxubGV0IHR5cGVfbmFtZV90YWcgPSBcInNleHBfZ3JhbW1hci50eXBlX25hbWVcIlxuXG4oKiogVGhpcyByZXNlcnZlZCBrZXkgaW5kaWNhdGVzIHRoYXQgYSBzZXhwIHJlcHJlc2VudHMgYSBrZXkvdmFsdWUgYXNzb2NpYXRpb24uIFRoZSB0YWcnc1xuICAgIHZhbHVlIGlzIGlnbm9yZWQuICopXG5sZXQgYXNzb2NfdGFnID0gXCJzZXhwX2dyYW1tYXIuYXNzb2NcIlxuXG4oKiogVGhpcyByZXNlcnZlZCBrZXkgaW5kaWNhdGVzIHRoYXQgYSBzZXhwIGlzIGEga2V5IGluIGEga2V5L3ZhbHVlIGFzc29jaWF0aW9uLiBUaGUgdGFnJ3NcbiAgICB2YWx1ZSBpcyBpZ25vcmVkLiAqKVxubGV0IGFzc29jX2tleV90YWcgPSBcInNleHBfZ3JhbW1hci5hc3NvYy5rZXlcIlxuXG4oKiogVGhpcyByZXNlcnZlZCBrZXkgaW5kaWNhdGVzIHRoYXQgYSBzZXhwIGlzIGEgdmFsdWUgaW4gYSBrZXkvdmFsdWUgYXNzb2NpYXRpb24uIFRoZVxuICAgIHRhZydzIHZhbHVlIGlzIGlnbm9yZWQuICopXG5sZXQgYXNzb2NfdmFsdWVfdGFnID0gXCJzZXhwX2dyYW1tYXIuYXNzb2MudmFsdWVcIlxuXG4oKiogV2hlbiB0aGUga2V5IGlzIHNldCB0byBbQXRvbSBcImZhbHNlXCJdIGZvciBhIHZhcmlhbnQgY2xhdXNlLCB0aGF0IGNsYXVzZSBzaG91bGQgbm90IGJlXG4gICAgc3VnZ2VzdGVkIGluIGF1dG8tY29tcGxldGlvbiBiYXNlZCBvbiB0aGUgc2V4cCBncmFtbWFyLiAqKVxubGV0IGNvbXBsZXRpb25fc3VnZ2VzdGVkID0gXCJzZXhwX2dyYW1tYXIuY29tcGxldGlvbi1zdWdnZXN0ZWRcIlxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJkb2NfY29tbWVudF90YWciLCJ0eXBlX25hbWVfdGFnIiwiYXNzb2NfdGFnIiwiYXNzb2Nfa2V5X3RhZyIsImFzc29jX3ZhbHVlX3RhZyIsImNvbXBsZXRpb25fc3VnZ2VzdGVkIiwiY29lcmNlIiwidCIsInRhZyIsInBhcmFtIiwia2V5IiwidmFsdWUiLCJTZXhwbGliMF9TZXhwX2dyYW1tYXIiXSwibWFwcGluZ3MiOiJJQUFBQSxVQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLFlBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsdUJBQUE7QUFBQSxZQUFBQyxPQUFBQyxHQ29MMkQsU0FBQztBQUFBLFlBQUFDLElBQUFDLE9BQUFDLEtBQUFDLE9BRzFELG1DQUE0QztBQUFBO0FBQUEsSUFBQUM7QUFBQUEsTUR2TDlDIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6NjEyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6MywiZmlsZSI6InNleHBsaWIwLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZmFiaWFuLy5vcGFtL2RlZmF1bHQvbGliL3NleHBsaWIwL3NleHBfY29udl9ncmFtbWFyLm1sIl0sInNvdXJjZXNDb250ZW50IjpbIigqIGdlbmVyYXRlZCBjb2RlICopIiwib3BlbiBTdGRMYWJlbHNcblxubGV0IHNleHBfZ3JhbW1hcl93aXRoX3RhZ3MgZ3JhbW1hciB+dGFncyA9XG4gIExpc3QuZm9sZF9yaWdodCB0YWdzIH5pbml0OmdyYW1tYXIgfmY6KGZ1biAoa2V5LCB2YWx1ZSkgZ3JhbW1hciAtPlxuICAgIFNleHBfZ3JhbW1hci5UYWdnZWQgeyBrZXk7IHZhbHVlOyBncmFtbWFyIH0pXG47O1xuXG5sZXQgc2V4cF9ncmFtbWFyX3dpdGhfdGFnX2xpc3QgeCB+dGFncyA9XG4gIExpc3QuZm9sZF9yaWdodCB0YWdzIH5pbml0OnggfmY6KGZ1biAoa2V5LCB2YWx1ZSkgZ3JhbW1hciAtPlxuICAgIFNleHBfZ3JhbW1hci5UYWcgeyBrZXk7IHZhbHVlOyBncmFtbWFyIH0pXG47O1xuXG5sZXQgdW5pdF9zZXhwX2dyYW1tYXIgOiB1bml0IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gTGlzdCBFbXB0eSB9XG5sZXQgYm9vbF9zZXhwX2dyYW1tYXIgOiBib29sIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gQm9vbCB9XG5sZXQgc3RyaW5nX3NleHBfZ3JhbW1hciA6IHN0cmluZyBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IFN0cmluZyB9XG5sZXQgYnl0ZXNfc2V4cF9ncmFtbWFyIDogYnl0ZXMgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBTdHJpbmcgfVxubGV0IGNoYXJfc2V4cF9ncmFtbWFyIDogY2hhciBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IENoYXIgfVxubGV0IGludF9zZXhwX2dyYW1tYXIgOiBpbnQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBJbnRlZ2VyIH1cbmxldCBmbG9hdF9zZXhwX2dyYW1tYXIgOiBmbG9hdCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEZsb2F0IH1cbmxldCBpbnQzMl9zZXhwX2dyYW1tYXIgOiBpbnQzMiBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEludGVnZXIgfVxubGV0IGludDY0X3NleHBfZ3JhbW1hciA6IGludDY0IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gSW50ZWdlciB9XG5sZXQgbmF0aXZlaW50X3NleHBfZ3JhbW1hciA6IG5hdGl2ZWludCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEludGVnZXIgfVxubGV0IHNleHBfdF9zZXhwX2dyYW1tYXIgOiBTZXhwLnQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBBbnkgXCJTZXhwLnRcIiB9XG5sZXQgcmVmX3NleHBfZ3JhbW1hciBncmFtbWFyID0gU2V4cF9ncmFtbWFyLmNvZXJjZSBncmFtbWFyXG5sZXQgbGF6eV90X3NleHBfZ3JhbW1hciBncmFtbWFyID0gU2V4cF9ncmFtbWFyLmNvZXJjZSBncmFtbWFyXG5cbmxldCBvcHRpb25fc2V4cF9ncmFtbWFyICh7IHVudHlwZWQgfSA6IF8gU2V4cF9ncmFtbWFyLnQpIDogXyBvcHRpb24gU2V4cF9ncmFtbWFyLnQgPVxuICB7IHVudHlwZWQgPSBPcHRpb24gdW50eXBlZCB9XG47O1xuXG5sZXQgbGlzdF9zZXhwX2dyYW1tYXIgKHsgdW50eXBlZCB9IDogXyBTZXhwX2dyYW1tYXIudCkgOiBfIGxpc3QgU2V4cF9ncmFtbWFyLnQgPVxuICB7IHVudHlwZWQgPSBMaXN0IChNYW55IHVudHlwZWQpIH1cbjs7XG5cbmxldCBhcnJheV9zZXhwX2dyYW1tYXIgKHsgdW50eXBlZCB9IDogXyBTZXhwX2dyYW1tYXIudCkgOiBfIGFycmF5IFNleHBfZ3JhbW1hci50ID1cbiAgeyB1bnR5cGVkID0gTGlzdCAoTWFueSB1bnR5cGVkKSB9XG47O1xuXG5sZXQgZW1wdHlfc2V4cF9ncmFtbWFyIDogXyBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IFVuaW9uIFtdIH1cbmxldCBvcGFxdWVfc2V4cF9ncmFtbWFyID0gZW1wdHlfc2V4cF9ncmFtbWFyXG5sZXQgZnVuX3NleHBfZ3JhbW1hciA9IGVtcHR5X3NleHBfZ3JhbW1hclxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwzIiwiZiIsImEwIiwiYTEiLCJhMiIsImdsb2JhbF9kYXRhIiwidW5pdF9zZXhwX2dyYW1tYXIiLCJzZXhwX3Rfc2V4cF9ncmFtbWFyIiwiZW1wdHlfc2V4cF9ncmFtbWFyIiwiU2V4cGxpYjBfU2V4cF9ncmFtbWFyIiwiU3RkbGliX0xpc3RMYWJlbHMiLCJzZXhwX2dyYW1tYXJfd2l0aF90YWdzIiwiZ3JhbW1hciIsInRhZ3MiLCJwYXJhbSIsInZhbHVlIiwia2V5Iiwic2V4cF9ncmFtbWFyX3dpdGhfdGFnX2xpc3QiLCJ4IiwicmVmX3NleHBfZ3JhbW1hciIsImxhenlfdF9zZXhwX2dyYW1tYXIiLCJvcHRpb25fc2V4cF9ncmFtbWFyIiwibGlzdF9zZXhwX2dyYW1tYXIiLCJhcnJheV9zZXhwX2dyYW1tYXIiLCJTZXhwbGliMF9TZXhwX2NvbnZfZ3JhbW1hciJdLCJtYXBwaW5ncyI6Ik9BQUFBLFVBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQyxJQUFBQyxJQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsb0JBQUE7QUFBQSxJQUFBQyxzQkFBQTtBQUFBLElBQUFDLHFCQUFBO0FBQUEsSUFBQUMsd0JBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLFlBQUFDLHVCQUFBQyxTQUFBQztBQUFBQSxJQ0dFO0FBQUE7QUFBQSxzQkFBQUMsT0FBQUY7QUFBQUEsa0JBQUFHLFFBQXNDLFVBQUFDLE1BQUE7QUFBQSxjQUNwQztBQUFBLGFBQTRDO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsMkJBQUFDLEdBQUFMO0FBQUFBLElBSTlDO0FBQUE7QUFBQSxzQkFBQUMsT0FBQUY7QUFBQUEsa0JBQUFHLFFBQWdDLFVBQUFDLE1BQUE7QUFBQSxjQUM5QjtBQUFBLGFBQXlDO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUcsaUJBQUFQO0FBQUFBLElBY2QsbURBQTJCO0FBQUE7QUFBQSxZQUFBUSxvQkFBQVI7QUFBQUEsSUFDeEIsbURBQTJCO0FBQUE7QUFBQSxZQUFBUyxvQkFBQVAsT0FHM0Qsa0JBQTRCO0FBQUEsWUFBQVEsa0JBQUFSLE9BSTVCLHVCQUFpQztBQUFBLFlBQUFTLG1CQUFBVCxPQUlqQyx1QkFBaUM7QUFBQTtBQUFBLElBQUFVO0FBQUFBLE1EbkNuQyIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjY5MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzZXhwbGliMC5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2ZhYmlhbi8ub3BhbS9kZWZhdWx0L2xpYi9zZXhwbGliMC9zZXhwX2NvbnYubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBVdGlsaXR5IE1vZHVsZSBmb3IgUy1leHByZXNzaW9uIENvbnZlcnNpb25zICopXG5cbm9wZW4gU3RkTGFiZWxzXG5vcGVuIE1vcmVMYWJlbHNcbm9wZW4gUHJpbnRmXG5vcGVuIFNleHBcblxuKCogQ29udmVyc2lvbiBvZiBPQ2FtbC12YWx1ZXMgdG8gUy1leHByZXNzaW9ucyAqKVxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0IDogc3RyaW5nIC0+IGZsb2F0IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfZmxvYXRcIlxuXG4oKiAnJS4xN2cnIGlzIGd1YXJhbnRlZWQgdG8gYmUgcm91bmQtdHJpcHBhYmxlLlxuXG4gICAnJS4xNWcnIHdpbGwgYmUgcm91bmQtdHJpcHBhYmxlIGFuZCBub3QgaGF2ZSBub2lzZSBhdCB0aGUgbGFzdCBkaWdpdCBvciB0d28gZm9yIGEgZmxvYXRcbiAgIHdoaWNoIHdhcyBjb252ZXJ0ZWQgZnJvbSBhIGRlY2ltYWwgKHN0cmluZykgd2l0aCA8PSAxNSBzaWduaWZpY2FudCBkaWdpdHMuICBTbyBpdCdzXG4gICB3b3J0aCB0cnlpbmcgZmlyc3QgdG8gYXZvaWQgdGhpbmdzIGxpa2UgXCIzLjE0MDAwMDAwMDAwMDAwMDFcIi5cblxuICAgU2VlIGNvbW1lbnQgYWJvdmUgW3RvX3N0cmluZ19yb3VuZF90cmlwcGFibGVdIGluIHshQ29yZS5GbG9hdH0gZm9yXG4gICBkZXRhaWxlZCBleHBsYW5hdGlvbiBhbmQgZXhhbXBsZXMuICopXG5sZXQgZGVmYXVsdF9zdHJpbmdfb2ZfZmxvYXQgPVxuICByZWYgKGZ1biB4IC0+XG4gICAgbGV0IHkgPSBmb3JtYXRfZmxvYXQgXCIlLjE1R1wiIHggaW5cbiAgICBpZiBmbG9hdF9vZl9zdHJpbmcgeSA9IHggdGhlbiB5IGVsc2UgZm9ybWF0X2Zsb2F0IFwiJS4xN0dcIiB4KVxuOztcblxubGV0IHJlYWRfb2xkX29wdGlvbl9mb3JtYXQgPSByZWYgdHJ1ZVxubGV0IHdyaXRlX29sZF9vcHRpb25fZm9ybWF0ID0gcmVmIHRydWVcbmxldCBsaXN0X21hcCBmIGwgPSBMaXN0Lm1hcCBsIH5mXG5sZXQgc2V4cF9vZl91bml0ICgpID0gTGlzdCBbXVxubGV0IHNleHBfb2ZfYm9vbCBiID0gQXRvbSAoc3RyaW5nX29mX2Jvb2wgYilcbmxldCBzZXhwX29mX3N0cmluZyBzdHIgPSBBdG9tIHN0clxubGV0IHNleHBfb2ZfYnl0ZXMgYnl0ZXMgPSBBdG9tIChCeXRlcy50b19zdHJpbmcgYnl0ZXMpXG5sZXQgc2V4cF9vZl9jaGFyIGMgPSBBdG9tIChTdHJpbmcubWFrZSAxIGMpXG5sZXQgc2V4cF9vZl9pbnQgbiA9IEF0b20gKHN0cmluZ19vZl9pbnQgbilcbmxldCBzZXhwX29mX2Zsb2F0IG4gPSBBdG9tICghZGVmYXVsdF9zdHJpbmdfb2ZfZmxvYXQgbilcbmxldCBzZXhwX29mX2ludDMyIG4gPSBBdG9tIChJbnQzMi50b19zdHJpbmcgbilcbmxldCBzZXhwX29mX2ludDY0IG4gPSBBdG9tIChJbnQ2NC50b19zdHJpbmcgbilcbmxldCBzZXhwX29mX25hdGl2ZWludCBuID0gQXRvbSAoTmF0aXZlaW50LnRvX3N0cmluZyBuKVxubGV0IHNleHBfb2ZfcmVmIHNleHBfb2ZfX2EgcmYgPSBzZXhwX29mX19hICFyZlxubGV0IHNleHBfb2ZfbGF6eV90IHNleHBfb2ZfX2EgbHYgPSBzZXhwX29mX19hIChMYXp5LmZvcmNlIGx2KVxuXG5sZXQgc2V4cF9vZl9vcHRpb24gc2V4cF9vZl9fYSA9IGZ1bmN0aW9uXG4gIHwgU29tZSB4IHdoZW4gIXdyaXRlX29sZF9vcHRpb25fZm9ybWF0IC0+IExpc3QgWyBzZXhwX29mX19hIHggXVxuICB8IFNvbWUgeCAtPiBMaXN0IFsgQXRvbSBcInNvbWVcIjsgc2V4cF9vZl9fYSB4IF1cbiAgfCBOb25lIHdoZW4gIXdyaXRlX29sZF9vcHRpb25fZm9ybWF0IC0+IExpc3QgW11cbiAgfCBOb25lIC0+IEF0b20gXCJub25lXCJcbjs7XG5cbmxldCBzZXhwX29mX3BhaXIgc2V4cF9vZl9fYSBzZXhwX29mX19iIChhLCBiKSA9IExpc3QgWyBzZXhwX29mX19hIGE7IHNleHBfb2ZfX2IgYiBdXG5cbmxldCBzZXhwX29mX3RyaXBsZSBzZXhwX29mX19hIHNleHBfb2ZfX2Igc2V4cF9vZl9fYyAoYSwgYiwgYykgPVxuICBMaXN0IFsgc2V4cF9vZl9fYSBhOyBzZXhwX29mX19iIGI7IHNleHBfb2ZfX2MgYyBdXG47O1xuXG5sZXQgc2V4cF9vZl9saXN0IHNleHBfb2ZfX2EgbHN0ID0gTGlzdCAoTGlzdC5tYXAgbHN0IH5mOnNleHBfb2ZfX2EpXG5cbmxldCBzZXhwX29mX2FycmF5IHNleHBfb2ZfX2EgYXIgPVxuICBsZXQgbHN0X3JlZiA9IHJlZiBbXSBpblxuICBmb3IgaSA9IEFycmF5Lmxlbmd0aCBhciAtIDEgZG93bnRvIDAgZG9cbiAgICBsc3RfcmVmIDo9IHNleHBfb2ZfX2EgYXIuKGkpIDo6ICFsc3RfcmVmXG4gIGRvbmU7XG4gIExpc3QgIWxzdF9yZWZcbjs7XG5cbmxldCBzZXhwX29mX2hhc2h0Ymwgc2V4cF9vZl9rZXkgc2V4cF9vZl92YWwgaHRibCA9XG4gIGxldCBjb2xsIH5rZXk6ayB+ZGF0YTp2IGFjYyA9IExpc3QgWyBzZXhwX29mX2tleSBrOyBzZXhwX29mX3ZhbCB2IF0gOjogYWNjIGluXG4gIExpc3QgKEhhc2h0YmwuZm9sZCBodGJsIH5pbml0OltdIH5mOmNvbGwpXG47O1xuXG5sZXQgc2V4cF9vZl9vcGFxdWUgXyA9IEF0b20gXCI8b3BhcXVlPlwiXG5sZXQgc2V4cF9vZl9mdW4gXyA9IEF0b20gXCI8ZnVuPlwiXG5cbigqIEV4Y2VwdGlvbiBjb252ZXJ0ZXIgcmVnaXN0cmF0aW9uIGFuZCBsb29rdXAgKilcblxubW9kdWxlIEV4bl9jb252ZXJ0ZXIgPSBzdHJ1Y3RcbiAgKCogVGhlc2UgZXhjZXB0aW9uIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgY29udGV4dC1zd2l0Y2hlc1xuICAgICBjYW5ub3QgaGFwcGVuIHVubGVzcyB0aGVyZSBpcyBhbiBhbGxvY2F0aW9uLiAgSXQgaXMgcmVhc29uYWJsZSB0byBleHBlY3RcbiAgICAgdGhhdCB0aGlzIHdpbGwgcmVtYWluIHRydWUgZm9yIHRoZSBmb3Jlc2VlYWJsZSBmdXR1cmUuICBUaGF0IHdheSB3ZVxuICAgICBhdm9pZCB1c2luZyBtdXRleGVzIGFuZCB0aHVzIGEgZGVwZW5kZW5jeSBvbiB0aGUgdGhyZWFkcyBsaWJyYXJ5LiAqKVxuXG4gICgqIEZhc3QgYW5kIGF1dG9tYXRpYyBleGNlcHRpb24gcmVnaXN0cmF0aW9uICopXG5cbiAgbW9kdWxlIFJlZ2lzdHJhdGlvbiA9IHN0cnVjdFxuICAgIHR5cGUgdCA9XG4gICAgICB7IHNleHBfb2ZfZXhuIDogZXhuIC0+IFNleHAudFxuICAgICAgOyAoKiBJZiBbcHJpbnRleGMgPSB0cnVlXSB0aGVuIHRoaXMgc2V4cCBjb252ZXJ0ZXIgaXMgdXNlZCBmb3IgUHJpbnRleGMudG9fc3RyaW5nICopXG4gICAgICAgIHByaW50ZXhjIDogYm9vbFxuICAgICAgfVxuICBlbmRcblxuICBtb2R1bGUgRXhuX3RhYmxlID0gRXBoZW1lcm9uLksxLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgdCA9IGV4dGVuc2lvbl9jb25zdHJ1Y3RvclxuXG4gICAgbGV0IGVxdWFsID0gKCA9PSApXG4gICAgbGV0IGhhc2ggPSBPYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLmlkXG4gIGVuZClcblxuICBsZXQgdGhlX2V4bl90YWJsZSA6IFJlZ2lzdHJhdGlvbi50IEV4bl90YWJsZS50ID0gRXhuX3RhYmxlLmNyZWF0ZSAxN1xuXG4gICgqIEVwaGVtZXJvbnMgYXJlIHVzZWQgc28gdGhhdCBbc2V4cF9vZl9leG5dIGNsb3N1cmUgZG9uJ3Qga2VlcCB0aGVcbiAgICAgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIGxpdmUuICopXG4gIGxldCBhZGQgPyhwcmludGV4YyA9IHRydWUpID9maW5hbGlzZTpfIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciBzZXhwX29mX2V4biA9XG4gICAgRXhuX3RhYmxlLmFkZCB0aGVfZXhuX3RhYmxlIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciB7IHNleHBfb2ZfZXhuOyBwcmludGV4YyB9XG4gIDs7XG5cbiAgbGV0IGZpbmRfYXV0byB+Zm9yX3ByaW50ZXhjIGV4biA9XG4gICAgbGV0IGV4dGVuc2lvbl9jb25zdHJ1Y3RvciA9IE9iai5FeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsIGV4biBpblxuICAgIG1hdGNoIEV4bl90YWJsZS5maW5kX29wdCB0aGVfZXhuX3RhYmxlIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgeyBzZXhwX29mX2V4bjsgcHJpbnRleGMgfSAtPlxuICAgICAgKG1hdGNoIGZvcl9wcmludGV4YywgcHJpbnRleGMgd2l0aFxuICAgICAgIHwgZmFsc2UsIF8gfCBfLCB0cnVlIC0+IFNvbWUgKHNleHBfb2ZfZXhuIGV4bilcbiAgICAgICB8IHRydWUsIGZhbHNlIC0+IE5vbmUpXG4gIDs7XG5cbiAgbW9kdWxlIEZvcl91bml0X3Rlc3RzX29ubHkgPSBzdHJ1Y3RcbiAgICBsZXQgc2l6ZSAoKSA9IChFeG5fdGFibGUuc3RhdHNfYWxpdmUgdGhlX2V4bl90YWJsZSkubnVtX2JpbmRpbmdzXG4gIGVuZFxuZW5kXG5cbmxldCBzZXhwX29mX2V4bl9vcHRfZm9yX3ByaW50ZXhjIGV4biA9IEV4bl9jb252ZXJ0ZXIuZmluZF9hdXRvIH5mb3JfcHJpbnRleGM6dHJ1ZSBleG5cbmxldCBzZXhwX29mX2V4bl9vcHQgZXhuID0gRXhuX2NvbnZlcnRlci5maW5kX2F1dG8gfmZvcl9wcmludGV4YzpmYWxzZSBleG5cblxubGV0IHNleHBfb2ZfZXhuIGV4biA9XG4gIG1hdGNoIHNleHBfb2ZfZXhuX29wdCBleG4gd2l0aFxuICB8IE5vbmUgLT4gTGlzdCBbIEF0b20gKFByaW50ZXhjLnRvX3N0cmluZyBleG4pIF1cbiAgfCBTb21lIHNleHAgLT4gc2V4cFxuOztcblxubGV0IGV4bl90b19zdHJpbmcgZSA9IFNleHAudG9fc3RyaW5nX2h1bSAoc2V4cF9vZl9leG4gZSlcblxuKCoge1tleGNlcHRpb24gQmxhaCBbQEBkZXJpdmluZyBzZXhwXV19IGdlbmVyYXRlcyBhIGNhbGwgdG8gdGhlIGZ1bmN0aW9uXG4gICBbRXhuX2NvbnZlcnRlci5hZGRdIGRlZmluZWQgaW4gdGhpcyBmaWxlLiAgU28gd2UgYXJlIGd1YXJhbnRlZCB0aGF0IGFzIHNvb24gYXMgd2VcbiAgIG1hcmsgYW4gZXhjZXB0aW9uIGFzIHNleHBhYmxlLCB0aGlzIG1vZHVsZSB3aWxsIGJlIGxpbmtlZCBpbiBhbmQgdGhpcyBwcmludGVyIHdpbGwgYmVcbiAgIHJlZ2lzdGVyZWQsIHdoaWNoIGlzIHdoYXQgd2Ugd2FudC4gKilcbmxldCAoKSA9XG4gIFByaW50ZXhjLnJlZ2lzdGVyX3ByaW50ZXIgKGZ1biBleG4gLT5cbiAgICBtYXRjaCBzZXhwX29mX2V4bl9vcHRfZm9yX3ByaW50ZXhjIGV4biB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgc2V4cCAtPiBTb21lIChTZXhwLnRvX3N0cmluZ19odW0gfmluZGVudDoyIHNleHApKVxuOztcblxubGV0IHByaW50ZXhjX3ByZWZlcl9zZXhwIGV4biA9XG4gIG1hdGNoIHNleHBfb2ZfZXhuX29wdCBleG4gd2l0aFxuICB8IE5vbmUgLT4gUHJpbnRleGMudG9fc3RyaW5nIGV4blxuICB8IFNvbWUgc2V4cCAtPiBTZXhwLnRvX3N0cmluZ19odW0gfmluZGVudDoyIHNleHBcbjs7XG5cbigqIENvbnZlcnNpb24gb2YgUy1leHByZXNzaW9ucyB0byBPQ2FtbC12YWx1ZXMgKilcblxuZXhjZXB0aW9uIE9mX3NleHBfZXJyb3IgPSBTZXhwLk9mX3NleHBfZXJyb3JcblxubGV0IHJlY29yZF9jaGVja19leHRyYV9maWVsZHMgPSByZWYgdHJ1ZVxubGV0IG9mX3NleHBfZXJyb3JfZXhuIGV4YyBzZXhwID0gcmFpc2UgKE9mX3NleHBfZXJyb3IgKGV4Yywgc2V4cCkpXG5sZXQgb2Zfc2V4cF9lcnJvciB3aGF0IHNleHAgPSByYWlzZSAoT2Zfc2V4cF9lcnJvciAoRmFpbHVyZSB3aGF0LCBzZXhwKSlcblxubGV0IHVuaXRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBbXSAtPiAoKVxuICB8IEF0b20gXyB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwidW5pdF9vZl9zZXhwOiBlbXB0eSBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBib29sX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gKFwidHJ1ZVwiIHwgXCJUcnVlXCIpIC0+IHRydWVcbiAgfCBBdG9tIChcImZhbHNlXCIgfCBcIkZhbHNlXCIpIC0+IGZhbHNlXG4gIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJib29sX29mX3NleHA6IHVua25vd24gc3RyaW5nXCIgc2V4cFxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiYm9vbF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBzdHJpbmdfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT4gc3RyXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJzdHJpbmdfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgYnl0ZXNfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT4gQnl0ZXMub2Zfc3RyaW5nIHN0clxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiYnl0ZXNfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgY2hhcl9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgIGlmIFN0cmluZy5sZW5ndGggc3RyIDw+IDFcbiAgICB0aGVuIG9mX3NleHBfZXJyb3IgXCJjaGFyX29mX3NleHA6IGF0b20gc3RyaW5nIG11c3QgY29udGFpbiBvbmUgY2hhcmFjdGVyIG9ubHlcIiBzZXhwO1xuICAgIHN0ci5bMF1cbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImNoYXJfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgaW50X29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBpbnRfb2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwiaW50X29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJpbnRfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgZmxvYXRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IGZsb2F0X29mX3N0cmluZyBzdHIgd2l0aFxuICAgICB8IGV4YyAtPiBvZl9zZXhwX2Vycm9yIChcImZsb2F0X29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJmbG9hdF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBpbnQzMl9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgICh0cnkgSW50MzIub2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwiaW50MzJfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImludDMyX29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGludDY0X29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBJbnQ2NC5vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJpbnQ2NF9vZl9zZXhwOiBcIiBeIGV4bl90b19zdHJpbmcgZXhjKSBzZXhwKVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiaW50NjRfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgbmF0aXZlaW50X29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBOYXRpdmVpbnQub2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwibmF0aXZlaW50X29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJuYXRpdmVpbnRfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgcmVmX29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID0gcmVmIChhX19vZl9zZXhwIHNleHApXG5sZXQgbGF6eV90X29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID0gTGF6eS5mcm9tX3ZhbCAoYV9fb2Zfc2V4cCBzZXhwKVxuXG5sZXQgb3B0aW9uX29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID1cbiAgaWYgIXJlYWRfb2xkX29wdGlvbl9mb3JtYXRcbiAgdGhlbiAoXG4gICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgfCBMaXN0IFtdIHwgQXRvbSAoXCJub25lXCIgfCBcIk5vbmVcIikgLT4gTm9uZVxuICAgIHwgTGlzdCBbIGVsIF0gfCBMaXN0IFsgQXRvbSAoXCJzb21lXCIgfCBcIlNvbWVcIik7IGVsIF0gLT4gU29tZSAoYV9fb2Zfc2V4cCBlbClcbiAgICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwib3B0aW9uX29mX3NleHA6IGxpc3QgbXVzdCByZXByZXNlbnQgb3B0aW9uYWwgdmFsdWVcIiBzZXhwXG4gICAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcIm9wdGlvbl9vZl9zZXhwOiBvbmx5IG5vbmUgY2FuIGJlIGF0b21cIiBzZXhwKVxuICBlbHNlIChcbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IEF0b20gKFwibm9uZVwiIHwgXCJOb25lXCIpIC0+IE5vbmVcbiAgICB8IExpc3QgWyBBdG9tIChcInNvbWVcIiB8IFwiU29tZVwiKTsgZWwgXSAtPiBTb21lIChhX19vZl9zZXhwIGVsKVxuICAgIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJvcHRpb25fb2Zfc2V4cDogb25seSBub25lIGNhbiBiZSBhdG9tXCIgc2V4cFxuICAgIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJvcHRpb25fb2Zfc2V4cDogbGlzdCBtdXN0IGJlIChzb21lIGVsKVwiIHNleHApXG47O1xuXG5sZXQgcGFpcl9vZl9zZXhwIGFfX29mX3NleHAgYl9fb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBbIGFfc2V4cDsgYl9zZXhwIF0gLT5cbiAgICBsZXQgYSA9IGFfX29mX3NleHAgYV9zZXhwIGluXG4gICAgbGV0IGIgPSBiX19vZl9zZXhwIGJfc2V4cCBpblxuICAgIGEsIGJcbiAgfCBMaXN0IF8gLT5cbiAgICBvZl9zZXhwX2Vycm9yIFwicGFpcl9vZl9zZXhwOiBsaXN0IG11c3QgY29udGFpbiBleGFjdGx5IHR3byBlbGVtZW50cyBvbmx5XCIgc2V4cFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwicGFpcl9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCB0cmlwbGVfb2Zfc2V4cCBhX19vZl9zZXhwIGJfX29mX3NleHAgY19fb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBbIGFfc2V4cDsgYl9zZXhwOyBjX3NleHAgXSAtPlxuICAgIGxldCBhID0gYV9fb2Zfc2V4cCBhX3NleHAgaW5cbiAgICBsZXQgYiA9IGJfX29mX3NleHAgYl9zZXhwIGluXG4gICAgbGV0IGMgPSBjX19vZl9zZXhwIGNfc2V4cCBpblxuICAgIGEsIGIsIGNcbiAgfCBMaXN0IF8gLT5cbiAgICBvZl9zZXhwX2Vycm9yIFwidHJpcGxlX29mX3NleHA6IGxpc3QgbXVzdCBjb250YWluIGV4YWN0bHkgdGhyZWUgZWxlbWVudHMgb25seVwiIHNleHBcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcInRyaXBsZV9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBsaXN0X29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBsc3QgLT4gTGlzdC5tYXAgbHN0IH5mOmFfX29mX3NleHBcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImxpc3Rfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgYXJyYXlfb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IFtdIC0+IFt8fF1cbiAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIHQgKyAxIGluXG4gICAgbGV0IHJlcyA9IEFycmF5Lm1ha2UgbGVuIChhX19vZl9zZXhwIGgpIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByZXNcbiAgICAgIHwgaCA6OiB0IC0+XG4gICAgICAgIHJlcy4oaSkgPC0gYV9fb2Zfc2V4cCBoO1xuICAgICAgICBsb29wIChpICsgMSkgdFxuICAgIGluXG4gICAgbG9vcCAxIHRcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImFycmF5X29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGhhc2h0Ymxfb2Zfc2V4cCBrZXlfb2Zfc2V4cCB2YWxfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBsc3QgLT5cbiAgICBsZXQgaHRibCA9IEhhc2h0YmwuY3JlYXRlIDAgaW5cbiAgICBsZXQgYWN0ID0gZnVuY3Rpb25cbiAgICAgIHwgTGlzdCBbIGtfc2V4cDsgdl9zZXhwIF0gLT5cbiAgICAgICAgSGFzaHRibC5hZGQgaHRibCB+a2V5OihrZXlfb2Zfc2V4cCBrX3NleHApIH5kYXRhOih2YWxfb2Zfc2V4cCB2X3NleHApXG4gICAgICB8IExpc3QgXyB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiaGFzaHRibF9vZl9zZXhwOiB0dXBsZSBsaXN0IG5lZWRlZFwiIHNleHBcbiAgICBpblxuICAgIExpc3QuaXRlciBsc3QgfmY6YWN0O1xuICAgIGh0YmxcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImhhc2h0Ymxfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgb3BhcXVlX29mX3NleHAgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgXCJvcGFxdWVfb2Zfc2V4cDogY2Fubm90IGNvbnZlcnQgb3BhcXVlIHZhbHVlc1wiIHNleHBcbjs7XG5cbmxldCBmdW5fb2Zfc2V4cCBzZXhwID0gb2Zfc2V4cF9lcnJvciBcImZ1bl9vZl9zZXhwOiBjYW5ub3QgY29udmVydCBmdW5jdGlvbiB2YWx1ZXNcIiBzZXhwXG5cbigqIFNleHAgR3JhbW1hcnMgKilcblxuaW5jbHVkZSBTZXhwX2NvbnZfZ3JhbW1hclxuXG4oKiBSZWdpc3RlcmluZyBkZWZhdWx0IGV4Y2VwdGlvbiBwcmludGVycyAqKVxuXG5sZXQgZ2V0X2ZsY19lcnJvciBuYW1lIChmaWxlLCBsaW5lLCBjaHIpID0gQXRvbSAoc3ByaW50ZiBcIiVzICVzOiVkOiVkXCIgbmFtZSBmaWxlIGxpbmUgY2hyKVxuXG5sZXQgKCkgPVxuICBMaXN0Lml0ZXJcbiAgICB+ZjooZnVuIChleHRlbnNpb25fY29uc3RydWN0b3IsIGhhbmRsZXIpIC0+XG4gICAgICBFeG5fY29udmVydGVyLmFkZCB+cHJpbnRleGM6ZmFsc2UgfmZpbmFsaXNlOmZhbHNlIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciBoYW5kbGVyKVxuICAgIFsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBBc3NlcnRfZmFpbHVyZV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBBc3NlcnRfZmFpbHVyZSBhcmcgLT4gZ2V0X2ZsY19lcnJvciBcIkFzc2VydF9mYWlsdXJlXCIgYXJnXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBFeGl0XVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEV4aXQgLT4gQXRvbSBcIkV4aXRcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgRW5kX29mX2ZpbGVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgRW5kX29mX2ZpbGUgLT4gQXRvbSBcIkVuZF9vZl9maWxlXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEZhaWx1cmVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgRmFpbHVyZSBhcmcgLT4gTGlzdCBbIEF0b20gXCJGYWlsdXJlXCI7IEF0b20gYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE5vdF9mb3VuZF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBOb3RfZm91bmQgLT4gQXRvbSBcIk5vdF9mb3VuZFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBJbnZhbGlkX2FyZ3VtZW50XVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEludmFsaWRfYXJndW1lbnQgYXJnIC0+IExpc3QgWyBBdG9tIFwiSW52YWxpZF9hcmd1bWVudFwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBNYXRjaF9mYWlsdXJlXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IE1hdGNoX2ZhaWx1cmUgYXJnIC0+IGdldF9mbGNfZXJyb3IgXCJNYXRjaF9mYWlsdXJlXCIgYXJnXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBOb3RfZm91bmRfc11cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBOb3RfZm91bmRfcyBhcmcgLT4gTGlzdCBbIEF0b20gXCJOb3RfZm91bmRfc1wiOyBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgU3lzX2Vycm9yXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFN5c19lcnJvciBhcmcgLT4gTGlzdCBbIEF0b20gXCJTeXNfZXJyb3JcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgQXJnLkhlbHBdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgQXJnLkhlbHAgYXJnIC0+IExpc3QgWyBBdG9tIFwiQXJnLkhlbHBcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgQXJnLkJhZF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBBcmcuQmFkIGFyZyAtPiBMaXN0IFsgQXRvbSBcIkFyZy5CYWRcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgTGF6eS5VbmRlZmluZWRdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgTGF6eS5VbmRlZmluZWQgLT4gQXRvbSBcIkxhenkuVW5kZWZpbmVkXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFBhcnNpbmcuUGFyc2VfZXJyb3JdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgUGFyc2luZy5QYXJzZV9lcnJvciAtPiBBdG9tIFwiUGFyc2luZy5QYXJzZV9lcnJvclwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBRdWV1ZS5FbXB0eV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBRdWV1ZS5FbXB0eSAtPiBBdG9tIFwiUXVldWUuRW1wdHlcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgU2NhbmYuU2Nhbl9mYWlsdXJlXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFNjYW5mLlNjYW5fZmFpbHVyZSBhcmcgLT4gTGlzdCBbIEF0b20gXCJTY2FuZi5TY2FuX2ZhaWx1cmVcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgU3RhY2suRW1wdHldXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgU3RhY2suRW1wdHkgLT4gQXRvbSBcIlN0YWNrLkVtcHR5XCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFN5cy5CcmVha11cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBTeXMuQnJlYWsgLT4gQXRvbSBcIlN5cy5CcmVha1wiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIF1cbjs7XG5cbmxldCAoKSA9XG4gIExpc3QuaXRlclxuICAgIH5mOihmdW4gKGV4dGVuc2lvbl9jb25zdHJ1Y3RvciwgaGFuZGxlcikgLT5cbiAgICAgIEV4bl9jb252ZXJ0ZXIuYWRkIH5wcmludGV4Yzp0cnVlIH5maW5hbGlzZTpmYWxzZSBleHRlbnNpb25fY29uc3RydWN0b3IgaGFuZGxlcilcbiAgICBbICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgT2Zfc2V4cF9lcnJvcl1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBPZl9zZXhwX2Vycm9yIChleGMsIHNleHApIC0+XG4gICAgICAgICAgTGlzdCBbIEF0b20gXCJTZXhwbGliLkNvbnYuT2Zfc2V4cF9lcnJvclwiOyBzZXhwX29mX2V4biBleGM7IHNleHAgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICBdXG47O1xuXG5leHRlcm5hbCBpZ25vcmUgOiBfIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuZXh0ZXJuYWwgKCA9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3RfQXNzZXJ0X2ZhaWx1cmUiLCJjc3RfTm9uZSIsImNzdF9Tb21lIiwiY3N0X25vbmUiLCJjc3Rfb3B0aW9uX29mX3NleHBfb25seV9ub25lX2MiLCJjc3Rfc29tZSIsImNzdF9zcmNfc2V4cF9jb252X21sIiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfZmxvYXRfb2Zfc3RyaW5nIiwiY2FtbF9mb3JtYXRfZmxvYXQiLCJjYW1sX2ludF9vZl9zdHJpbmciLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDUiLCJhMyIsImE0IiwiZ2xvYmFsX2RhdGEiLCJBc3NlcnRfZmFpbHVyZSIsIlN0ZGxpYiIsIlNleHBsaWIwX1NleHAiLCJTdGRsaWJfQXJnIiwiU3RkbGliX0xhenkiLCJTdGRsaWJfUGFyc2luZyIsIlN0ZGxpYl9RdWV1ZSIsIlN0ZGxpYl9TY2FuZiIsIlN0ZGxpYl9TdGFjayIsIlN0ZGxpYl9TeXMiLCJTdGRsaWJfUHJpbnRmIiwiU3RkbGliX01vcmVMYWJlbHMiLCJTdGRsaWJfTGlzdExhYmVscyIsIlN0ZGxpYl9CeXRlc0xhYmVscyIsIlN0ZGxpYl9QcmludGV4YyIsIlN0ZGxpYl9PYmoiLCJDYW1saW50ZXJuYWxMYXp5IiwiU3RkbGliX05hdGl2ZWludCIsIlN0ZGxpYl9JbnQ2NCIsIlN0ZGxpYl9JbnQzMiIsIlN0ZGxpYl9TdHJpbmdMYWJlbHMiLCJTdGRsaWJfRXBoZW1lcm9uIiwiU2V4cGxpYjBfU2V4cF9jb252X2dyYW1tYXIiLCJkZWZhdWx0X3N0cmluZ19vZl9mbG9hdCIsIngiLCJ5IiwicmVhZF9vbGRfb3B0aW9uX2Zvcm1hdCIsIndyaXRlX29sZF9vcHRpb25fZm9ybWF0IiwibGlzdF9tYXAiLCJsIiwic2V4cF9vZl91bml0IiwicGFyYW0iLCJzZXhwX29mX2Jvb2wiLCJiIiwic2V4cF9vZl9zdHJpbmciLCJzdHIiLCJzZXhwX29mX2J5dGVzIiwiYnl0ZXMiLCJzZXhwX29mX2NoYXIiLCJjIiwic2V4cF9vZl9pbnQiLCJuIiwic2V4cF9vZl9mbG9hdCIsInNleHBfb2ZfaW50MzIiLCJzZXhwX29mX2ludDY0Iiwic2V4cF9vZl9uYXRpdmVpbnQiLCJzZXhwX29mX3JlZiIsInNleHBfb2ZfYSIsInJmIiwic2V4cF9vZl9sYXp5X3QiLCJsdiIsInNleHBfb2Zfb3B0aW9uIiwic2V4cF9vZl9wYWlyIiwic2V4cF9vZl9iIiwiYSIsInNleHBfb2ZfdHJpcGxlIiwic2V4cF9vZl9jIiwic2V4cF9vZl9saXN0IiwibHN0Iiwic2V4cF9vZl9hcnJheSIsImFyIiwibHN0X3JlZiIsImkiLCJzZXhwX29mX2hhc2h0YmwiLCJzZXhwX29mX2tleSIsInNleHBfb2ZfdmFsIiwiaHRibCIsImNvbGwiLCJrIiwidiIsImFjYyIsInNleHBfb2Zfb3BhcXVlIiwic2V4cF9vZl9mdW4iLCJlcXVhbCIsImhhc2giLCJFeG5fdGFibGUiLCJ0aGVfZXhuX3RhYmxlIiwiYWRkIiwib3B0IiwiZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIiwic2V4cF9vZl9leG4iLCJwcmludGV4YyIsImZpbmRfYXV0byIsImZvcl9wcmludGV4YyIsImV4biIsIm1hdGNoIiwic2l6ZSIsIkZvcl91bml0X3Rlc3RzX29ubHkiLCJzZXhwX29mX2V4bl9vcHQiLCJzZXhwIiwiZXhuX3RvX3N0cmluZyIsImUiLCJwcmludGV4Y19wcmVmZXJfc2V4cCIsIk9mX3NleHBfZXJyb3IiLCJyZWNvcmRfY2hlY2tfZXh0cmFfZmllbGRzIiwiY3N0X3VuaXRfb2Zfc2V4cF9lbXB0eV9saXN0X25lIiwiY3N0X2Jvb2xfb2Zfc2V4cF91bmtub3duX3N0cmluIiwiY3N0X2Jvb2xfb2Zfc2V4cF9hdG9tX25lZWRlZCIsImNzdF9zdHJpbmdfb2Zfc2V4cF9hdG9tX25lZWRlZCIsImNzdF9ieXRlc19vZl9zZXhwX2F0b21fbmVlZGVkIiwiY3N0X2NoYXJfb2Zfc2V4cF9hdG9tX3N0cmluZ19tIiwiY3N0X2NoYXJfb2Zfc2V4cF9hdG9tX25lZWRlZCIsImNzdF9pbnRfb2Zfc2V4cCIsImNzdF9pbnRfb2Zfc2V4cF9hdG9tX25lZWRlZCIsImNzdF9mbG9hdF9vZl9zZXhwIiwiY3N0X2Zsb2F0X29mX3NleHBfYXRvbV9uZWVkZWQiLCJjc3RfaW50MzJfb2Zfc2V4cCIsImNzdF9pbnQzMl9vZl9zZXhwX2F0b21fbmVlZGVkIiwiY3N0X2ludDY0X29mX3NleHAiLCJjc3RfaW50NjRfb2Zfc2V4cF9hdG9tX25lZWRlZCIsImNzdF9uYXRpdmVpbnRfb2Zfc2V4cCIsImNzdF9uYXRpdmVpbnRfb2Zfc2V4cF9hdG9tX25lZSIsImNzdF9vcHRpb25fb2Zfc2V4cF9saXN0X211c3RfciIsImNzdF9vcHRpb25fb2Zfc2V4cF9saXN0X211c3RfYiIsImNzdF9wYWlyX29mX3NleHBfbGlzdF9uZWVkZWQiLCJjc3RfcGFpcl9vZl9zZXhwX2xpc3RfbXVzdF9jb24iLCJjc3RfdHJpcGxlX29mX3NleHBfbGlzdF9uZWVkZWQiLCJjc3RfdHJpcGxlX29mX3NleHBfbGlzdF9tdXN0X2MiLCJjc3RfbGlzdF9vZl9zZXhwX2xpc3RfbmVlZGVkIiwiY3N0X2FycmF5X29mX3NleHBfbGlzdF9uZWVkZWQiLCJjc3RfaGFzaHRibF9vZl9zZXhwX2xpc3RfbmVlZGUiLCJjc3RfaGFzaHRibF9vZl9zZXhwX3R1cGxlX2xpc3QiLCJjc3Rfb3BhcXVlX29mX3NleHBfY2Fubm90X2NvbnYiLCJjc3RfZnVuX29mX3NleHBfY2Fubm90X2NvbnZlcnQiLCJvZl9zZXhwX2Vycm9yX2V4biIsImV4YyIsIm9mX3NleHBfZXJyb3IiLCJ3aGF0IiwidW5pdF9vZl9zZXhwIiwiYm9vbF9vZl9zZXhwIiwic3RyaW5nX29mX3NleHAiLCJieXRlc19vZl9zZXhwIiwiY2hhcl9vZl9zZXhwIiwiaW50X29mX3NleHAiLCJmbG9hdF9vZl9zZXhwIiwiaW50MzJfb2Zfc2V4cCIsImludDY0X29mX3NleHAiLCJuYXRpdmVpbnRfb2Zfc2V4cCIsInJlZl9vZl9zZXhwIiwiYV9vZl9zZXhwIiwibGF6eV90X29mX3NleHAiLCJvcHRpb25fb2Zfc2V4cCIsImVsIiwicGFpcl9vZl9zZXhwIiwiYl9vZl9zZXhwIiwiYl9zZXhwIiwiYV9zZXhwIiwidHJpcGxlX29mX3NleHAiLCJjX29mX3NleHAiLCJjX3NleHAiLCJsaXN0X29mX3NleHAiLCJhcnJheV9vZl9zZXhwIiwidCIsImgiLCJsZW4iLCJyZXMiLCJoYXNodGJsX29mX3NleHAiLCJrZXlfb2Zfc2V4cCIsInZhbF9vZl9zZXhwIiwiYWN0Iiwidl9zZXhwIiwia19zZXhwIiwib3BhcXVlX29mX3NleHAiLCJmdW5fb2Zfc2V4cCIsInNleHBfZ3JhbW1hcl93aXRoX3RhZ3MiLCJzZXhwX2dyYW1tYXJfd2l0aF90YWdfbGlzdCIsInVuaXRfc2V4cF9ncmFtbWFyIiwiYm9vbF9zZXhwX2dyYW1tYXIiLCJzdHJpbmdfc2V4cF9ncmFtbWFyIiwiYnl0ZXNfc2V4cF9ncmFtbWFyIiwiY2hhcl9zZXhwX2dyYW1tYXIiLCJpbnRfc2V4cF9ncmFtbWFyIiwiZmxvYXRfc2V4cF9ncmFtbWFyIiwiaW50MzJfc2V4cF9ncmFtbWFyIiwiaW50NjRfc2V4cF9ncmFtbWFyIiwibmF0aXZlaW50X3NleHBfZ3JhbW1hciIsInNleHBfdF9zZXhwX2dyYW1tYXIiLCJyZWZfc2V4cF9ncmFtbWFyIiwibGF6eV90X3NleHBfZ3JhbW1hciIsIm9wdGlvbl9zZXhwX2dyYW1tYXIiLCJsaXN0X3NleHBfZ3JhbW1hciIsImFycmF5X3NleHBfZ3JhbW1hciIsIm9wYXF1ZV9zZXhwX2dyYW1tYXIiLCJmdW5fc2V4cF9ncmFtbWFyIiwiZ2V0X2ZsY19lcnJvciIsIm5hbWUiLCJjaHIiLCJsaW5lIiwiZmlsZSIsImNzdF9NYXRjaF9mYWlsdXJlIiwiaGFuZGxlciIsInRhZyIsImFyZyIsIlNleHBsaWIwX1NleHBfY29udiJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyx1QkFBQTtBQUFBLElBQUFDLFdBQUE7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UjtBQUFBLHVCQUFZO0FBQUE7QUFBQTtBQUFBLFFBQ3RCO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FJSDtBQUFBO0FBQUEsY0FBQUE7QUFBQUEsVUFBQStKLFVBQ0ssVUFBQS9HLHdCQUFBO0FBQUEsTUFDRCxnREFBK0U7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBaEQ7QUFBQUEsWUFBQWdLLE1BRTdFO0FBQUE7QUFBQSxTQUdPO0FBQUEsWUFBQXRHLE9BSFAsVUFBQW9DLE1BQUE7QUFBQSxRQUU0Qyx1REFBZTtBQUFBLE9BQ3hDO0FBQUE7QUFBQTtBQUFBLElBQUFvRTtBQUFBQSxNQUN0QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVEdFpMIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTUxNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzZXhwbGliMC5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2ZhYmlhbi8ub3BhbS9kZWZhdWx0L2xpYi9zZXhwbGliMC9zZXhwX2NvbnZfZXJyb3IubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBDb252X2Vycm9yOiBNb2R1bGUgZm9yIEhhbmRsaW5nIEVycm9ycyBkdXJpbmcgQXV0b21hdGVkIFMtZXhwcmVzc2lvblxuICAgQ29udmVyc2lvbnMgKilcblxub3BlbiBTdGRMYWJlbHNcbm9wZW4gUHJpbnRmXG5vcGVuIFNleHBfY29udlxuXG5leGNlcHRpb24gT2Zfc2V4cF9lcnJvciA9IE9mX3NleHBfZXJyb3JcblxubGV0IGVycm9yIH5sb2MgfnNleHAgbXNnID0gb2Zfc2V4cF9lcnJvciAoc3ByaW50ZiBcIiVzX29mX3NleHA6ICVzXCIgbG9jIG1zZykgc2V4cFxubGV0IHNpbXBsZV9lcnJvciBtc2cgbG9jIHNleHAgPSBlcnJvciB+bG9jIH5zZXhwIG1zZ1xuXG4oKiBFcnJvcnMgY29uY2VybmluZyB0dXBsZXMgKilcblxubGV0IHR1cGxlX29mX3NpemVfbl9leHBlY3RlZCBsb2MgbiBzZXhwID1cbiAgZXJyb3IgfmxvYyB+c2V4cCAoc3ByaW50ZiBcInR1cGxlIG9mIHNpemUgJWQgZXhwZWN0ZWRcIiBuKVxuOztcblxubGV0IHR1cGxlX3BhaXJfZXhwZWN0ZWQgbG9jIG5hbWUgc2V4cCA9XG4gIGxldCBtc2cgPSBzcHJpbnRmIFwiJXNfb2Zfc2V4cDogZXhwZWN0ZWQgYSBwYWlyIGJlZ2lubmluZyB3aXRoIGxhYmVsICVzXCIgbG9jIG5hbWUgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxubGV0IHR1cGxlX2luY29ycmVjdF9sYWJlbCBsb2MgbmFtZSBwb3Mgc2V4cCA9XG4gIGxldCBtc2cgPVxuICAgIHNwcmludGYgXCIlc19vZl9zZXhwOiBpbmNvcnJlY3QgbGFiZWwgZm9yIGVsZW1lbnQgJXMgYXQgcG9zaXRpb24gJWlcIiBsb2MgbmFtZSBwb3NcbiAgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxuKCogRXJyb3JzIGNvbmNlcm5pbmcgc3VtIHR5cGVzICopXG5cbmxldCBzdGFnX25vX2FyZ3MgPSBzaW1wbGVfZXJyb3IgXCJ0aGlzIGNvbnN0cnVjdG9yIGRvZXMgbm90IHRha2UgYXJndW1lbnRzXCJcblxubGV0IHN0YWdfaW5jb3JyZWN0X25fYXJncyBsb2MgdGFnIHNleHAgPVxuICBlcnJvciB+bG9jIH5zZXhwIChzcHJpbnRmIFwic3VtIHRhZyAlUyBoYXMgaW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHNcIiB0YWcpXG47O1xuXG5sZXQgc3RhZ190YWtlc19hcmdzID0gc2ltcGxlX2Vycm9yIFwidGhpcyBjb25zdHJ1Y3RvciByZXF1aXJlcyBhcmd1bWVudHNcIlxubGV0IG5lc3RlZF9saXN0X2ludmFsaWRfc3VtID0gc2ltcGxlX2Vycm9yIFwiZXhwZWN0ZWQgYSB2YXJpYW50IHR5cGUsIHNhdyBhIG5lc3RlZCBsaXN0XCJcbmxldCBlbXB0eV9saXN0X2ludmFsaWRfc3VtID0gc2ltcGxlX2Vycm9yIFwiZXhwZWN0ZWQgYSB2YXJpYW50IHR5cGUsIHNhdyBhbiBlbXB0eSBsaXN0XCJcbmxldCB1bmV4cGVjdGVkX3N0YWcgPSBzaW1wbGVfZXJyb3IgXCJ1bmV4cGVjdGVkIHZhcmlhbnQgY29uc3RydWN0b3JcIlxuXG4oKiBFcnJvcnMgY29uY2VybmluZyByZWNvcmRzICopXG5cbmxldCByZWNvcmRfc2V4cF9ib29sX3dpdGhfcGF5bG9hZCA9XG4gIHNpbXBsZV9lcnJvciBcInJlY29yZCBjb252ZXJzaW9uOiBhIFtzZXhwLmJvb2xdIGZpZWxkIHdhcyBnaXZlbiBhIHBheWxvYWQuXCJcbjs7XG5cbmxldCByZWNvcmRfb25seV9wYWlyc19leHBlY3RlZCA9XG4gIHNpbXBsZV9lcnJvclxuICAgIFwicmVjb3JkIGNvbnZlcnNpb246IG9ubHkgcGFpcnMgZXhwZWN0ZWQsIHRoZWlyIGZpcnN0IGVsZW1lbnQgbXVzdCBiZSBhbiBhdG9tXCJcbjs7XG5cbmxldCByZWNvcmRfaW52YWxpZF9maWVsZHMgfndoYXQgfmxvYyBmbGRfbmFtZXMgc2V4cCA9XG4gIGxldCBmbGRfbmFtZXNfc3RyID0gU3RyaW5nLmNvbmNhdCBmbGRfbmFtZXMgfnNlcDpcIiBcIiBpblxuICBlcnJvciB+bG9jIH5zZXhwIChzcHJpbnRmIFwiJXM6ICVzXCIgd2hhdCBmbGRfbmFtZXNfc3RyKVxuOztcblxubGV0IHJlY29yZF9kdXBsaWNhdGVfZmllbGRzIGxvYyBmbGRfbmFtZXMgc2V4cCA9XG4gIHJlY29yZF9pbnZhbGlkX2ZpZWxkcyB+d2hhdDpcImR1cGxpY2F0ZSBmaWVsZHNcIiB+bG9jIGZsZF9uYW1lcyBzZXhwXG47O1xuXG5sZXQgcmVjb3JkX2V4dHJhX2ZpZWxkcyBsb2MgZmxkX25hbWVzIHNleHAgPVxuICByZWNvcmRfaW52YWxpZF9maWVsZHMgfndoYXQ6XCJleHRyYSBmaWVsZHNcIiB+bG9jIGZsZF9uYW1lcyBzZXhwXG47O1xuXG5sZXQgcmVjIHJlY29yZF9nZXRfdW5kZWZpbmVkX2xvb3AgZmllbGRzID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBTdHJpbmcuY29uY2F0IChMaXN0LnJldiBmaWVsZHMpIH5zZXA6XCIgXCJcbiAgfCAodHJ1ZSwgZmllbGQpIDo6IHJlc3QgLT4gcmVjb3JkX2dldF91bmRlZmluZWRfbG9vcCAoZmllbGQgOjogZmllbGRzKSByZXN0XG4gIHwgXyA6OiByZXN0IC0+IHJlY29yZF9nZXRfdW5kZWZpbmVkX2xvb3AgZmllbGRzIHJlc3Rcbjs7XG5cbmxldCByZWNvcmRfdW5kZWZpbmVkX2VsZW1lbnRzIGxvYyBzZXhwIGxzdCA9XG4gIGxldCB1bmRlZmluZWQgPSByZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIFtdIGxzdCBpblxuICBsZXQgbXNnID0gc3ByaW50ZiBcInRoZSBmb2xsb3dpbmcgcmVjb3JkIGVsZW1lbnRzIHdlcmUgdW5kZWZpbmVkOiAlc1wiIHVuZGVmaW5lZCBpblxuICBlcnJvciB+bG9jIH5zZXhwIG1zZ1xuOztcblxubGV0IHJlY29yZF9saXN0X2luc3RlYWRfYXRvbSA9IHNpbXBsZV9lcnJvciBcImxpc3QgaW5zdGVhZCBvZiBhdG9tIGZvciByZWNvcmQgZXhwZWN0ZWRcIlxuXG5sZXQgcmVjb3JkX3BvbHlfZmllbGRfdmFsdWUgPVxuICBzaW1wbGVfZXJyb3IgXCJjYW5ub3QgY29udmVydCB2YWx1ZXMgb2YgdHlwZXMgcmVzdWx0aW5nIGZyb20gcG9seW1vcnBoaWMgcmVjb3JkIGZpZWxkc1wiXG47O1xuXG4oKiBFcnJvcnMgY29uY2VybmluZyBwb2x5bW9ycGhpYyB2YXJpYW50cyAqKVxuXG5leGNlcHRpb24gTm9fdmFyaWFudF9tYXRjaFxuXG5sZXQgbm9fdmFyaWFudF9tYXRjaCAoKSA9IHJhaXNlIE5vX3ZhcmlhbnRfbWF0Y2hcbmxldCBub19tYXRjaGluZ192YXJpYW50X2ZvdW5kID0gc2ltcGxlX2Vycm9yIFwibm8gbWF0Y2hpbmcgdmFyaWFudCBmb3VuZFwiXG5sZXQgcHRhZ19ub19hcmdzID0gc2ltcGxlX2Vycm9yIFwicG9seW1vcnBoaWMgdmFyaWFudCBkb2VzIG5vdCB0YWtlIGFyZ3VtZW50c1wiXG5cbmxldCBwdGFnX2luY29ycmVjdF9uX2FyZ3MgbG9jIGNuc3RyIHNleHAgPVxuICBlcnJvclxuICAgIH5sb2NcbiAgICB+c2V4cFxuICAgIChzcHJpbnRmIFwicG9seW1vcnBoaWMgdmFyaWFudCB0YWcgJVMgaGFzIGluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzXCIgY25zdHIpXG47O1xuXG5sZXQgcHRhZ190YWtlc19hcmdzID0gc2ltcGxlX2Vycm9yIFwicG9seW1vcnBoaWMgdmFyaWFudCB0YWcgdGFrZXMgYW4gYXJndW1lbnRcIlxuXG5sZXQgbmVzdGVkX2xpc3RfaW52YWxpZF9wb2x5X3ZhciA9XG4gIHNpbXBsZV9lcnJvciBcImEgbmVzdGVkIGxpc3QgaXMgYW4gaW52YWxpZCBwb2x5bW9ycGhpYyB2YXJpYW50XCJcbjs7XG5cbmxldCBlbXB0eV9saXN0X2ludmFsaWRfcG9seV92YXIgPVxuICBzaW1wbGVfZXJyb3IgXCJ0aGUgZW1wdHkgbGlzdCBpcyBhbiBpbnZhbGlkIHBvbHltb3JwaGljIHZhcmlhbnRcIlxuOztcblxubGV0IGVtcHR5X3R5cGUgPSBzaW1wbGVfZXJyb3IgXCJ0cnlpbmcgdG8gY29udmVydCBhbiBlbXB0eSB0eXBlXCJcbiJdLCJuYW1lcyI6WyJydW50aW1lIiwiY3N0IiwiY3N0X2hhc19pbmNvcnJlY3RfbnVtYmVyX29mX2FyIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImdsb2JhbF9kYXRhIiwibXNnIiwiU3RkbGliX0xpc3RMYWJlbHMiLCJTdGRsaWJfU3RyaW5nTGFiZWxzIiwiU3RkbGliX1ByaW50ZiIsIlNleHBsaWIwX1NleHBfY29udiIsIk9mX3NleHBfZXJyb3IiLCJjc3RfZHVwbGljYXRlX2ZpZWxkcyIsImNzdF9leHRyYV9maWVsZHMiLCJlcnJvciIsImxvYyIsInNleHAiLCJzaW1wbGVfZXJyb3IiLCJ0dXBsZV9vZl9zaXplX25fZXhwZWN0ZWQiLCJuIiwidHVwbGVfcGFpcl9leHBlY3RlZCIsIm5hbWUiLCJ0dXBsZV9pbmNvcnJlY3RfbGFiZWwiLCJwb3MiLCJzdGFnX25vX2FyZ3MiLCJzdGFnX2luY29ycmVjdF9uX2FyZ3MiLCJ0YWciLCJzdGFnX3Rha2VzX2FyZ3MiLCJuZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSIsImVtcHR5X2xpc3RfaW52YWxpZF9zdW0iLCJ1bmV4cGVjdGVkX3N0YWciLCJyZWNvcmRfc2V4cF9ib29sX3dpdGhfcGF5bG9hZCIsInJlY29yZF9vbmx5X3BhaXJzX2V4cGVjdGVkIiwicmVjb3JkX2ludmFsaWRfZmllbGRzIiwid2hhdCIsImZsZF9uYW1lcyIsImZsZF9uYW1lc19zdHIiLCJyZWNvcmRfZHVwbGljYXRlX2ZpZWxkcyIsInJlY29yZF9leHRyYV9maWVsZHMiLCJyZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIiwiZmllbGRzIiwicGFyYW0iLCJyZXN0IiwiZmllbGQiLCJyZWNvcmRfdW5kZWZpbmVkX2VsZW1lbnRzIiwibHN0IiwidW5kZWZpbmVkJCIsInJlY29yZF9saXN0X2luc3RlYWRfYXRvbSIsInJlY29yZF9wb2x5X2ZpZWxkX3ZhbHVlIiwiTm9fdmFyaWFudF9tYXRjaCIsIm5vX3ZhcmlhbnRfbWF0Y2giLCJub19tYXRjaGluZ192YXJpYW50X2ZvdW5kIiwicHRhZ19ub19hcmdzIiwicHRhZ19pbmNvcnJlY3Rfbl9hcmdzIiwiY25zdHIiLCJwdGFnX3Rha2VzX2FyZ3MiLCJuZXN0ZWRfbGlzdF9pbnZhbGlkX3BvbHlfdmFyIiwiZW1wdHlfbGlzdF9pbnZhbGlkX3BvbHlfdmFyIiwiZW1wdHlfdHlwZSIsIlNleHBsaWIwX1NleHBfY29udl9lcnJvciJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsaUNBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUosR0FBQUMsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFOLEdBQUFDLElBQUFFLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBWixRQUFBO0FBQUEsSUFBQUEsTUFBQTtBQUFBLElBQUFhLE1BQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLElBQUFBO0FBQUFBLE1BQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUE7QUFBQUEsTUFBQTtBQUFBLElBQUFBLFFBQUE7QUFBQSxJQUFBQSxRQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElBQUFBLFNBQUE7QUFBQSxJQUFBQSxTQUFBO0FBQUEsSUFBQUEsU0FBQTtBQUFBLElB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QUFBMUMsS0FBQUMsTUFBQTtBQUFBO0FBQUEsWUFBQTBDLFdBQUEzQyxLQUFBQyxNQUFBO0FBQUE7QUFBQSxJQUFBMkM7QUFBQUEsTUFvRytCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUQ5Ry9EIiwiaWdub3JlTGlzdCI6WzBdfX0seyJvZmZzZXQiOnsibGluZSI6MTczMiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsImZpbGUiOiJzZXhwbGliMC5jbWEuanMiLCJzb3VyY2VzIjpbIi9idWlsdGluL2JsYWNrYm94Lm1sIiwiL1VzZXJzL2ZhYmlhbi8ub3BhbS9kZWZhdWx0L2xpYi9zZXhwbGliMC9zZXhwX2NvbnZfbGFiZWxlZF90dXBsZS5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm1vZHVsZSBGaWVsZHMgPSBzdHJ1Y3RcbiAgdHlwZSBfIHQgPVxuICAgIHwgRmllbGQgOlxuICAgICAgICB7IG5hbWUgOiBzdHJpbmdcbiAgICAgICAgOyBjb252IDogU2V4cC50IC0+ICdhXG4gICAgICAgIDsgcmVzdCA6ICdiIHRcbiAgICAgICAgfVxuICAgICAgICAtPiAoJ2EgKiAnYikgdFxuICAgIHwgRW1wdHkgOiB1bml0IHRcblxuICBsZXQgcmVjIGxlbmd0aF9sb29wIDogdHlwZSBhLiBhIHQgLT4gaW50IC0+IGludCA9XG4gICAgZnVuIHQgYWNjIC0+XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBhY2NcbiAgICB8IEZpZWxkIGZpZWxkIC0+IGxlbmd0aF9sb29wIGZpZWxkLnJlc3QgKGFjYyArIDEpXG4gIDs7XG5cbiAgbGV0IGxlbmd0aCB0ID0gbGVuZ3RoX2xvb3AgdCAwXG5lbmRcblxubGV0W0B0YWlsX21vZF9jb25zXSByZWMgb2ZfbGlzdFxuICA6IHR5cGUgYS5cbiAgICBjYWxsZXI6c3RyaW5nXG4gICAgLT4gZmllbGRzOmEgRmllbGRzLnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gb3JpZ2luYWxfc2V4cDpTZXhwLnRcbiAgICAtPiBwb3M6aW50XG4gICAgLT4gU2V4cC50IGxpc3RcbiAgICAtPiBhXG4gID1cbiAgZnVuIH5jYWxsZXIgfmZpZWxkcyB+bGVuIH5vcmlnaW5hbF9zZXhwIH5wb3MgbGlzdCAtPlxuICBtYXRjaCBmaWVsZHMgd2l0aFxuICB8IEVtcHR5IC0+XG4gICAgKG1hdGNoIGxpc3Qgd2l0aFxuICAgICB8IFtdIC0+ICgpXG4gICAgIHwgXyA6OiBfIC0+IFNleHBfY29udl9lcnJvci50dXBsZV9vZl9zaXplX25fZXhwZWN0ZWQgY2FsbGVyIGxlbiBvcmlnaW5hbF9zZXhwKVxuICB8IEZpZWxkIHsgbmFtZTsgY29udjsgcmVzdCB9IC0+XG4gICAgKG1hdGNoIGxpc3Qgd2l0aFxuICAgICB8IFtdIC0+IFNleHBfY29udl9lcnJvci50dXBsZV9vZl9zaXplX25fZXhwZWN0ZWQgY2FsbGVyIGxlbiBvcmlnaW5hbF9zZXhwXG4gICAgIHwgc2V4cCA6OiBsaXN0IC0+XG4gICAgICAgKG1hdGNoIHNleHAgd2l0aFxuICAgICAgICB8IExpc3QgWyBBdG9tIGF0b207IHNleHAgXSAtPlxuICAgICAgICAgIGlmIFN0cmluZy5lcXVhbCBhdG9tIG5hbWVcbiAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAoIGNvbnYgc2V4cFxuICAgICAgICAgICAgLCBvZl9saXN0IH5jYWxsZXIgfmZpZWxkczpyZXN0IH5sZW4gfm9yaWdpbmFsX3NleHAgfnBvczoocG9zICsgMSkgbGlzdCApXG4gICAgICAgICAgZWxzZSBTZXhwX2NvbnZfZXJyb3IudHVwbGVfaW5jb3JyZWN0X2xhYmVsIGNhbGxlciBuYW1lIHBvcyBvcmlnaW5hbF9zZXhwXG4gICAgICAgIHwgXyAtPiBTZXhwX2NvbnZfZXJyb3IudHVwbGVfcGFpcl9leHBlY3RlZCBjYWxsZXIgbmFtZSBzZXhwKSlcbjs7XG5cbmxldCBsYWJlbGVkX3R1cGxlX29mX3NleHAgfmNhbGxlciB+ZmllbGRzIH5jcmVhdGUgb3JpZ2luYWxfc2V4cCA9XG4gIGxldCBsZW4gPSBGaWVsZHMubGVuZ3RoIGZpZWxkcyBpblxuICBtYXRjaCAob3JpZ2luYWxfc2V4cCA6IFNleHAudCkgd2l0aFxuICB8IEF0b20gXyAtPiBTZXhwX2NvbnZfZXJyb3IudHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkIGNhbGxlciBsZW4gb3JpZ2luYWxfc2V4cFxuICB8IExpc3QgbGlzdCAtPiBjcmVhdGUgKG9mX2xpc3QgfmNhbGxlciB+ZmllbGRzIH5sZW4gfm9yaWdpbmFsX3NleHAgfnBvczowIGxpc3QpXG47O1xuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX2NhbGwxIiwiZiIsImEwIiwiY2FtbF9jYWxsMiIsImExIiwiZ2xvYmFsX2RhdGEiLCJTdGRsaWJfU3RyaW5nIiwiU2V4cGxpYjBfU2V4cF9jb252X2Vycm9yIiwibGFiZWxlZF90dXBsZV9vZl9zZXhwIiwiY2FsbGVyIiwiZmllbGRzIiwiY3JlYXRlIiwib3JpZ2luYWxfc2V4cCIsInQiLCJhY2MiLCJsaXN0IiwicG9zIiwiY29udiIsIm5hbWUiLCJzZXhwIiwiYXRvbSIsImJsb2NrIiwiZHN0Iiwib2Zmc2V0IiwiU2V4cGxpYjBfU2V4cF9jb252X2xhYmVsZWRfdHVwIl0sIm1hcHBpbmdzIjoiT0FBQUEsVUFBQTtBQUFBLFlBQUFDLFdBQUFDLEdBQUFDO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBRixHQUFBQyxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFBQyxjQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLFlBQUFDLHNCQUFBQyxRQUFBQyxVQUFBQyxRQUFBQztBQUFBQSxRQUFBQyxJQ2lCaUIsVUFBQUMsTUFBQTtBQUFBO0FBQUEsS0FMYjtBQUFBLFNBQUFBLFFBRWlCLGFBQUFELE1BQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQXNDbkI7QUFBQSxLQUNZLHlFQUNtRTtBQUFBLFFBQUFFLFNBRi9FO0FBQUE7QUFBQTtBQUFBLFNBQUFDLFFBckJBO0FBQUE7QUFBQSxVQUFBTixTQUFBLGFBQUFPLE9BQUEsYUFBQUMsT0FBQTtBQUFBLE1BTUU7QUFBQSxXQUFBSCxPQUFBLFdBQUFJLE9BQUE7QUFBQSxPQUdHO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFBQUEsU0FBQSxNQUFBQyxPQUFBO0FBQUEsV0FFTTtBQUFBO0FBQUE7QUFBQSxlQUlFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxRQUZEO0FBQUEsWUFBQUMsTUFDQTtBQUFBLFlBQUFDLFNBQUE7QUFBQSxZQUFBYixXQUFBO0FBQUEsWUFBQU0sTUFBQTtBQUFBLFlBQUFELFNBQUE7QUFBQTtBQUFBLFlBZFo7QUFBQSxhQUVFO0FBQUEsY0FFYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQURKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQUFBTCxXQUhYO0FBQUEsYUFBQU8sU0FBQTtBQUFBLGFBQUFDLFNBQUE7QUFBQSxZQU1FO0FBQUEsYUFDUztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFBQUgsU0FEVCxXQUFBSSxTQUFBO0FBQUEsWUFHRztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG9CQUFBQSxTQUFBLE1BQUFDLFNBQUE7QUFBQSxnQkFFTTtBQUFBLHFCQUFBRSxRQUVDO0FBQUEsaUJBQVM7QUFBQSxxQkFBQU4sUUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBRVI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBVEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBTFQ7QUFBQSxZQUVhO0FBQUE7QUFBQTtBQUFBLElBbUJnRTtBQUFBO0FBQUEsT0FBQVEsaUNEdERqRiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjE4NzgsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V4cGxpYjAuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCIsIi9Vc2Vycy9mYWJpYW4vLm9wYW0vZGVmYXVsdC9saWIvc2V4cGxpYjAvc2V4cF9jb252X3JlY29yZC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSIsIm9wZW4hIFN0ZExhYmVsc1xub3BlbiEgU2V4cF9jb252XG5vcGVuISBTZXhwX2NvbnZfZXJyb3JcblxubW9kdWxlIEtpbmQgPSBzdHJ1Y3RcbiAgdHlwZSAoXywgXykgdCA9XG4gICAgfCBEZWZhdWx0IDogKHVuaXQgLT4gJ2EpIC0+ICgnYSwgU2V4cC50IC0+ICdhKSB0XG4gICAgfCBPbWl0X25pbCA6ICgnYSwgU2V4cC50IC0+ICdhKSB0XG4gICAgfCBSZXF1aXJlZCA6ICgnYSwgU2V4cC50IC0+ICdhKSB0XG4gICAgfCBTZXhwX2FycmF5IDogKCdhIGFycmF5LCBTZXhwLnQgLT4gJ2EpIHRcbiAgICB8IFNleHBfYm9vbCA6IChib29sLCB1bml0KSB0XG4gICAgfCBTZXhwX2xpc3QgOiAoJ2EgbGlzdCwgU2V4cC50IC0+ICdhKSB0XG4gICAgfCBTZXhwX29wdGlvbiA6ICgnYSBvcHRpb24sIFNleHAudCAtPiAnYSkgdFxuZW5kXG5cbm1vZHVsZSBGaWVsZHMgPSBzdHJ1Y3RcbiAgdHlwZSBfIHQgPVxuICAgIHwgRW1wdHkgOiB1bml0IHRcbiAgICB8IEZpZWxkIDpcbiAgICAgICAgeyBuYW1lIDogc3RyaW5nXG4gICAgICAgIDsga2luZCA6ICgnYSwgJ2NvbnYpIEtpbmQudFxuICAgICAgICA7IGNvbnYgOiAnY29udlxuICAgICAgICA7IHJlc3QgOiAnYiB0XG4gICAgICAgIH1cbiAgICAgICAgLT4gKCdhICogJ2IpIHRcblxuICBsZXQgbGVuZ3RoID1cbiAgICBsZXQgcmVjIGxlbmd0aF9sb29wIDogdHlwZSBhLiBhIHQgLT4gaW50IC0+IGludCA9XG4gICAgICBmdW4gdCBhY2MgLT5cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBGaWVsZCB7IHJlc3Q7IF8gfSAtPiBsZW5ndGhfbG9vcCByZXN0IChhY2MgKyAxKVxuICAgICAgfCBFbXB0eSAtPiBhY2NcbiAgICBpblxuICAgIGZ1biB0IC0+IGxlbmd0aF9sb29wIHQgMFxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWxmb3JtZWQgPSBzdHJ1Y3RcbiAgKCogUmVwcmVzZW50cyBlcnJvcnMgdGhhdCBjYW4gb2NjdXIgZHVlIHRvIG1hbGZvcm1lZCByZWNvcmQgc2V4cHMuIEFjY3VtdWxhdGVkIGFzIGFcbiAgICAgdmFsdWUgc28gd2UgY2FuIHJlcG9ydCBtdWx0aXBsZSBuYW1lcyBhdCBvbmNlIGZvciBleHRyYSBmaWVsZHMsIGR1cGxpY2F0ZSBmaWVsZHMsIG9yXG4gICAgIG1pc3NpbmcgZmllbGRzLiAqKVxuICB0eXBlIHQgPVxuICAgIHwgQm9vbF9wYXlsb2FkXG4gICAgfCBFeHRyYXMgb2Ygc3RyaW5nIGxpc3RcbiAgICB8IER1cHMgb2Ygc3RyaW5nIGxpc3RcbiAgICB8IE1pc3Npbmcgb2Ygc3RyaW5nIGxpc3RcbiAgICB8IE5vbl9wYWlyIG9mIFNleHAudCBvcHRpb25cblxuICBsZXQgY29tYmluZSBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgICgqIGNob29zZSB0aGUgZmlyc3QgYm9vbC1wYXlsb2FkIG9yIG5vbi1wYWlyIGVycm9yIHRoYXQgb2NjdXJzICopXG4gICAgfCAoKEJvb2xfcGF5bG9hZCB8IE5vbl9wYWlyIF8pIGFzIHQpLCBfIC0+IHRcbiAgICB8IF8sICgoQm9vbF9wYXlsb2FkIHwgTm9uX3BhaXIgXykgYXMgdCkgLT4gdFxuICAgICgqIGNvbWJpbmUgbGlzdHMgb2Ygc2ltaWxhciBlcnJvcnMgKilcbiAgICB8IEV4dHJhcyBhLCBFeHRyYXMgYiAtPiBFeHRyYXMgKGEgQCBiKVxuICAgIHwgRHVwcyBhLCBEdXBzIGIgLT4gRHVwcyAoYSBAIGIpXG4gICAgfCBNaXNzaW5nIGEsIE1pc3NpbmcgYiAtPiBNaXNzaW5nIChhIEAgYilcbiAgICAoKiBvdGhlcndpc2UsIGR1cHMgPiBleHRyYXMgPiBtaXNzaW5nICopXG4gICAgfCAoRHVwcyBfIGFzIHQpLCBfIHwgXywgKER1cHMgXyBhcyB0KSAtPiB0XG4gICAgfCAoRXh0cmFzIF8gYXMgdCksIF8gfCBfLCAoRXh0cmFzIF8gYXMgdCkgLT4gdFxuICA7O1xuXG4gIGxldCByYWlzZSB0IH5jYWxsZXIgfmNvbnRleHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgQm9vbF9wYXlsb2FkIC0+IHJlY29yZF9zZXhwX2Jvb2xfd2l0aF9wYXlsb2FkIGNhbGxlciBjb250ZXh0XG4gICAgfCBFeHRyYXMgbmFtZXMgLT4gcmVjb3JkX2V4dHJhX2ZpZWxkcyBjYWxsZXIgbmFtZXMgY29udGV4dFxuICAgIHwgRHVwcyBuYW1lcyAtPiByZWNvcmRfZHVwbGljYXRlX2ZpZWxkcyBjYWxsZXIgbmFtZXMgY29udGV4dFxuICAgIHwgTWlzc2luZyBuYW1lcyAtPlxuICAgICAgTGlzdC5tYXAgbmFtZXMgfmY6KGZ1biBuYW1lIC0+IHRydWUsIG5hbWUpXG4gICAgICB8PiByZWNvcmRfdW5kZWZpbmVkX2VsZW1lbnRzIGNhbGxlciBjb250ZXh0XG4gICAgfCBOb25fcGFpciBtYXliZV9jb250ZXh0IC0+XG4gICAgICBsZXQgY29udGV4dCA9IE9wdGlvbi52YWx1ZSBtYXliZV9jb250ZXh0IH5kZWZhdWx0OmNvbnRleHQgaW5cbiAgICAgIHJlY29yZF9vbmx5X3BhaXJzX2V4cGVjdGVkIGNhbGxlciBjb250ZXh0XG4gIDs7XG5lbmRcblxuZXhjZXB0aW9uIE1hbGZvcm1lZCBvZiBNYWxmb3JtZWQudFxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgKCogU3RvcmVzIHNleHBzIGNvcnJlc3BvbmRpbmcgdG8gcmVjb3JkIGZpZWxkcywgaW4gdGhlIG9yZGVyIHRoZSBmaWVsZHMgd2VyZSBkZWNsYXJlZC5cbiAgICAgRXhjbHVkZXMgZmllbGRzIGFscmVhZHkgcGFyc2VkIGluIHRoZSBmYXN0IHBhdGguXG5cbiAgICAgTGlzdCBzZXhwcyByZXByZXNlbnQgYSBmaWVsZCB0aGF0IGlzIHByZXNlbnQsIHN1Y2ggYXMgKHggMSkgZm9yIGEgZmllbGQgbmFtZWQgXCJ4XCIuXG4gICAgIEF0b20gc2V4cHMgcmVwcmVzZW50IGEgZmllbGQgdGhhdCBpcyBhYnNlbnQsIG9yIGF0IGxlYXN0IG5vdCB5ZXQgc2Vlbi4gKilcbiAgdHlwZSB0ID0geyBzdGF0ZSA6IFNleHAudCBhcnJheSB9IFtAQHVuYm94ZWRdXG5cbiAgbGV0IHVuc2FmZV9nZXQgdCBwb3MgPSBBcnJheS51bnNhZmVfZ2V0IHQuc3RhdGUgcG9zXG4gIGxldCB1bnNhZmVfc2V0IHQgcG9zIHNleHAgPSBBcnJheS51bnNhZmVfc2V0IHQuc3RhdGUgcG9zIHNleHBcbiAgbGV0IGFic2VudCA9IFNleHAuQXRvbSBcIlwiXG4gIGxldCBjcmVhdGUgbGVuID0geyBzdGF0ZSA9IEFycmF5Lm1ha2UgbGVuIGFic2VudCB9XG5lbmRcblxuKCogUGFyc2luZyBmaWVsZCB2YWx1ZXMgZnJvbSBzdGF0ZS4gKilcblxubGV0IHJlYyBwYXJzZV92YWx1ZV9tYWxmb3JtZWRcbiAgOiB0eXBlIGEgYi4gTWFsZm9ybWVkLnQgLT4gZmllbGRzOihhICogYikgRmllbGRzLnQgLT4gc3RhdGU6U3RhdGUudCAtPiBwb3M6aW50IC0+IGFcbiAgPVxuICBmdW4gbWFsZm9ybWVkIH5maWVsZHMgfnN0YXRlIH5wb3MgLT5cbiAgbGV0IChGaWVsZCBmaWVsZCkgPSBmaWVsZHMgaW5cbiAgbGV0IG1hbGZvcm1lZCA9XG4gICAgbWF0Y2ggcGFyc2VfdmFsdWVzIH5maWVsZHM6ZmllbGQucmVzdCB+c3RhdGUgfnBvczoocG9zICsgMSkgd2l0aFxuICAgIHwgKF8gOiBiKSAtPiBtYWxmb3JtZWRcbiAgICB8IGV4Y2VwdGlvbiBNYWxmb3JtZWQgb3RoZXIgLT4gTWFsZm9ybWVkLmNvbWJpbmUgbWFsZm9ybWVkIG90aGVyXG4gIGluXG4gIHJhaXNlIChNYWxmb3JtZWQgbWFsZm9ybWVkKVxuXG5hbmQgcGFyc2VfdmFsdWUgOiB0eXBlIGEgYi4gZmllbGRzOihhICogYikgRmllbGRzLnQgLT4gc3RhdGU6U3RhdGUudCAtPiBwb3M6aW50IC0+IGEgKiBiID1cbiAgZnVuIH5maWVsZHMgfnN0YXRlIH5wb3MgLT5cbiAgbGV0IChGaWVsZCB7IG5hbWU7IGtpbmQ7IGNvbnY7IHJlc3QgfSkgPSBmaWVsZHMgaW5cbiAgbGV0IHZhbHVlIDogYSA9XG4gICAgbWF0Y2gga2luZCwgU3RhdGUudW5zYWZlX2dldCBzdGF0ZSBwb3Mgd2l0aFxuICAgICgqIHdlbGwtZm9ybWVkICopXG4gICAgfCBSZXF1aXJlZCwgTGlzdCBbIF87IHNleHAgXSAtPiBjb252IHNleHBcbiAgICB8IERlZmF1bHQgXywgTGlzdCBbIF87IHNleHAgXSAtPiBjb252IHNleHBcbiAgICB8IE9taXRfbmlsLCBMaXN0IFsgXzsgc2V4cCBdIC0+IGNvbnYgc2V4cFxuICAgIHwgU2V4cF9vcHRpb24sIExpc3QgWyBfOyBzZXhwIF0gLT4gU29tZSAoY29udiBzZXhwKVxuICAgIHwgU2V4cF9saXN0LCBMaXN0IFsgXzsgc2V4cCBdIC0+IGxpc3Rfb2Zfc2V4cCBjb252IHNleHBcbiAgICB8IFNleHBfYXJyYXksIExpc3QgWyBfOyBzZXhwIF0gLT4gYXJyYXlfb2Zfc2V4cCBjb252IHNleHBcbiAgICB8IFNleHBfYm9vbCwgTGlzdCBbIF8gXSAtPiB0cnVlXG4gICAgKCogaWxsLWZvcm1lZCAqKVxuICAgIHwgKCAoUmVxdWlyZWQgfCBEZWZhdWx0IF8gfCBPbWl0X25pbCB8IFNleHBfb3B0aW9uIHwgU2V4cF9saXN0IHwgU2V4cF9hcnJheSlcbiAgICAgICwgKExpc3QgKF8gOjogXyA6OiBfIDo6IF8pIGFzIHNleHApICkgLT5cbiAgICAgIHBhcnNlX3ZhbHVlX21hbGZvcm1lZCAoTm9uX3BhaXIgKFNvbWUgc2V4cCkpIH5maWVsZHMgfnN0YXRlIH5wb3NcbiAgICB8ICggKFJlcXVpcmVkIHwgRGVmYXVsdCBfIHwgT21pdF9uaWwgfCBTZXhwX29wdGlvbiB8IFNleHBfbGlzdCB8IFNleHBfYXJyYXkpXG4gICAgICAsIExpc3QgKFtdIHwgWyBfIF0pICkgLT4gcGFyc2VfdmFsdWVfbWFsZm9ybWVkIChOb25fcGFpciBOb25lKSB+ZmllbGRzIH5zdGF0ZSB+cG9zXG4gICAgfCBTZXhwX2Jvb2wsIExpc3QgKFtdIHwgXyA6OiBfIDo6IF8pIC0+XG4gICAgICBwYXJzZV92YWx1ZV9tYWxmb3JtZWQgQm9vbF9wYXlsb2FkIH5maWVsZHMgfnN0YXRlIH5wb3NcbiAgICAoKiBhYnNlbnQgKilcbiAgICB8IFJlcXVpcmVkLCBBdG9tIF8gLT4gcGFyc2VfdmFsdWVfbWFsZm9ybWVkIChNaXNzaW5nIFsgbmFtZSBdKSB+ZmllbGRzIH5zdGF0ZSB+cG9zXG4gICAgfCBEZWZhdWx0IGRlZmF1bHQsIEF0b20gXyAtPiBkZWZhdWx0ICgpXG4gICAgfCBPbWl0X25pbCwgQXRvbSBfIC0+IGNvbnYgKExpc3QgW10pXG4gICAgfCBTZXhwX29wdGlvbiwgQXRvbSBfIC0+IE5vbmVcbiAgICB8IFNleHBfbGlzdCwgQXRvbSBfIC0+IFtdXG4gICAgfCBTZXhwX2FycmF5LCBBdG9tIF8gLT4gW3x8XVxuICAgIHwgU2V4cF9ib29sLCBBdG9tIF8gLT4gZmFsc2VcbiAgaW5cbiAgdmFsdWUsIHBhcnNlX3ZhbHVlcyB+ZmllbGRzOnJlc3QgfnN0YXRlIH5wb3M6KHBvcyArIDEpXG5cbmFuZCBwYXJzZV92YWx1ZXMgOiB0eXBlIGEuIGZpZWxkczphIEZpZWxkcy50IC0+IHN0YXRlOlN0YXRlLnQgLT4gcG9zOmludCAtPiBhID1cbiAgZnVuIH5maWVsZHMgfnN0YXRlIH5wb3MgLT5cbiAgbWF0Y2ggZmllbGRzIHdpdGhcbiAgfCBGaWVsZCBfIC0+IHBhcnNlX3ZhbHVlIH5maWVsZHMgfnN0YXRlIH5wb3NcbiAgfCBFbXB0eSAtPiAoKVxuOztcblxuKCogUG9wdWxhdGluZyBzdGF0ZS4gSGFuZGxlcyBzbG93IHBhdGggY2FzZXMgd2hlcmUgdGhlcmUgbWF5IGJlIHJlb3JkZXJlZCwgZHVwbGljYXRlZCxcbiAgIG1pc3NpbmcsIG9yIGV4dHJhIGZpZWxkcy4gKilcblxubGV0IHJlYyBwYXJzZV9zcGluZV9tYWxmb3JtZWQgbWFsZm9ybWVkIH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHMgPVxuICBsZXQgbWFsZm9ybWVkID1cbiAgICBtYXRjaCBwYXJzZV9zcGluZV9zbG93IH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHMgd2l0aFxuICAgIHwgKCkgLT4gbWFsZm9ybWVkXG4gICAgfCBleGNlcHRpb24gTWFsZm9ybWVkIG90aGVyIC0+IE1hbGZvcm1lZC5jb21iaW5lIG1hbGZvcm1lZCBvdGhlclxuICBpblxuICByYWlzZSAoTWFsZm9ybWVkIG1hbGZvcm1lZClcblxuYW5kIHBhcnNlX3NwaW5lX3Nsb3cgfmluZGV4IH5leHRyYSB+c2VlbiB+c3RhdGUgfmxlbiBzZXhwcyA9XG4gIG1hdGNoIChzZXhwcyA6IFNleHAudCBsaXN0KSB3aXRoXG4gIHwgW10gLT4gKClcbiAgfCAoTGlzdCAoQXRvbSBuYW1lIDo6IF8pIGFzIGZpZWxkKSA6OiBzZXhwcyAtPlxuICAgIGxldCBpID0gaW5kZXggbmFtZSBpblxuICAgIChtYXRjaCBzZWVuIDw9IGkgJiYgaSA8IGxlbiB3aXRoXG4gICAgIHwgdHJ1ZSAtPlxuICAgICAgICgqIHZhbGlkIGZpZWxkIGZvciBzbG93LXBhdGggcGFyc2luZyAqKVxuICAgICAgIGxldCBwb3MgPSBpIC0gc2VlbiBpblxuICAgICAgIChtYXRjaCBTdGF0ZS51bnNhZmVfZ2V0IHN0YXRlIHBvcyB3aXRoXG4gICAgICAgIHwgQXRvbSBfIC0+XG4gICAgICAgICAgKCogZmllbGQgbm90IHNlZW4geWV0ICopXG4gICAgICAgICAgU3RhdGUudW5zYWZlX3NldCBzdGF0ZSBwb3MgZmllbGQ7XG4gICAgICAgICAgcGFyc2Vfc3BpbmVfc2xvdyB+aW5kZXggfmV4dHJhIH5zZWVuIH5zdGF0ZSB+bGVuIHNleHBzXG4gICAgICAgIHwgTGlzdCBfIC0+XG4gICAgICAgICAgKCogZmllbGQgYWxyZWFkeSBzZWVuICopXG4gICAgICAgICAgcGFyc2Vfc3BpbmVfbWFsZm9ybWVkIChEdXBzIFsgbmFtZSBdKSB+aW5kZXggfmV4dHJhIH5zZWVuIH5zdGF0ZSB+bGVuIHNleHBzKVxuICAgICB8IGZhbHNlIC0+XG4gICAgICAgKG1hdGNoIDAgPD0gaSAmJiBpIDwgc2VlbiB3aXRoXG4gICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgICgqIGZpZWxkIHNlZW4gaW4gZmFzdCBwYXRoICopXG4gICAgICAgICAgcGFyc2Vfc3BpbmVfbWFsZm9ybWVkIChEdXBzIFsgbmFtZSBdKSB+aW5kZXggfmV4dHJhIH5zZWVuIH5zdGF0ZSB+bGVuIHNleHBzXG4gICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgICAoKiBleHRyYSBmaWVsZCAqKVxuICAgICAgICAgIChtYXRjaCBleHRyYSB3aXRoXG4gICAgICAgICAgIHwgdHJ1ZSAtPiBwYXJzZV9zcGluZV9zbG93IH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHNcbiAgICAgICAgICAgfCBmYWxzZSAtPlxuICAgICAgICAgICAgIHBhcnNlX3NwaW5lX21hbGZvcm1lZCAoRXh0cmFzIFsgbmFtZSBdKSB+aW5kZXggfmV4dHJhIH5zZWVuIH5zdGF0ZSB+bGVuIHNleHBzKSkpXG4gIHwgc2V4cCA6OiBzZXhwcyAtPlxuICAgIHBhcnNlX3NwaW5lX21hbGZvcm1lZCAoTm9uX3BhaXIgKFNvbWUgc2V4cCkpIH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHNcbjs7XG5cbigqIFNsb3cgcGF0aCBmb3IgcmVjb3JkIHBhcnNpbmcuIFVzZXMgc3RhdGUgdG8gc3RvcmUgZmllbGRzIGFzIHRoZXkgYXJlIGRpc2NvdmVyZWQuICopXG5cbmxldCBwYXJzZV9yZWNvcmRfc2xvdyB+ZmllbGRzIH5pbmRleCB+ZXh0cmEgfnNlZW4gc2V4cHMgPVxuICBsZXQgdW5zZWVuID0gRmllbGRzLmxlbmd0aCBmaWVsZHMgaW5cbiAgbGV0IHN0YXRlID0gU3RhdGUuY3JlYXRlIHVuc2VlbiBpblxuICBsZXQgbGVuID0gc2VlbiArIHVuc2VlbiBpblxuICAoKiBwb3B1bGF0ZSBzdGF0ZSAqKVxuICBwYXJzZV9zcGluZV9zbG93IH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHM7XG4gICgqIHBhcnNlIHZhbHVlcyBmcm9tIHN0YXRlICopXG4gIHBhcnNlX3ZhbHVlcyB+ZmllbGRzIH5zdGF0ZSB+cG9zOjBcbjs7XG5cbigqIEZhc3QgcGF0aCBmb3IgcmVjb3JkIHBhcnNpbmcuIERpcmVjdGx5IHBhcnNlcyBhbmQgcmV0dXJucyBmaWVsZHMgaW4gdGhlIG9yZGVyIHRoZXkgYXJlXG4gICBkZWNsYXJlZC4gRmFsbHMgYmFjayBvbiBzbG93IHBhdGggaWYgYW55IGZpZWxkcyBhcmUgYWJzZW50LCByZW9yZGVyZWQsIG9yIG1hbGZvcm1lZC4gKilcblxubGV0IHJlYyBwYXJzZV9maWVsZF9mYXN0XG4gIDogdHlwZSBhIGIuXG4gICAgZmllbGRzOihhICogYikgRmllbGRzLnRcbiAgICAtPiBpbmRleDooc3RyaW5nIC0+IGludClcbiAgICAtPiBleHRyYTpib29sXG4gICAgLT4gc2VlbjppbnRcbiAgICAtPiBTZXhwLnQgbGlzdFxuICAgIC0+IGEgKiBiXG4gID1cbiAgZnVuIH5maWVsZHMgfmluZGV4IH5leHRyYSB+c2VlbiBzZXhwcyAtPlxuICBsZXQgKEZpZWxkIHsgbmFtZTsga2luZDsgY29udjsgcmVzdCB9KSA9IGZpZWxkcyBpblxuICBtYXRjaCBzZXhwcyB3aXRoXG4gIHwgTGlzdCAoQXRvbSBhdG9tIDo6IGFyZ3MpIDo6IG90aGVycyB3aGVuIFN0cmluZy5lcXVhbCBhdG9tIG5hbWUgLT5cbiAgICAobWF0Y2gga2luZCwgYXJncyB3aXRoXG4gICAgIHwgUmVxdWlyZWQsIFsgc2V4cCBdIC0+XG4gICAgICAgY29udiBzZXhwLCBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHM6cmVzdCB+aW5kZXggfmV4dHJhIH5zZWVuOihzZWVuICsgMSkgb3RoZXJzXG4gICAgIHwgRGVmYXVsdCBfLCBbIHNleHAgXSAtPlxuICAgICAgIGNvbnYgc2V4cCwgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzOnJlc3QgfmluZGV4IH5leHRyYSB+c2Vlbjooc2VlbiArIDEpIG90aGVyc1xuICAgICB8IE9taXRfbmlsLCBbIHNleHAgXSAtPlxuICAgICAgIGNvbnYgc2V4cCwgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzOnJlc3QgfmluZGV4IH5leHRyYSB+c2Vlbjooc2VlbiArIDEpIG90aGVyc1xuICAgICB8IFNleHBfb3B0aW9uLCBbIHNleHAgXSAtPlxuICAgICAgICggU29tZSAoY29udiBzZXhwKVxuICAgICAgICwgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzOnJlc3QgfmluZGV4IH5leHRyYSB+c2Vlbjooc2VlbiArIDEpIG90aGVycyApXG4gICAgIHwgU2V4cF9saXN0LCBbIHNleHAgXSAtPlxuICAgICAgICggbGlzdF9vZl9zZXhwIGNvbnYgc2V4cFxuICAgICAgICwgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzOnJlc3QgfmluZGV4IH5leHRyYSB+c2Vlbjooc2VlbiArIDEpIG90aGVycyApXG4gICAgIHwgU2V4cF9hcnJheSwgWyBzZXhwIF0gLT5cbiAgICAgICAoIGFycmF5X29mX3NleHAgY29udiBzZXhwXG4gICAgICAgLCBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHM6cmVzdCB+aW5kZXggfmV4dHJhIH5zZWVuOihzZWVuICsgMSkgb3RoZXJzIClcbiAgICAgfCBTZXhwX2Jvb2wsIFtdIC0+XG4gICAgICAgdHJ1ZSwgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzOnJlc3QgfmluZGV4IH5leHRyYSB+c2Vlbjooc2VlbiArIDEpIG90aGVyc1xuICAgICAoKiBtYWxmb3JtZWQgZmllbGQgb2Ygc29tZSBraW5kLCBkaXNwYXRjaCB0byBzbG93IHBhdGggKilcbiAgICAgfCBfLCBfIC0+IHBhcnNlX3JlY29yZF9zbG93IH5maWVsZHMgfmluZGV4IH5leHRyYSB+c2VlbiBzZXhwcylcbiAgKCogbWFsZm9ybWVkIG9yIG91dC1vZi1vcmRlciBmaWVsZCwgZGlzcGF0Y2ggdG8gc2xvdyBwYXRoICopXG4gIHwgXyAtPiBwYXJzZV9yZWNvcmRfc2xvdyB+ZmllbGRzIH5pbmRleCB+ZXh0cmEgfnNlZW4gc2V4cHNcblxuYW5kIHBhcnNlX3NwaW5lX2Zhc3RcbiAgOiB0eXBlIGEuXG4gICAgZmllbGRzOmEgRmllbGRzLnRcbiAgICAtPiBpbmRleDooc3RyaW5nIC0+IGludClcbiAgICAtPiBleHRyYTpib29sXG4gICAgLT4gc2VlbjppbnRcbiAgICAtPiBTZXhwLnQgbGlzdFxuICAgIC0+IGFcbiAgPVxuICBmdW4gfmZpZWxkcyB+aW5kZXggfmV4dHJhIH5zZWVuIHNleHBzIC0+XG4gIG1hdGNoIGZpZWxkcyB3aXRoXG4gIHwgRmllbGQgXyAtPiBwYXJzZV9maWVsZF9mYXN0IH5maWVsZHMgfmluZGV4IH5leHRyYSB+c2VlbiBzZXhwc1xuICB8IEVtcHR5IC0+XG4gICAgKG1hdGNoIHNleHBzIHdpdGhcbiAgICAgfCBbXSAtPiAoKVxuICAgICB8IF8gOjogXyAtPlxuICAgICAgICgqIGV4dHJhIHNleHBzLCBkaXNwYXRjaCB0byBzbG93IHBhdGggKilcbiAgICAgICBwYXJzZV9yZWNvcmRfc2xvdyB+ZmllbGRzIH5pbmRleCB+ZXh0cmEgfnNlZW4gc2V4cHMpXG47O1xuXG5sZXQgcGFyc2VfcmVjb3JkX2Zhc3QgfmZpZWxkcyB+aW5kZXggfmV4dHJhIHNleHBzID1cbiAgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzIH5pbmRleCB+ZXh0cmEgfnNlZW46MCBzZXhwc1xuOztcblxuKCogRW50cnkgcG9pbnRzLiAqKVxuXG5sZXQgcmVjb3JkX29mX3NleHBzXG4gIH5jYWxsZXJcbiAgfmNvbnRleHRcbiAgfmZpZWxkc1xuICB+aW5kZXhfb2ZfZmllbGRcbiAgfmFsbG93X2V4dHJhX2ZpZWxkc1xuICB+Y3JlYXRlXG4gIHNleHBzXG4gID1cbiAgbGV0IGFsbG93X2V4dHJhX2ZpZWxkcyA9XG4gICAgYWxsb3dfZXh0cmFfZmllbGRzIHx8IG5vdCAhU2V4cF9jb252LnJlY29yZF9jaGVja19leHRyYV9maWVsZHNcbiAgaW5cbiAgbWF0Y2hcbiAgICBwYXJzZV9yZWNvcmRfZmFzdCB+ZmllbGRzIH5pbmRleDppbmRleF9vZl9maWVsZCB+ZXh0cmE6YWxsb3dfZXh0cmFfZmllbGRzIHNleHBzXG4gIHdpdGhcbiAgfCB2YWx1ZSAtPiBjcmVhdGUgdmFsdWVcbiAgfCBleGNlcHRpb24gTWFsZm9ybWVkIG1hbGZvcm1lZCAtPiBNYWxmb3JtZWQucmFpc2UgbWFsZm9ybWVkIH5jYWxsZXIgfmNvbnRleHRcbjs7XG5cbmxldCByZWNvcmRfb2Zfc2V4cCB+Y2FsbGVyIH5maWVsZHMgfmluZGV4X29mX2ZpZWxkIH5hbGxvd19leHRyYV9maWVsZHMgfmNyZWF0ZSBzZXhwID1cbiAgbWF0Y2ggKHNleHAgOiBTZXhwLnQpIHdpdGhcbiAgfCBBdG9tIF8gYXMgY29udGV4dCAtPiByZWNvcmRfbGlzdF9pbnN0ZWFkX2F0b20gY2FsbGVyIGNvbnRleHRcbiAgfCBMaXN0IHNleHBzIGFzIGNvbnRleHQgLT5cbiAgICByZWNvcmRfb2Zfc2V4cHNcbiAgICAgIH5jYWxsZXJcbiAgICAgIH5jb250ZXh0XG4gICAgICB+ZmllbGRzXG4gICAgICB+aW5kZXhfb2ZfZmllbGRcbiAgICAgIH5hbGxvd19leHRyYV9maWVsZHNcbiAgICAgIH5jcmVhdGVcbiAgICAgIHNleHBzXG47O1xuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjYW1sX21heWJlX2F0dGFjaF9iYWNrdHJhY2UiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImdsb2JhbF9kYXRhIiwiYWJzZW50IiwiU2V4cGxpYjBfU2V4cF9jb252IiwiU3RkbGliX1N0cmluZ0xhYmVscyIsIlNleHBsaWIwX1NleHBfY29udl9lcnJvciIsIlN0ZGxpYl9MaXN0TGFiZWxzIiwiU3RkbGliX09wdGlvbiIsIlN0ZGxpYiIsIktpbmQiLCJjb21iaW5lIiwiYSIsImIiLCJ0IiwiTWFsZm9ybWVkIiwiZHVtbXkiLCJwYXJzZV92YWx1ZV9tYWxmb3JtZWQiLCJtYWxmb3JtZWQiLCJmaWVsZHMiLCJzdGF0ZSIsInBvcyIsImV4biIsInRhZyIsIm90aGVyIiwicGFyc2VfdmFsdWVzIiwicmVzdCIsImNvbnYiLCJraW5kIiwibmFtZSIsInNleHAiLCJ2YWx1ZSIsImRlZmF1bHQkIiwicGFyc2Vfc3BpbmVfbWFsZm9ybWVkIiwiaW5kZXgiLCJleHRyYSIsInNlZW4iLCJsZW4iLCJzZXhwcyIsInBhcnNlX3NwaW5lX3Nsb3ciLCJmaWVsZCIsIm1hdGNoIiwiaSIsInBhcnNlX3JlY29yZF9zbG93IiwidW5zZWVuIiwiYWNjIiwicGFyc2Vfc3BpbmVfZmFzdCIsIm90aGVycyIsImFyZ3MiLCJhdG9tIiwicmVjb3JkX29mX3NleHBzIiwiY2FsbGVyIiwiY29udGV4dCIsImluZGV4X29mX2ZpZWxkIiwiYWxsb3dfZXh0cmFfZmllbGRzIiwiY3JlYXRlIiwibmFtZXMiLCJtYXliZV9jb250ZXh0IiwicmVjb3JkX29mX3NleHAiLCJTZXhwbGliMF9TZXhwX2NvbnZfcmVjb3JkIl0sIm1hcHBpbmdzIjoiSUFBQUEsVUFBQTtBQUFBLElBQUFDLDhCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FB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QUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFuQmxELDJEQW1Ca0Q7QUFBQTtBQUFBLFlBQUFvQjtBQUFBQSxJQUFBQztBQUFBQSxJQUFBQztBQUFBQSxJQUFBakM7QUFBQUEsSUFBQWtDO0FBQUFBLElBQUFDO0FBQUFBLElBQUFDO0FBQUFBLElBQUFqQjtBQUFBQTtBQUFBQSxLQUFBZ0I7QUFBQUEsT0FrQnpEO0FBQUEsSUFHQTtBQUFBO0FBQUEsTUFBQXZCO0FBQUFBLFFBakJBO0FBQUE7QUFBQTtBQUFBLFVBQUFUO0FBQUFBLFNBQUFBLE1EcFFGLDRCQUFBQyxNQUFBO0FBQUE7QUFBQSxTQUFBTCxZQUFBO0FBQUEsS0MrREk7QUFBQSxNQUNrQixpRUF5TnlEO0FBQUEsS0ExTjNFO0FBQUE7QUFBQSxZQUFBc0MsUUFBQTtBQUFBLFFBRWtCO0FBQUEsZ0RBd055RDtBQUFBO0FBQUEsWUFBQUEsVUExTjNFO0FBQUEsUUFHZ0I7QUFBQSxrREF1TjJEO0FBQUE7QUFBQTtBQUFBLFNBQUFBLFVBMU4zRTtBQUFBO0FBQUEsV0FLRTtBQUFBO0FBQUEsc0JBQUEzQixNQUErQixvQkFBVTtBQUFBO0FBQUEsUUFDdEMsb0VBb05zRTtBQUFBO0FBQUE7QUFBQSxTQUFBNEIsZ0JBMU4zRTtBQUFBLFNBQUFMLFVBUWdCO0FBQUEsUUFDZCwrREFpTnlFO0FBQUE7QUFBQTtBQUFBLElBRGxFLGdDQUNrRTtBQUFBO0FBQUEsWUFBQU07QUFBQUEsSUFBQVAsUUFBQWhDLFFBQUFrQyxnQkFBQUMsb0JBQUFDLFFBQUF6QjtBQUFBQSxJQUk3RTtBQUFBLEtBQ3VCLDREQVNkO0FBQUEsUUFBQVEsUUFWVDtBQUFBLElBR0U7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFPTztBQUFBO0FBQUE7QUFBQSxJQUFBcUI7QUFBQUEsTUF0UVA7QUFBQTtBQUFBO0FBQUE7QUFBQSxFRGpDSiIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzMDUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V4cGxpYjAuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiU2V4cGxpYjBfU2V4cGFibGUiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxvQkFBQSIsImlnbm9yZUxpc3QiOlswXX19LHsib2Zmc2V0Ijp7ImxpbmUiOjIzMTUsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V4cGxpYjAuY21hLmpzIiwic291cmNlcyI6WyIvYnVpbHRpbi9ibGFja2JveC5tbCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKiBnZW5lcmF0ZWQgY29kZSAqKSJdLCJuYW1lcyI6WyJydW50aW1lIiwiU2V4cGxpYjAiXSwibWFwcGluZ3MiOiJPQUFBQSxVQUFBLHlCQUFBQyxXQUFBIiwiaWdub3JlTGlzdCI6WzBdfX1dfQ==
