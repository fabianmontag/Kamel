// Generated by js_of_ocaml
//# buildInfo:effects=disabled, kind=cma, use-js-string=true, version=6.2.0

//# unitInfo: Provides: MenhirLib
//# unitInfo: Requires: CamlinternalLazy, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Char, Stdlib__Lexing, Stdlib__List, Stdlib__Printf, Stdlib__String, Stdlib__Sys
//# shape: MenhirLib:[N,[F(4)*->F(1),F(2)*->F(2),[F(1)*,F(1)*]],[],[],N,N,N,N,N,N,N,N,[],[],N,N,[N]]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$2 = ":\n",
    cst_At_an_unknown_location = "At an unknown location:\n",
    cst_lib_pack_menhirLib_ml = "lib/pack/menhirLib.ml",
    caml_array_make = runtime.caml_array_make,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_check_bound = runtime.caml_check_bound,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_div = runtime.caml_div,
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_mod = runtime.caml_mod,
    caml_mul = runtime.caml_mul,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) === 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    arrow = " -> ",
    dot = ".",
    space = " ",
    newline$0 = "\n",
    cst$1 = "...",
    cst$0 = "???",
    cst = "",
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Assert_failure = global_data.Assert_failure,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Lexing = global_data.Stdlib__Lexing,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    CamlinternalLazy = global_data.CamlinternalLazy;
   function take(n, input){
    if(0 !== n && input){
     var xs = input[2], x = input[1], xs$0 = take(n - 1 | 0, xs);
     return xs === xs$0 ? input : [0, x, xs$0];
    }
    return 0;
   }
   function drop(n$1, xs$1){
    var n = n$1, xs = xs$1;
    for(;;){
     if(0 === n) return xs;
     if(! xs) return 0;
     var xs$0 = xs[2], n$0 = n - 1 | 0;
     n = n$0;
     xs = xs$0;
    }
   }
   function uniq1(cmp, x, ys$1){
    var ys = ys$1;
    for(;;){
     if(! ys) return 0;
     var ys$0 = ys[2], y = ys[1];
     if(0 !== caml_call2(cmp, x, y)) return [0, y, uniq1(cmp, y, ys$0)];
     ys = ys$0;
    }
   }
   function uniq(cmp, xs){
    if(! xs) return 0;
    var xs$0 = xs[2], x = xs[1];
    return [0, x, uniq1(cmp, x, xs$0)];
   }
   function weed(cmp, xs){
    return uniq(cmp, caml_call2(Stdlib_List[63], cmp, xs));
   }
   function length(xs){
    var a = caml_obj_tag(xs);
    a:
    if(250 === a)
     var match = xs[1];
    else{
     if(246 !== a && 244 !== a){var match = xs; break a;}
     var match = caml_call1(CamlinternalLazy[2], xs);
    }
    if(! match) return 0;
    var xs$0 = match[2];
    return 1 + length(xs$0) | 0;
   }
   function foldr(f, xs, accu){
    var a = caml_obj_tag(xs);
    a:
    if(250 === a)
     var match = xs[1];
    else{
     if(246 !== a && 244 !== a){var match = xs; break a;}
     var match = caml_call1(CamlinternalLazy[2], xs);
    }
    if(! match) return accu;
    var xs$0 = match[2], x = match[1];
    return caml_call2(f, x, foldr(f, xs$0, accu));
   }
   function traditional2revised(get_raw_token, get_startp, get_endp, parser){
    return function(lexer){
     var lexbuf = caml_call2(Stdlib_Lexing[3], 0, cst);
     function lexer$0(lexbuf){
      var token = caml_call1(lexer, 0);
      lexbuf[11] = caml_call1(get_startp, token);
      lexbuf[12] = caml_call1(get_endp, token);
      return caml_call1(get_raw_token, token);
     }
     return caml_call2(parser, lexer$0, lexbuf);};
   }
   function revised2traditional(make_token, parser){
    return function(lexer, lexbuf){
     function lexer$0(param){
      var token = caml_call1(lexer, lexbuf);
      return caml_call3(make_token, token, lexbuf[11], lexbuf[12]);
     }
     return caml_call1(parser, lexer$0);};
   }
   function traditional2revised$0(parser){
    return traditional2revised
            (function(param){var token = param[1]; return token;},
             function(param){var startp = param[2]; return startp;},
             function(param){var endp = param[3]; return endp;},
             parser);
   }
   function revised2traditional$0(parser){
    return revised2traditional
            (function(token, startp, endp){return [0, token, startp, endp];},
             parser);
   }
   var
    Simplified = [0, traditional2revised$0, revised2traditional$0],
    Convert = [0, traditional2revised, revised2traditional, Simplified],
    IncrementalEngine = [0],
    EngineTypes = [0],
    f = [0, cst_lib_pack_menhirLib_ml, 2103, 6],
    g = [0, [11, "before '", [2, 0, [12, 39, 0]]], "before '%s'"],
    h =
      [0,
       [11, "after '", [2, 0, [11, "' and before '", [2, 0, [12, 39, 0]]]]],
       "after '%s' and before '%s'"],
    i = [0, cst_lib_pack_menhirLib_ml, 2116, 6];
   function update(buffer, x2){
    var match = buffer[1];
    if(typeof match === "number")
     var a = [0, x2];
    else
     var x1 = 0 === match[0] ? match[1] : match[2], a = [1, x1, x2];
    buffer[1] = a;
   }
   function show(f$0, buffer){
    var match = buffer[1];
    if(typeof match === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, f], 1);
    if(0 === match[0]){
     var invalid = match[1], a = caml_call1(f$0, invalid);
     return caml_call2(Stdlib_Printf[4], g, a);
    }
    var
     invalid$0 = match[2],
     valid = match[1],
     b = caml_call1(f$0, invalid$0),
     c = caml_call1(f$0, valid);
    return caml_call3(Stdlib_Printf[4], h, c, b);
   }
   function last(buffer){
    var match = buffer[1];
    if(typeof match === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, i], 1);
    var invalid = 0 === match[0] ? match[1] : match[2];
    return invalid;
   }
   function wrap(lexer){
    var buffer = [0, 0];
    return [0,
            buffer,
            function(lexbuf){
             var token = caml_call1(lexer, lexbuf);
             update(buffer, [0, lexbuf[11], lexbuf[12]]);
             return token;
            }];
   }
   function wrap_supplier(supplier){
    var buffer = [0, 0];
    return [0,
            buffer,
            function(param){
             var
              triple = caml_call1(supplier, 0),
              pos2 = triple[3],
              pos1 = triple[2];
             update(buffer, [0, pos1, pos2]);
             return triple;
            }];
   }
   function extract(text, param){
    var
     pos2 = param[2],
     pos1 = param[1],
     ofs1 = pos1[4],
     ofs2 = pos2[4],
     len = ofs2 - ofs1 | 0;
    try{var a = caml_call3(Stdlib_String[16], text, ofs1, len); return a;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), tag = exn[1];
     if(tag === Stdlib[6]) return cst$0;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function sanitize(text){
    return caml_call2
            (Stdlib_String[18], function(c){return 32 <= c ? c : 32;}, text);
   }
   function compress(text){
    var
     b = caml_call1(Stdlib_Bytes[5], text),
     n = runtime.caml_ml_bytes_length(b),
     i = 0,
     j = 0,
     skipping = 0;
    for(;;){
     if(j >= n) return caml_call3(Stdlib_Bytes[8], b, 0, i);
     var j$0 = j + 1 | 0, c = runtime.caml_bytes_get(b, j), a = c - 9 | 0;
     a:
     {
      if(4 < a >>> 0){
       if(23 !== a) break a;
      }
      else if(1 >= a - 2 >>> 0) break a;
      var i$0 = skipping ? i : (caml_bytes_set(b, i, 32), i + 1 | 0);
      i = i$0;
      j = j$0;
      skipping = 1;
      continue;
     }
     caml_bytes_set(b, i, c);
     var i$1 = i + 1 | 0;
     i = i$1;
     j = j$0;
     skipping = 0;
    }
   }
   function shorten(k, text){
    var n = caml_ml_string_length(text);
    if(n <= ((2 * k | 0) + 3 | 0)) return text;
    var
     a = caml_call3(Stdlib_String[16], text, n - k | 0, k),
     b = caml_call2(Stdlib[28], cst$1, a),
     c = caml_call3(Stdlib_String[16], text, 0, k);
    return caml_call2(Stdlib[28], c, b);
   }
   var
    Copy = [248, "MenhirLib.ErrorReports.Copy", runtime.caml_fresh_oo_id(0)],
    j = [0, [11, cst_At_an_unknown_location, 0], cst_At_an_unknown_location],
    k =
      [0,
       [11,
        'File "',
        [2,
         0,
         [11,
          '", line ',
          [4,
           0,
           0,
           0,
           [11,
            ", characters ",
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [11, cst$2, 0]]]]]]]]],
       'File "%s", line %d, characters %d-%d:\n'],
    l = [0, cst_lib_pack_menhirLib_ml, 2297, 4],
    m = [0, cst_lib_pack_menhirLib_ml, 2460, 2],
    n = [0, cst_lib_pack_menhirLib_ml, 2609, 4],
    o = [0, cst_lib_pack_menhirLib_ml, 2560, 4],
    p = [0, cst_lib_pack_menhirLib_ml, 2678, 6],
    q = [0, cst_lib_pack_menhirLib_ml, 2852, 10],
    r = [0, cst_lib_pack_menhirLib_ml, 2774, 6],
    s = [0, cst_lib_pack_menhirLib_ml, 2771, 2],
    t = [0, cst_lib_pack_menhirLib_ml, 2936, 2],
    u = [0, cst_lib_pack_menhirLib_ml, 2934, 2],
    v = [0, cst_lib_pack_menhirLib_ml, 2979, 2],
    w = [0, cst_lib_pack_menhirLib_ml, 3004, 2],
    x = [0, cst_lib_pack_menhirLib_ml, 3008, 2],
    y = [0, cst_lib_pack_menhirLib_ml, 3012, 2];
   function expand(f, text){
    var
     n = caml_ml_string_length(text),
     b = caml_call1(Stdlib_Buffer[1], n),
     i = 0;
    for(;;){
     if(i >= n) return caml_call1(Stdlib_Buffer[2], b);
     var i$0 = i + 1 | 0, c = caml_string_get(text, i);
     try{
      if(36 !== c) throw caml_maybe_attach_backtrace(Copy, 1);
      var j = [0, i$0];
      for(;;){
       if(j[1] < n){
        var
         c$0 = caml_string_get(text, j[1]),
         a = 48 <= c$0 ? 1 : 0,
         d = a ? c$0 <= 57 ? 1 : 0 : a;
        if(d){j[1]++; continue;}
       }
       if(i$0 === j[1]) throw caml_maybe_attach_backtrace(Copy, 1);
       var
        k =
          runtime.caml_int_of_string
           (caml_call3(Stdlib_String[16], text, i$0, j[1] - i$0 | 0)),
        e = caml_call1(f, k);
       caml_call2(Stdlib_Buffer[16], b, e);
       var g = j[1];
       i = g;
       break;
      }
     }
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      if(exn !== Copy) throw caml_maybe_attach_backtrace(exn, 0);
      caml_call2(Stdlib_Buffer[12], b, c);
      i = i$0;
     }
    }
   }
   function init(filename, lexbuf){
    lexbuf[12] = [0, filename, 1, 0, 0];
    return lexbuf;
   }
   function read(filename){
    var
     c = caml_call1(Stdlib[79], filename),
     a = caml_call1(Stdlib[92], c),
     text = caml_call2(Stdlib[86], c, a);
    caml_call1(Stdlib[93], c);
    var lexbuf = caml_call2(Stdlib_Lexing[3], 0, text);
    return [0, text, init(filename, lexbuf)];
   }
   function newline(lexbuf){
    var pos = lexbuf[12];
    lexbuf[12] = [0, pos[1], pos[2] + 1 | 0, pos[4], pos[4]];
    return 0;
   }
   function range(range){
    var
     pos2$0 = range[2],
     pos1$0 = range[1],
     pos2 = range[2],
     pos1 = range[1],
     a = pos1 === Stdlib_Lexing[1] ? 1 : 0,
     b = a || (pos2 === Stdlib_Lexing[1] ? 1 : 0);
    if(b) return caml_call1(Stdlib_Printf[4], j);
    var
     file = pos1$0[1],
     line = pos1$0[2],
     char1 = pos1$0[4] - pos1$0[3] | 0,
     char2 = pos2$0[4] - pos1$0[3] | 0;
    return caml_call5(Stdlib_Printf[4], k, file, line, char1, char2);
   }
   function tabulate(is_eof, lexer){
    var tokens = 0;
    for(;;){
     var token = caml_call1(lexer, 0), tokens$0 = [0, token, tokens];
     if(caml_call1(is_eof, token)) break;
     tokens = tokens$0;
    }
    var
     a = caml_call1(Stdlib_List[10], tokens$0),
     tokens$1 = caml_call1(Stdlib_Array[11], a),
     i = [0, 0];
    function lexer$0(param){
     if(i[1] >= tokens$1.length - 1)
      throw caml_maybe_attach_backtrace([0, Assert_failure, l], 1);
     var token = tokens$1[i[1] + 1];
     i[1] = i[1] + 1 | 0;
     return token;
    }
    return lexer$0;
   }
   function make(x){return [0, x, caml_array_make(16384, x), 0];}
   function ensure(a, i){
    if(0 > i) throw caml_maybe_attach_backtrace([0, Assert_failure, m], 1);
    var table = a[2], length$1 = table.length - 1;
    if(length$1 <= i){
     var length$2 = 2 * length$1 | 0, length = length$2, b = a[1];
     for(;;){
      if(i < length){
       var table$0 = caml_array_make(length, b);
       caml_call5(Stdlib_Array[9], table, 0, table$0, 0, length$1);
       a[2] = table$0;
       break;
      }
      var length$0 = 2 * length | 0;
      length = length$0;
     }
    }
   }
   function get(a, i){ensure(a, i); return a[2][i + 1];}
   function set(a, i, x){
    ensure(a, i);
    a[2][i + 1] = x;
    var b = a[3] <= i ? 1 : 0, c = b ? (a[3] = i + 1 | 0, 0) : b;
    return c;
   }
   function extent(a){return a[3];}
   function domain(a){return caml_call3(Stdlib_Array[6], a[2], 0, a[3]);}
   function pack(a){
    var
     m = a.length - 1,
     k =
       caml_call3
        (Stdlib_Array[18],
         function(k$1, v){
          if(0 <= v){
           var k = 1, max = 2;
           for(;;){
            if(0 >= max){var a = k; break;}
            if(v < max){var a = k; break;}
            var max$0 = caml_mul(max, max), k$0 = 2 * k | 0;
            k = k$0;
            max = max$0;
           }
          }
          else
           var a = Stdlib_Sys[9];
          return caml_call2(Stdlib[17], k$1, a);
         },
         1,
         a);
    if(8 < k){
     if(0 !== (k % 8 | 0))
      throw caml_maybe_attach_backtrace([0, Assert_failure, n], 1);
     var
      w = k / 8 | 0,
      n$0 = caml_mul(m, w),
      s = caml_create_bytes(n$0),
      b = m - 1 | 0,
      f = 0;
     if(b >= 0){
      var i = f;
      for(;;){
       var v = [0, caml_check_bound(a, i)[i + 1]], g = 1;
       if(w >= 1){
        var x = g;
        for(;;){
         caml_bytes_set
          (s,
           caml_mul(i + 1 | 0, w) - x | 0,
           caml_call1(Stdlib_Char[1], v[1] & 255));
         v[1] = v[1] >>> 8 | 0;
         var l = x + 1 | 0;
         if(w === x) break;
         x = l;
        }
       }
       var h = i + 1 | 0;
       if(b === i) break;
       i = h;
      }
     }
     return [0, k, caml_call1(Stdlib_Bytes[44], s)];
    }
    if(0 !== caml_mod(8, k))
     throw caml_maybe_attach_backtrace([0, Assert_failure, o], 1);
    var
     w$0 = caml_div(8, k),
     n$1 =
       0 === caml_mod(m, w$0) ? caml_div(m, w$0) : caml_div(m, w$0) + 1 | 0,
     s$0 = caml_create_bytes(n$1),
     i$0 = [0, 0],
     d = n$1 - 1 | 0,
     p = 0;
    if(d >= 0){
     var j = p;
     for(;;){
      var c = [0, 0], q = 1;
      if(w$0 >= 1){
       var x$0 = q;
       for(;;){
        var ii = i$0[1];
        if(ii === m)
         var e = 0;
        else{
         var v$0 = caml_check_bound(a, ii)[ii + 1];
         i$0[1] = ii + 1 | 0;
         var e = v$0;
        }
        c[1] = c[1] << k | e;
        var t = x$0 + 1 | 0;
        if(w$0 === x$0) break;
        x$0 = t;
       }
      }
      caml_bytes_set(s$0, j, caml_call1(Stdlib_Char[1], c[1]));
      var r = j + 1 | 0;
      if(d === j) break;
      j = r;
     }
    }
    return [0, k, caml_call1(Stdlib_Bytes[44], s$0)];
   }
   function get1(s, i){
    var
     i$0 = i >>> 3 | 0,
     c$1 = caml_string_unsafe_get(s, i$0),
     c = c$1 >>> (caml_call1(Stdlib[21], i) & 7) | 0,
     c$0 = c & 1;
    return c$0;
   }
   function get$0(param, i){
    var s = param[2], k = param[1], switcher = k - 1 | 0;
    if(15 >= switcher >>> 0)
     switch(switcher){
       case 0:
        return get1(s, i);
       case 1:
        var
         i$3 = i >>> 2 | 0,
         c = caml_string_unsafe_get(s, i$3),
         c$0 = c >>> (2 * (caml_call1(Stdlib[21], i) & 3) | 0) | 0,
         c$1 = c$0 & 3;
        return c$1;
       case 3:
        var
         i$4 = i >>> 1 | 0,
         c$4 = caml_string_unsafe_get(s, i$4),
         c$2 = c$4 >>> (4 * (caml_call1(Stdlib[21], i) & 1) | 0) | 0,
         c$3 = c$2 & 15;
        return c$3;
       case 7:
        return caml_string_unsafe_get(s, i);
       case 15:
        var j$0 = 2 * i | 0, i$5 = j$0 + 1 | 0;
        return (caml_string_unsafe_get(s, j$0) << 8)
               + caml_string_unsafe_get(s, i$5)
               | 0;
     }
    if(32 !== k) throw caml_maybe_attach_backtrace([0, Assert_failure, p], 1);
    var j = 4 * i | 0, i$0 = j + 3 | 0, i$1 = j + 2 | 0, i$2 = j + 1 | 0;
    return (((((caml_string_unsafe_get(s, j) << 8)
           + caml_string_unsafe_get(s, i$2)
           | 0)
           << 8)
           + caml_string_unsafe_get(s, i$1)
           | 0)
           << 8)
           + caml_string_unsafe_get(s, i$0)
           | 0;
   }
   function unflatten1(param, i, j){
    var data = param[2], n = param[1];
    return get1(data, caml_mul(n, i) + j | 0);
   }
   function decode(displacement){
    return 0 === (displacement & 1)
            ? displacement >>> 1 | 0
            : - (displacement >>> 1 | 0) | 0;
   }
   function compress$0(equal, insignificant, dummy, m, n, t){
    if(t.length - 1 !== m)
     throw caml_maybe_attach_backtrace([0, Assert_failure, s], 1);
    var a = m - 1 | 0, b = 0;
    if(a >= 0){
     var i = b;
     for(;;){
      if(caml_check_bound(t, i)[i + 1].length - 1 !== n)
       throw caml_maybe_attach_backtrace([0, Assert_failure, r], 1);
      var c = i + 1 | 0;
      if(a === i) break;
      i = c;
     }
    }
    function sparse(i, line){
     var j$2 = n - 1 | 0, j = j$2, rank = 0, row = 0;
     for(;;){
      if(0 > j) return [0, i, rank, row];
      var x = caml_check_bound(line, j)[j + 1];
      if(caml_call1(insignificant, x)){var j$0 = j - 1 | 0; j = j$0;}
      else{
       var
        row$0 = [0, [0, j, x], row],
        rank$0 = 1 + rank | 0,
        j$1 = j - 1 | 0;
       j = j$1;
       rank = rank$0;
       row = row$0;
      }
     }
    }
    var rows = caml_call2(Stdlib_Array[16], sparse, t);
    caml_call2
     (Stdlib_Array[37],
      function(a, param){
       var rank2 = param[2], rank1 = a[2];
       return runtime.caml_int_compare(rank2, rank1);
      },
      rows);
    var displacement = caml_array_make(m, 0), data = make(dummy);
    caml_call2
     (Stdlib_Array[12],
      function(param$1){
       var row$1 = param$1[3], i = param$1[1];
       if(row$1){
        var j$0 = row$1[1][1], k$1 = - j$0 | 0, k = k$1;
        a:
        for(;;){
         var d = data[3], param = row$1;
         for(;;){
          if(param){
           var row = param[2], match = param[1], x = match[2], j = match[1];
           if(0 > (k + j | 0))
            throw caml_maybe_attach_backtrace([0, Assert_failure, q], 1);
           if(d <= (k + j | 0))
            var a = 1;
           else{
            var y = get(data, k + j | 0);
            if(caml_call1(insignificant, y)){param = row; continue;}
            if(caml_call2(equal, x, y)){param = row; continue;}
            var a = 0;
           }
          }
          else
           var a = 1;
          if(a){var displacement$0 = k; break a;}
          var k$0 = k + 1 | 0;
          k = k$0;
          break;
         }
        }
       }
       else
        var displacement$0 = 0;
       var param$0 = row$1;
       for(;;){
        if(! param$0){
         var
          b =
            0 <= displacement$0
             ? displacement$0 << 1
             : ((- displacement$0 | 0) << 1) + 1 | 0;
         caml_check_bound(displacement, i)[i + 1] = b;
         return 0;
        }
        var
         row$0 = param$0[2],
         match$0 = param$0[1],
         x$0 = match$0[2],
         j$1 = match$0[1];
        set(data, displacement$0 + j$1 | 0, x$0);
        param$0 = row$0;
       }
      },
      rows);
    return [0, displacement, domain(data)];
   }
   function get$1(param, i, j){
    var data = param[2], displacement = param[1];
    if(0 <= i && i < displacement.length - 1){
     var k = decode(caml_check_bound(displacement, i)[i + 1]);
     if(0 <= (k + j | 0) && (k + j | 0) < data.length - 1){
      var a = k + j | 0;
      return caml_check_bound(data, a)[a + 1];
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, t], 1);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, u], 1);
   }
   function getget(get_displacement, get_data, param, i, j){
    var
     data = param[2],
     displacement = param[1],
     k = decode(caml_call2(get_displacement, displacement, i));
    return caml_call2(get_data, data, k + j | 0);
   }
   function make$0(a){
    var
     n = a.length - 1,
     size = [0, 0],
     entry =
       caml_call2
        (Stdlib_Array[1],
         n + 1 | 0,
         function(i){
          var s = size[1];
          if(i < n)
           size[1] = s + (caml_check_bound(a, i)[i + 1].length - 1) | 0;
          return s;
         }),
     b = size[1];
    if(caml_check_bound(entry, n)[n + 1] !== b)
     throw caml_maybe_attach_backtrace([0, Assert_failure, v], 1);
    var
     i = [0, 0],
     j = [0, 0],
     data =
       caml_call2
        (Stdlib_Array[1],
         size[1],
         function(param){
          for(;;){
           var b = i[1], e = caml_check_bound(a, b)[b + 1].length - 1;
           if(j[1] !== e){
            var
             c = j[1],
             d = i[1],
             x = caml_check_bound(caml_check_bound(a, d)[d + 1], c)[c + 1];
            j[1] = j[1] + 1 | 0;
            return x;
           }
           i[1] = i[1] + 1 | 0;
           j[1] = 0;
          }
         });
    return [0, data, entry];
   }
   function length$0(param){var entry = param[2]; return entry.length - 1;}
   function row_length(param, i){
    var
     entry = param[2],
     a = i + 1 | 0,
     b = caml_check_bound(entry, i)[i + 1];
    return caml_check_bound(entry, a)[a + 1] - b | 0;
   }
   function row_length_via(get_entry, i){
    var a = caml_call1(get_entry, i);
    return caml_call1(get_entry, i + 1 | 0) - a | 0;
   }
   function read$0(la, i, j){
    var entry = la[2], data = la[1];
    if(0 <= j && j < row_length(la, i)){
     var a = caml_check_bound(entry, i)[i + 1] + j | 0;
     return caml_check_bound(data, a)[a + 1];
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, w], 1);
   }
   function read_via(get_data, get_entry, i, j){
    if(0 <= j && j < row_length_via(get_entry, i))
     return caml_call1(get_data, caml_call1(get_entry, i) + j | 0);
    throw caml_maybe_attach_backtrace([0, Assert_failure, x], 1);
   }
   function write(la, i, j, v){
    var entry = la[2], data = la[1];
    if(0 <= j && j < row_length(la, i)){
     var a = caml_check_bound(entry, i)[i + 1] + j | 0;
     caml_check_bound(data, a)[a + 1] = v;
     return 0;
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, y], 1);
   }
   function read_interval_via(get_data, i, j){
    if(i === j) return 0;
    var a = read_interval_via(get_data, i + 1 | 0, j);
    return [0, caml_call1(get_data, i), a];
   }
   function read_row_via(get_data, get_entry, i){
    var a = caml_call1(get_entry, i + 1 | 0);
    return read_interval_via(get_data, caml_call1(get_entry, i), a);
   }
   function read_row(param, i){
    var entry = param[2], data = param[1];
    return read_row_via
            (function(a){return caml_check_bound(data, a)[a + 1];},
             function(a){return caml_check_bound(entry, a)[a + 1];},
             i);
   }
   var TableFormat = [0], InspectionTableFormat = [0];
   function Symbols(T){return [0];}
   var
    StaticVersion = [0, 0],
    D = [0, cst_lib_pack_menhirLib_ml, 3613, 4],
    E = [0, cst_lib_pack_menhirLib_ml, 3662, 8],
    F = [0, cst_lib_pack_menhirLib_ml, 3680, 8],
    G = [0, cst_lib_pack_menhirLib_ml, 3701, 10],
    H = [0, cst_lib_pack_menhirLib_ml, 3723, 4],
    I =
      [0, [11, "State ", [4, 0, 0, 0, [11, cst$2, [10, 0]]]], "State %d:\n%!"],
    J =
      [0,
       [11,
        "Shifting (",
        [2, 0, [11, ") to state ", [4, 0, 0, 0, [12, 10, [10, 0]]]]]],
       "Shifting (%s) to state %d\n%!"],
    K = [0, [2, 0, [12, 10, [10, 0]]], "%s\n%!"],
    L =
      [0,
       [11,
        "Lookahead token is now ",
        [2,
         0,
         [11,
          " (",
          [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [11, ")\n", [10, 0]]]]]]]],
       "Lookahead token is now %s (%d-%d)\n%!"],
    M =
      [0,
       [11, "Initiating error handling\n", [10, 0]],
       "Initiating error handling\n%!"],
    N =
      [0,
       [11, "Resuming error handling\n", [10, 0]],
       "Resuming error handling\n%!"],
    O =
      [0,
       [11, "Handling error in state ", [4, 0, 0, 0, [12, 10, [10, 0]]]],
       "Handling error in state %d\n%!"],
    z = [0, cst_lib_pack_menhirLib_ml, 3313, 4],
    A = [0, cst_lib_pack_menhirLib_ml, 3332, 4],
    B = [0, cst_lib_pack_menhirLib_ml, 3338, 4],
    C = [0, cst_lib_pack_menhirLib_ml, 3425, 4],
    cst_feed_outgoing_transition_d =
      "feed: outgoing transition does not exist",
    cst_Current_LR_1_state = "Current LR(1) state: ",
    cst_some_initial_state = "<some initial state>",
    a = [0, cst_lib_pack_menhirLib_ml, 1471, 4],
    b = [0, cst_lib_pack_menhirLib_ml, 1486, 4],
    cst_offer_expects_InputNeeded = "offer expects InputNeeded",
    cst_resume_expects_HandlingErr =
      "resume expects HandlingError | Shifting | AboutToReduce",
    c = [0, cst_lib_pack_menhirLib_ml, 1801, 4],
    d = [0, cst_lib_pack_menhirLib_ml, 1828, 8],
    e = [0, cst_lib_pack_menhirLib_ml, 2016, 6],
    cst_force_reduction_this_reduc =
      "force_reduction: this reduction is not permitted in this state",
    MenhirLib =
      [0,
       [0, take, drop, uniq, weed, length, foldr],
       Convert,
       IncrementalEngine,
       EngineTypes,
       [0,
        function(T){
         var
          number = T[1],
          production_index = T[7],
          find_production = T[8],
          Error = T[18],
          log = T[21],
          Log = T[22];
         function run(env, please_discard){
          if(log) caml_call1(Log[1], env[4]);
          return please_discard ? [0, env] : check_for_default_reduction(env);
         }
         function check_for_default_reduction(env){
          return caml_call4
                  (T[9], env[4], announce_reduce, check_for_error_token, env);
         }
         function check_for_error_token(env){
          if(! env[1]){
           var
            token = env[2][1],
            a = caml_call1(T[3], token),
            b = caml_call1(T[2], token);
           return caml_call7
                   (T[10], env[4], b, a, shift, announce_reduce, initiate, env);
          }
          if(log) caml_call1(Log[6], 0);
          return [3, env];
         }
         function shift(env, please_discard, terminal, value, s){
          if(log) caml_call2(Log[2], terminal, s);
          var
           match = env[2],
           endp = match[3],
           startp = match[2],
           stack = [0, env[4], value, startp, endp, env[3]],
           new_env = [0, env[1], env[2], stack, s];
          return [1, env, new_env, please_discard];
         }
         function announce_reduce(env, prod){
          if(! caml_call1(T[17], prod)) return [2, env, prod];
          if(log) caml_call1(Log[3], prod);
          var v = env[3][2];
          return [4, v];
         }
         function reduce(env, prod){
          if(log) caml_call1(Log[3], prod);
          var
           stack = caml_call2(T[19], prod, env),
           current = caml_call2(T[14], stack[1], prod),
           env$0 = [0, env[1], env[2], stack, current];
          return run(env$0, 0);
         }
         function initiate(env){
          if(log) caml_call1(Log[5], 0);
          var env$0 = [0, 1, env[2], env[3], env[4]];
          return [3, env$0];
         }
         function start(s, initial){
          var empty = [];
          runtime.caml_update_dummy
           (empty, [0, s, T[5], initial, initial, empty]);
          var env = [0, 0, [0, 0, initial, initial], empty, s];
          return run(env, 1);
         }
         function offer(param){
          if(typeof param !== "number" && 0 === param[0]){
           var env = param[1];
           return function(triple){
            if(log){
             var
              endp = triple[3],
              startp = triple[2],
              token = triple[1],
              a = caml_call1(T[2], token);
             caml_call3(Log[4], a, startp, endp);
            }
            var env$0 = [0, 0, triple, env[3], env[4]];
            return check_for_default_reduction(env$0);};
          }
          return caml_call1(Stdlib[1], cst_offer_expects_InputNeeded);
         }
         function resume(opt, checkpoint){
          var strategy = opt ? opt[1] : -822677911;
          if(typeof checkpoint !== "number")
           switch(checkpoint[0]){
             case 1:
              var please_discard = checkpoint[3], env = checkpoint[2];
              return run(env, please_discard);
             case 2:
              var prod = checkpoint[2], env$0 = checkpoint[1];
              return reduce(env$0, prod);
             case 3:
              var env$1 = checkpoint[1];
              if(env$1[1])
               return caml_call7
                       (T[10],
                        env$1[4],
                        T[4],
                        T[5],
                        function(env, please_discard$0, terminal, value, s){
                         if(caml_equal(terminal, T[4]) && caml_equal(value, T[5])){
                          if(log) caml_call1(Log[7], env[4]);
                          var
                           please_discard =
                             -798940232 <= strategy ? 0 : please_discard$0;
                          return shift(env, please_discard, terminal, value, s);
                         }
                         throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
                        },
                        function(env, prod){
                         if(log) caml_call1(Log[7], env[4]);
                         return -798940232 <= strategy
                                 ? announce_reduce(env, prod)
                                 : reduce(env, prod);
                        },
                        function(env$0){
                         if(-798940232 <= strategy) return 0;
                         var cell = env$0[3], next = cell[5];
                         if(next === cell) return 0;
                         var env = [0, env$0[1], env$0[2], next, cell[1]];
                         return [3, env];
                        },
                        env$1);
              throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
           }
          return caml_call1(Stdlib[1], cst_resume_expects_HandlingErr);
         }
         function lexer_lexbuf_to_supplier(lexer, lexbuf){
          return function(param){
           var
            token = caml_call1(lexer, lexbuf),
            startp = lexbuf[11],
            endp = lexbuf[12];
           return [0, token, startp, endp];};
         }
         function loop(opt$2, read, checkpoint$2){
          var opt = opt$2, checkpoint = checkpoint$2;
          for(;;){
           var strategy = opt ? opt[1] : -822677911;
           if(typeof checkpoint === "number")
            throw caml_maybe_attach_backtrace(Error, 1);
           switch(checkpoint[0]){
             case 0:
              var
               triple = caml_call1(read, 0),
               checkpoint$0 = caml_call1(offer(checkpoint), triple),
               opt$0 = [0, strategy];
              opt = opt$0;
              checkpoint = checkpoint$0;
              break;
             case 4:
              var v = checkpoint[1]; return v;
             default:
              var
               checkpoint$1 = resume([0, strategy], checkpoint),
               opt$1 = [0, strategy];
              opt = opt$1;
              checkpoint = checkpoint$1;
           }
          }
         }
         function entry(strategy, s, lexer, lexbuf){
          var initial = lexbuf[12], a = start(s, initial);
          return loop
                  ([0, strategy], lexer_lexbuf_to_supplier(lexer, lexbuf), a);
         }
         function loop_handle(succeed, fail, read, checkpoint$2){
          var checkpoint = checkpoint$2;
          for(;;){
           if(typeof checkpoint !== "number")
            switch(checkpoint[0]){
              case 0:
               var
                triple = caml_call1(read, 0),
                checkpoint$0 = caml_call1(offer(checkpoint), triple);
               checkpoint = checkpoint$0;
               continue;
              case 4:
               var v = checkpoint[1]; return caml_call1(succeed, v);
              case 3: break;
              default:
               var checkpoint$1 = resume(0, checkpoint);
               checkpoint = checkpoint$1;
               continue;
            }
           return caml_call1(fail, checkpoint);
          }
         }
         function loop_handle_undo(succeed, fail, read, checkpoint$2){
          a:
          {
           if(typeof checkpoint$2 !== "number" && 0 === checkpoint$2[0]){var a = 1; break a;}
           var a = 0;
          }
          if(! a)
           throw caml_maybe_attach_backtrace([0, Assert_failure, c], 1);
          var param = [0, checkpoint$2, checkpoint$2];
          for(;;){
           var checkpoint = param[2], inputneeded = param[1];
           if(typeof checkpoint !== "number")
            switch(checkpoint[0]){
              case 0:
               var
                triple = caml_call1(read, 0),
                checkpoint$0 = caml_call1(offer(checkpoint), triple);
               param = [0, checkpoint, checkpoint$0];
               continue;
              case 4:
               var v = checkpoint[1]; return caml_call1(succeed, v);
              case 3: break;
              default:
               var checkpoint$1 = resume(0, checkpoint);
               param = [0, inputneeded, checkpoint$1];
               continue;
            }
           return caml_call2(fail, inputneeded, checkpoint);
          }
         }
         function shifts(checkpoint$1){
          var checkpoint = checkpoint$1;
          for(;;){
           if(typeof checkpoint !== "number")
            switch(checkpoint[0]){
              case 1:
               var env = checkpoint[1]; return [0, env];
              case 2:
               var checkpoint$0 = resume(0, checkpoint);
               checkpoint = checkpoint$0;
               continue;
              case 3:
               return 0;
            }
           throw caml_maybe_attach_backtrace([0, Assert_failure, d], 1);
          }
         }
         function acceptable(checkpoint, token, pos){
          var
           triple = [0, token, pos, pos],
           checkpoint$0 = caml_call1(offer(checkpoint), triple);
          return shifts(checkpoint$0) ? 1 : 0;
         }
         function f(cell, current){
          return [246,
                  function(param){
                   var next = cell[5];
                   if(next === cell) return 0;
                   var element = [0, current, cell[2], cell[3], cell[4]];
                   return [0, element, f(next, cell[1])];
                  }];
         }
         function stack(env){return f(env[3], env[4]);}
         function top(env){
          var cell = env[3], next = cell[5];
          return next === cell
                  ? 0
                  : [0, [0, env[4], cell[2], cell[3], cell[4]]];
         }
         function equal(env1, env2){
          var a = env1[3] === env2[3] ? 1 : 0;
          if(a)
           var
            c = caml_call1(number, env2[4]),
            b = caml_call1(number, env1[4]) === c ? 1 : 0;
          else
           var b = a;
          return b;
         }
         function current_state_number(env){
          return caml_call1(number, env[4]);
         }
         function positions(param){
          var match = param[2], endp = match[3], startp = match[2];
          return [0, startp, endp];
         }
         function state_has_default_reduction(state){
          return caml_call4
                  (T[9],
                   state,
                   function(env, prod){return 1;},
                   function(env){return 0;},
                   0);
         }
         function env_has_default_reduction(env){
          return state_has_default_reduction(env[4]);
         }
         function pop(env){
          var cell = env[3], next = cell[5];
          return next === cell ? 0 : [0, [0, env[1], env[2], next, cell[1]]];
         }
         function force_reduction(prod, env){
          if(! caml_call2(T[20], env[4], prod))
           return caml_call1(Stdlib[1], cst_force_reduction_this_reduc);
          if(caml_call1(T[17], prod))
           throw caml_maybe_attach_backtrace([0, Assert_failure, e], 1);
          var
           stack = caml_call2(T[19], prod, env),
           current = caml_call2(T[14], stack[1], prod);
          return [0, env[1], env[2], stack, current];
         }
         function input_needed(env){return [0, env];}
         function pop_many(i$1, env$1){
          var i = i$1, env = env$1;
          for(;;){
           if(0 === i) return [0, env];
           var match = pop(env);
           if(! match) return 0;
           var env$0 = match[1], i$0 = i - 1 | 0;
           i = i$0;
           env = env$0;
          }
         }
         function get(i, env){
          var match = pop_many(i, env);
          if(! match) return 0;
          var env$0 = match[1];
          return top(env$0);
         }
         return [0,
                 Error,
                 entry,
                 offer,
                 resume,
                 lexer_lexbuf_to_supplier,
                 loop,
                 loop_handle,
                 loop_handle_undo,
                 shifts,
                 acceptable,
                 number,
                 production_index,
                 find_production,
                 stack,
                 top,
                 pop_many,
                 get,
                 current_state_number,
                 equal,
                 positions,
                 env_has_default_reduction,
                 state_has_default_reduction,
                 pop,
                 force_reduction,
                 input_needed,
                 start];
        }],
       [0,
        wrap,
        wrap_supplier,
        show,
        last,
        extract,
        sanitize,
        compress,
        shorten,
        expand],
       [0, init, read, newline, range, tabulate],
       [0,
        function(I, User){
         function print_symbols(i$1, symbols$1){
          var i = i$1, symbols = symbols$1;
          for(;;)
           if(0 === i){
            caml_call1(User[1], dot);
            caml_call1(User[1], space);
            i = -1;
           }
           else{
            if(! symbols) return 0;
            var symbols$0 = symbols[2], symbol = symbols[1];
            caml_call1(User[2], symbol);
            caml_call1(User[1], space);
            var i$0 = i - 1 | 0;
            i = i$0;
            symbols = symbols$0;
           }
         }
         function print_element_as_symbol(element){
          var s = element[1], a = [0, caml_call1(I[29], s)];
          return caml_call1(User[2], a);
         }
         var match = User[3];
         if(match)
          var print_element = match[1], print_element$0 = print_element;
         else
          var print_element$0 = print_element_as_symbol;
         function print_stack(env){
          var
           match = caml_call1(I[13], env),
           match$0 = caml_call1(I[21], env);
          if(match && match$0){
           var env$0 = match$0[1], element = match[1];
           print_stack(env$0);
           caml_call1(User[1], space);
           return caml_call1(print_element$0, element);
          }
         }
         function print_stack$0(env){
          print_stack(env);
          return caml_call1(User[1], newline$0);
         }
         function print_item(param){
          var i = param[2], prod = param[1], a = caml_call1(I[31], prod);
          caml_call1(User[2], a);
          caml_call1(User[1], arrow);
          print_symbols(i, caml_call1(I[32], prod));
          return caml_call1(User[1], newline$0);
         }
         function print_symbols$0(symbols){return print_symbols(-1, symbols);}
         function print_production(prod){return print_item([0, prod, -1]);}
         function print_current_state(env){
          caml_call1(User[1], cst_Current_LR_1_state);
          var match = caml_call1(I[13], env);
          if(match){
           var
            current = match[1][1],
            a = caml_call1(I[9], current),
            b = caml_call1(Stdlib[33], a);
           caml_call1(User[1], b);
           caml_call1(User[1], newline$0);
           var c = caml_call1(I[30], current);
           return caml_call2(Stdlib_List[18], print_item, c);
          }
          caml_call1(User[1], cst_some_initial_state);
          return caml_call1(User[1], newline$0);
         }
         function print_env(env){
          print_stack$0(env);
          print_current_state(env);
          return caml_call1(User[1], newline$0);
         }
         return [0,
                 print_symbols$0,
                 print_element_as_symbol,
                 print_stack$0,
                 print_item,
                 print_production,
                 print_current_state,
                 print_env];
        }],
       [0, make, get, set, extent, domain],
       [0, pack, get$0, get1, unflatten1],
       [0, compress$0, get$1, getget],
       [0,
        make$0,
        read$0,
        write,
        length$0,
        row_length,
        read_row,
        row_length_via,
        read_via,
        read_row_via],
       TableFormat,
       InspectionTableFormat,
       [0,
        Symbols,
        function(TT, IT, ET, E){
         function read_packed_linearized(param, i){
          var entry = param[2], data = param[1];
          return read_row_via
                  (function(a){return get$0(data, a);},
                   function(a){return get$0(entry, a);},
                   i);
         }
         function decode_symbol(symbol){
          if(0 >= symbol)
           throw caml_maybe_attach_backtrace([0, Assert_failure, z], 1);
          var kind = symbol & 1, symbol$0 = symbol >>> 1 | 0;
          return 0 === kind
                  ? caml_call1(IT[1], symbol$0 - 1 | 0)
                  : caml_call1(IT[2], symbol$0);
         }
         function n2i(nt){
          var answer = TT[9] + nt | 0;
          if(caml_equal(caml_call1(IT[2], answer), [0, [1, nt]]))
           return answer;
          throw caml_maybe_attach_backtrace([0, Assert_failure, A], 1);
         }
         function t2i(t){
          if(caml_equal(caml_call1(IT[1], t), [0, [0, t]])) return t;
          throw caml_maybe_attach_backtrace([0, Assert_failure, B], 1);
         }
         function compare_terminals(t1, t2){
          var a = t2i(t2);
          return t2i(t1) - a | 0;
         }
         function compare_nonterminals(nt1, nt2){
          var a = n2i(nt2);
          return n2i(nt1) - a | 0;
         }
         function compare_symbols(symbol1, symbol2){
          var a = symbol1[1];
          if(0 === a[0]){
           var match = symbol2[1], t1 = a[1];
           if(0 !== match[0]) return -1;
           var t2 = match[1];
           return compare_terminals(t1, t2);
          }
          var match$0 = symbol2[1], nt1 = a[1];
          if(0 === match$0[0]) return 1;
          var nt2 = match$0[1];
          return compare_nonterminals(nt1, nt2);
         }
         function compare_productions(prod1, prod2){return prod1 - prod2 | 0;}
         function compare_items(a, param){
          var
           index2 = param[2],
           prod2 = param[1],
           index1 = a[2],
           prod1 = a[1],
           c = prod1 - prod2 | 0;
          return 0 === c ? index1 - index2 | 0 : c;
         }
         function incoming_symbol(s){
          var
           core = get$0(IT[4], s),
           symbol = decode_symbol(get$0(IT[6], core)),
           symbol$0 = symbol[1];
          return symbol$0;
         }
         function lhs(prod){
          var a = get$0(TT[7], prod);
          return caml_call1(IT[2], a);
         }
         function rhs(prod){
          var a = read_packed_linearized(IT[3], prod);
          return caml_call2(Stdlib_List[20], decode_symbol, a);
         }
         function export$(t){return [0, t >>> 10 | 0, t % 1024 | 0];}
         function items(s){
          var core = get$0(IT[4], s), a = read_packed_linearized(IT[5], core);
          return caml_call2(Stdlib_List[20], export$, a);
         }
         function decode_bool(i){
          if(0 !== i && 1 !== i)
           throw caml_maybe_attach_backtrace([0, Assert_failure, C], 1);
          return 1 === i ? 1 : 0;
         }
         function nullable(nt){
          var a = n2i(nt);
          return decode_bool(get1(IT[7], a));
         }
         function first(nt, t){
          var a = t2i(t), b = n2i(nt);
          return decode_bool(unflatten1(IT[8], b, a));
         }
         function xfirst(symbol, t){
          var match = symbol[1];
          if(0 === match[0]){
           var t$0 = match[1];
           return 0 === compare_terminals(t, t$0) ? 1 : 0;
          }
          var nt = match[1];
          return first(nt, t);
         }
         function foreach_terminal(f, accu){
          var n = TT[5][1], accu$1 = accu, i$0 = 0;
          for(;;){
           if(i$0 === n) return accu$1;
           var
            accu$0 = caml_call2(f, caml_call1(IT[1], i$0), accu$1),
            i = i$0 + 1 | 0;
           accu$1 = accu$0;
           i$0 = i;
          }
         }
         function foreach_terminal_but_error(f, accu){
          var n = TT[5][1], accu$1 = accu, i$0 = 0;
          for(;;){
           if(i$0 === n) return accu$1;
           var
            accu$0 =
              i$0 === TT[2]
               ? accu$1
               : caml_call2(f, caml_call1(IT[1], i$0), accu$1),
            i = i$0 + 1 | 0;
           accu$1 = accu$0;
           i$0 = i;
          }
         }
         function feed_failure(param){
          return caml_call1(Stdlib[1], cst_feed_outgoing_transition_d);
         }
         function reduce(env, prod){return feed_failure(0);}
         function initiate(env){return feed_failure(0);}
         function feed(symbol, startp, semv, endp, env){
          if(0 === symbol[0]){
           var
            terminal = symbol[1],
            terminal$0 = t2i(terminal),
            source$0 = env[4];
           return caml_call7
                   (ET[10],
                    source$0,
                    terminal$0,
                    semv,
                    function(env, please_discard, terminal, semv, target){
                     var stack = [0, source$0, semv, startp, endp, env[3]];
                     return [0, env[1], env[2], stack, target];
                    },
                    reduce,
                    initiate,
                    env);
          }
          var
           nt = symbol[1],
           nt$0 = n2i(nt),
           source = env[4],
           match = caml_call2(ET[15], source, nt$0);
          if(! match) return feed_failure(0);
          var
           target = match[1],
           stack = [0, source, semv, startp, endp, env[3]];
          return [0, env[1], env[2], stack, target];
         }
         return [0,
                 compare_terminals,
                 compare_nonterminals,
                 compare_symbols,
                 compare_productions,
                 compare_items,
                 incoming_symbol,
                 items,
                 lhs,
                 rhs,
                 nullable,
                 first,
                 xfirst,
                 foreach_terminal,
                 foreach_terminal_but_error,
                 feed];
        }],
       [0,
        function(T){
         function number(s){return s;}
         var token2terminal = T[1], token2value = T[3], error_terminal = T[2];
         function foreach_terminal(f, accu){
          var n = T[5][1], accu$1 = accu, i$0 = 0;
          for(;;){
           if(i$0 === n) return accu$1;
           var accu$0 = caml_call2(f, i$0, accu$1), i = i$0 + 1 | 0;
           accu$1 = accu$0;
           i$0 = i;
          }
         }
         function non_start_production(i){
          if(T[9] <= i && (i - T[9] | 0) < T[10].length - 1) return;
          throw caml_maybe_attach_backtrace([0, Assert_failure, D], 1);
         }
         function production_index(i){non_start_production(i); return i;}
         function find_production(i){non_start_production(i); return i;}
         function default_reduction(state, defred, nodefred, env){
          var code = get$0(T[4], state);
          if(0 === code) return caml_call1(nodefred, env);
          var prod = code - 1 | 0;
          return caml_call2(defred, env, prod);
         }
         function is_start(prod){return prod < T[9] ? 1 : 0;}
         function action(state, terminal, value, shift, reduce, fail, env){
          var c = unflatten1(T[5], state, terminal);
          if(1 === c){
           var
            table = T[6],
            action = getget(get$0, get$0, table, state, terminal),
            opcode = action & 3,
            param = action >>> 2 | 0;
           if(2 > opcode) return caml_call2(reduce, env, param);
           var please_discard = 2 === opcode ? 1 : 0;
           return caml_call5
                   (shift, env, please_discard, terminal, value, param);
          }
          if(0 === c) return caml_call1(fail, env);
          throw caml_maybe_attach_backtrace([0, Assert_failure, E], 1);
         }
         function maybe_shift_t(state, terminal){
          var c = unflatten1(T[5], state, terminal);
          if(1 === c){
           var
            table = T[6],
            action = getget(get$0, get$0, table, state, terminal),
            opcode = action & 3;
           if(2 > opcode) return 0;
           var state$0 = action >>> 2 | 0;
           return [0, state$0];
          }
          if(0 === c) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, F], 1);
         }
         function may_reduce_prod(state, terminal, prod){
          var code = get$0(T[4], state);
          if(0 !== code){
           var prod$1 = code - 1 | 0;
           return prod === prod$1 ? 1 : 0;
          }
          var c = unflatten1(T[5], state, terminal);
          if(1 === c){
           var
            table = T[6],
            action = getget(get$0, get$0, table, state, terminal),
            opcode = action & 3;
           if(2 <= opcode) return 0;
           var prod$0 = action >>> 2 | 0;
           return prod === prod$0 ? 1 : 0;
          }
          if(0 === c) return 0;
          throw caml_maybe_attach_backtrace([0, Assert_failure, G], 1);
         }
         function goto_nt(state, nt){
          var table = T[8], code = getget(get$0, get$0, table, state, nt);
          return code - 1 | 0;
         }
         function lhs(prod){return get$0(T[7], prod);}
         function goto_prod(state, prod){return goto_nt(state, lhs(prod));}
         function maybe_goto_nt(state, nt){
          var table = T[8], code = getget(get$0, get$0, table, state, nt);
          if(0 <= code) return 0 === code ? 0 : [0, code - 1 | 0];
          throw caml_maybe_attach_backtrace([0, Assert_failure, H], 1);
         }
         var Error = T[11];
         function semantic_action(prod){
          var a = prod - T[9] | 0;
          return caml_check_bound(T[10], a)[a + 1];
         }
         function may_reduce(state, prod){
          var code = get$0(T[4], state);
          if(0 !== code){
           var prod$0 = code - 1 | 0;
           return prod === prod$0 ? 1 : 0;
          }
          var n = T[5][1], accu$0 = 0, i$0 = 0;
          for(;;){
           if(i$0 === n) return accu$0;
           var
            accu =
              accu$0
              ||
               action
                (state,
                 i$0,
                 0,
                 function(d, c, b, a, param){return 0;},
                 function(param, prod$0){return prod === prod$0 ? 1 : 0;},
                 function(param){return 0;},
                 0),
            i = i$0 + 1 | 0;
           accu$0 = accu;
           i$0 = i;
          }
         }
         var error_value = 0, log = T[12] ? 1 : 0;
         function state(state){
          return T[12]
                  ? caml_call3(Stdlib_Printf[1], Stdlib[40], I, state)
                  : 0;
         }
         function shift(terminal, state){
          var match = T[12];
          if(! match) return 0;
          var
           terminals = match[1][1],
           a = caml_check_bound(terminals, terminal)[terminal + 1];
          return caml_call4(Stdlib_Printf[1], Stdlib[40], J, a, state);
         }
         function reduce_or_accept(prod){
          var match = T[12];
          if(! match) return 0;
          var
           productions = match[1][2],
           a = caml_check_bound(productions, prod)[prod + 1];
          return caml_call3(Stdlib_Printf[1], Stdlib[40], K, a);
         }
         function lookahead_token(token, startp, endp){
          var match = T[12];
          if(! match) return 0;
          var
           terminals = match[1][1],
           a = endp[4],
           b = startp[4],
           c = caml_check_bound(terminals, token)[token + 1];
          return caml_call5(Stdlib_Printf[1], Stdlib[40], L, c, b, a);
         }
         function initiating_error_handling(param){
          return T[12] ? caml_call2(Stdlib_Printf[1], Stdlib[40], M) : 0;
         }
         function resuming_error_handling(param){
          return T[12] ? caml_call2(Stdlib_Printf[1], Stdlib[40], N) : 0;
         }
         function handling_error(state){
          return T[12]
                  ? caml_call3(Stdlib_Printf[1], Stdlib[40], O, state)
                  : 0;
         }
         var
          Log =
            [0,
             state,
             shift,
             reduce_or_accept,
             lookahead_token,
             initiating_error_handling,
             resuming_error_handling,
             handling_error];
         return [0,
                 number,
                 token2terminal,
                 token2value,
                 error_terminal,
                 error_value,
                 foreach_terminal,
                 production_index,
                 find_production,
                 default_reduction,
                 action,
                 maybe_shift_t,
                 may_reduce_prod,
                 goto_nt,
                 goto_prod,
                 maybe_goto_nt,
                 lhs,
                 is_start,
                 Error,
                 semantic_action,
                 may_reduce,
                 log,
                 Log];
        }],
       StaticVersion];
   runtime.caml_register_global(68, MenhirLib, "MenhirLib");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVuaGlyTGliLmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6MTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVuaGlyTGliLmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZmFiaWFuLy5vcGFtL2RlZmF1bHQvbGliL21lbmhpckxpYi9tZW5oaXJMaWIubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCJtb2R1bGUgR2VuZXJhbCA9IHN0cnVjdFxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IElucmlhLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgICAgICopXG4oKiAgIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIsIHdpdGggYSAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nLCBhcyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuKCogTGlzdHMuICopXG5cbmxldCByZWMgdGFrZSBuIHhzID1cbiAgbWF0Y2ggbiwgeHMgd2l0aFxuICB8IDAsIF9cbiAgfCBfLCBbXSAtPlxuICAgICAgW11cbiAgfCBfLCAoeCA6OiB4cyBhcyBpbnB1dCkgLT5cbiAgICAgbGV0IHhzJyA9IHRha2UgKG4gLSAxKSB4cyBpblxuICAgICBpZiB4cyA9PSB4cycgdGhlblxuICAgICAgIGlucHV0XG4gICAgIGVsc2VcbiAgICAgICB4IDo6IHhzJ1xuXG5sZXQgcmVjIGRyb3AgbiB4cyA9XG4gIG1hdGNoIG4sIHhzIHdpdGhcbiAgfCAwLCBfIC0+XG4gICAgICB4c1xuICB8IF8sIFtdIC0+XG4gICAgICBbXVxuICB8IF8sIF8gOjogeHMgLT5cbiAgICAgIGRyb3AgKG4gLSAxKSB4c1xuXG5sZXQgcmVjIHVuaXExIGNtcCB4IHlzID1cbiAgbWF0Y2ggeXMgd2l0aFxuICB8IFtdIC0+XG4gICAgICBbXVxuICB8IHkgOjogeXMgLT5cbiAgICAgIGlmIGNtcCB4IHkgPSAwIHRoZW5cbiAgICAgICAgdW5pcTEgY21wIHggeXNcbiAgICAgIGVsc2VcbiAgICAgICAgeSA6OiB1bmlxMSBjbXAgeSB5c1xuXG5sZXQgdW5pcSBjbXAgeHMgPVxuICBtYXRjaCB4cyB3aXRoXG4gIHwgW10gLT5cbiAgICAgIFtdXG4gIHwgeCA6OiB4cyAtPlxuICAgICAgeCA6OiB1bmlxMSBjbXAgeCB4c1xuXG5sZXQgd2VlZCBjbXAgeHMgPVxuICB1bmlxIGNtcCAoTGlzdC5zb3J0IGNtcCB4cylcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbigqIFN0cmVhbXMuICopXG5cbnR5cGUgJ2Egc3RyZWFtID1cbiAgICAnYSBoZWFkIExhenkudFxuXG5hbmQgJ2EgaGVhZCA9XG4gIHwgTmlsXG4gIHwgQ29ucyBvZiAnYSAqICdhIHN0cmVhbVxuXG4oKiBUaGUgbGVuZ3RoIG9mIGEgc3RyZWFtLiAqKVxuXG5sZXQgcmVjIGxlbmd0aCB4cyA9XG4gIG1hdGNoIExhenkuZm9yY2UgeHMgd2l0aFxuICB8IE5pbCAtPlxuICAgICAgMFxuICB8IENvbnMgKF8sIHhzKSAtPlxuICAgICAgMSArIGxlbmd0aCB4c1xuXG4oKiBGb2xkaW5nIG92ZXIgYSBzdHJlYW0uICopXG5cbmxldCByZWMgZm9sZHIgZiB4cyBhY2N1ID1cbiAgbWF0Y2ggTGF6eS5mb3JjZSB4cyB3aXRoXG4gIHwgTmlsIC0+XG4gICAgICBhY2N1XG4gIHwgQ29ucyAoeCwgeHMpIC0+XG4gICAgICBmIHggKGZvbGRyIGYgeHMgYWNjdSlcbmVuZFxubW9kdWxlIENvbnZlcnQgPSBzdHJ1Y3RcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCBJbnJpYS4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyICAgICAqKVxuKCogICB0aGUgdGVybXMgb2YgdGhlIEdOVSBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLCB3aXRoIGEgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZywgYXMgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQW4gb2NhbWx5YWNjLXN0eWxlLCBvciBNZW5oaXItc3R5bGUsIHBhcnNlciByZXF1aXJlcyBhY2Nlc3MgdG9cbiAgIHRoZSBsZXhlciwgd2hpY2ggbXVzdCBiZSBwYXJhbWV0ZXJpemVkIHdpdGggYSBsZXhpbmcgYnVmZmVyLCBhbmRcbiAgIHRvIHRoZSBsZXhpbmcgYnVmZmVyIGl0c2VsZiwgd2hlcmUgaXQgcmVhZHMgcG9zaXRpb24gaW5mb3JtYXRpb24uICopXG5cbigqIFRoaXMgdHJhZGl0aW9uYWwgQVBJIGlzIGNvbnZlbmllbnQgd2hlbiB1c2VkIHdpdGggb2NhbWxsZXgsIGJ1dFxuICAgaW5lbGVnYW50IHdoZW4gdXNlZCB3aXRoIG90aGVyIGxleGVyIGdlbmVyYXRvcnMuICopXG5cbnR5cGUgKCd0b2tlbiwgJ3NlbWFudGljX3ZhbHVlKSB0cmFkaXRpb25hbCA9XG4gICAgKExleGluZy5sZXhidWYgLT4gJ3Rva2VuKSAtPiBMZXhpbmcubGV4YnVmIC0+ICdzZW1hbnRpY192YWx1ZVxuXG4oKiBUaGlzIHJldmlzZWQgQVBJIGlzIGluZGVwZW5kZW50IG9mIGFueSBsZXhlciBnZW5lcmF0b3IuIEhlcmUsIHRoZVxuICAgcGFyc2VyIG9ubHkgcmVxdWlyZXMgYWNjZXNzIHRvIHRoZSBsZXhlciwgYW5kIHRoZSBsZXhlciB0YWtlcyBub1xuICAgcGFyYW1ldGVycy4gVGhlIHRva2VucyByZXR1cm5lZCBieSB0aGUgbGV4ZXIgbWF5IGNvbnRhaW4gcG9zaXRpb25cbiAgIGluZm9ybWF0aW9uLiAqKVxuXG50eXBlICgndG9rZW4sICdzZW1hbnRpY192YWx1ZSkgcmV2aXNlZCA9XG4gICAgKHVuaXQgLT4gJ3Rva2VuKSAtPiAnc2VtYW50aWNfdmFsdWVcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbigqIENvbnZlcnRpbmcgYSB0cmFkaXRpb25hbCBwYXJzZXIsIHByb2R1Y2VkIGJ5IG9jYW1seWFjYyBvciBNZW5oaXIsXG4gICBpbnRvIGEgcmV2aXNlZCBwYXJzZXIuICopXG5cbigqIEEgdG9rZW4gb2YgdGhlIHJldmlzZWQgbGV4ZXIgaXMgZXNzZW50aWFsbHkgYSB0cmlwbGUgb2YgYSB0b2tlblxuICAgb2YgdGhlIHRyYWRpdGlvbmFsIGxleGVyIChvciByYXcgdG9rZW4pLCBhIHN0YXJ0IHBvc2l0aW9uLCBhbmRcbiAgIGFuZCBlbmQgcG9zaXRpb24uIFRoZSB0aHJlZSBbZ2V0XSBmdW5jdGlvbnMgYXJlIGFjY2Vzc29ycy4gKilcblxuKCogV2UgZG8gbm90IHJlcXVpcmUgdGhlIHR5cGUgWyd0b2tlbl0gdG8gYWN0dWFsbHkgYmUgYSB0cmlwbGUgdHlwZS5cbiAgIFRoaXMgZW5hYmxlcyBjb21wbGV4IGFwcGxpY2F0aW9ucyB3aGVyZSBpdCBpcyBhIHJlY29yZCB0eXBlIHdpdGhcbiAgIG1vcmUgdGhhbiB0aHJlZSBmaWVsZHMuIEl0IGFsc28gZW5hYmxlcyBzaW1wbGUgYXBwbGljYXRpb25zIHdoZXJlXG4gICBwb3NpdGlvbnMgYXJlIG9mIG5vIGludGVyZXN0LCBzbyBbJ3Rva2VuXSBpcyBqdXN0IFsncmF3X3Rva2VuXVxuICAgYW5kIFtnZXRfc3RhcnRwXSBhbmQgW2dldF9lbmRwXSByZXR1cm4gZHVtbXkgcG9zaXRpb25zLiAqKVxuXG5sZXQgdHJhZGl0aW9uYWwycmV2aXNlZFxuICAoZ2V0X3Jhd190b2tlbiA6ICd0b2tlbiAtPiAncmF3X3Rva2VuKVxuICAoZ2V0X3N0YXJ0cCAgICA6ICd0b2tlbiAtPiBMZXhpbmcucG9zaXRpb24pXG4gIChnZXRfZW5kcCAgICAgIDogJ3Rva2VuIC0+IExleGluZy5wb3NpdGlvbilcbiAgKHBhcnNlciA6ICgncmF3X3Rva2VuLCAnc2VtYW50aWNfdmFsdWUpIHRyYWRpdGlvbmFsKVxuOiAoJ3Rva2VuLCAnc2VtYW50aWNfdmFsdWUpIHJldmlzZWQgPVxuXG4gICgqIEFjY2VwdCBhIHJldmlzZWQgbGV4ZXIuICopXG5cbiAgZnVuIChsZXhlciA6IHVuaXQgLT4gJ3Rva2VuKSAtPlxuXG4gICAgKCogQ3JlYXRlIGEgZHVtbXkgbGV4aW5nIGJ1ZmZlci4gKilcblxuICAgIGxldCBsZXhidWYgOiBMZXhpbmcubGV4YnVmID1cbiAgICAgIExleGluZy5mcm9tX3N0cmluZyBcIlwiXG4gICAgaW5cblxuICAgICgqIFdyYXAgdGhlIHJldmlzZWQgbGV4ZXIgYXMgYSB0cmFkaXRpb25hbCBsZXhlci4gQSB0cmFkaXRpb25hbFxuICAgICAgIGxleGVyIHJldHVybnMgYSByYXcgdG9rZW4gYW5kIHVwZGF0ZXMgdGhlIGZpZWxkcyBvZiB0aGUgbGV4aW5nXG4gICAgICAgYnVmZmVyIHdpdGggbmV3IHBvc2l0aW9ucywgd2hpY2ggd2lsbCBiZSByZWFkIGJ5IHRoZSBwYXJzZXIuICopXG5cbiAgICBsZXQgbGV4ZXIgKGxleGJ1ZiA6IExleGluZy5sZXhidWYpIDogJ3Jhd190b2tlbiA9XG4gICAgICBsZXQgdG9rZW4gOiAndG9rZW4gPSBsZXhlcigpIGluXG4gICAgICBsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wIDwtIGdldF9zdGFydHAgdG9rZW47XG4gICAgICBsZXhidWYuTGV4aW5nLmxleF9jdXJyX3AgPC0gZ2V0X2VuZHAgdG9rZW47XG4gICAgICBnZXRfcmF3X3Rva2VuIHRva2VuXG4gICAgaW5cblxuICAgICgqIEludm9rZSB0aGUgdHJhZGl0aW9uYWwgcGFyc2VyLiAqKVxuXG4gICAgcGFyc2VyIGxleGVyIGxleGJ1ZlxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuKCogQ29udmVydGluZyBhIHJldmlzZWQgcGFyc2VyIGJhY2sgdG8gYSB0cmFkaXRpb25hbCBwYXJzZXIuICopXG5cbmxldCByZXZpc2VkMnRyYWRpdGlvbmFsXG4gIChtYWtlX3Rva2VuIDogJ3Jhd190b2tlbiAtPiBMZXhpbmcucG9zaXRpb24gLT4gTGV4aW5nLnBvc2l0aW9uIC0+ICd0b2tlbilcbiAgKHBhcnNlciA6ICgndG9rZW4sICdzZW1hbnRpY192YWx1ZSkgcmV2aXNlZClcbjogKCdyYXdfdG9rZW4sICdzZW1hbnRpY192YWx1ZSkgdHJhZGl0aW9uYWwgPVxuXG4gICgqIEFjY2VwdCBhIHRyYWRpdGlvbmFsIGxleGVyIGFuZCBhIGxleGluZyBidWZmZXIuICopXG5cbiAgZnVuIChsZXhlciA6IExleGluZy5sZXhidWYgLT4gJ3Jhd190b2tlbikgKGxleGJ1ZiA6IExleGluZy5sZXhidWYpIC0+XG5cbiAgICAoKiBXcmFwIHRoZSB0cmFkaXRpb25hbCBsZXhlciBhcyBhIHJldmlzZWQgbGV4ZXIuICopXG5cbiAgICBsZXQgbGV4ZXIgKCkgOiAndG9rZW4gPVxuICAgICAgbGV0IHRva2VuIDogJ3Jhd190b2tlbiA9IGxleGVyIGxleGJ1ZiBpblxuICAgICAgbWFrZV90b2tlbiB0b2tlbiBsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wIGxleGJ1Zi5MZXhpbmcubGV4X2N1cnJfcFxuICAgIGluXG5cbiAgICAoKiBJbnZva2UgdGhlIHJldmlzZWQgcGFyc2VyLiAqKVxuXG4gICAgcGFyc2VyIGxleGVyXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4oKiBTaW1wbGlmaWVkIHZlcnNpb25zIG9mIHRoZSBhYm92ZSwgd2hlcmUgY29uY3JldGUgdHJpcGxlcyBhcmUgdXNlZC4gKilcblxubW9kdWxlIFNpbXBsaWZpZWQgPSBzdHJ1Y3RcblxuICBsZXQgdHJhZGl0aW9uYWwycmV2aXNlZCBwYXJzZXIgPVxuICAgIHRyYWRpdGlvbmFsMnJldmlzZWRcbiAgICAgIChmdW4gKHRva2VuLCBfLCBfKSAgLT4gdG9rZW4pXG4gICAgICAoZnVuIChfLCBzdGFydHAsIF8pIC0+IHN0YXJ0cClcbiAgICAgIChmdW4gKF8sIF8sIGVuZHApICAgLT4gZW5kcClcbiAgICAgIHBhcnNlclxuXG4gIGxldCByZXZpc2VkMnRyYWRpdGlvbmFsIHBhcnNlciA9XG4gICAgcmV2aXNlZDJ0cmFkaXRpb25hbFxuICAgICAgKGZ1biB0b2tlbiBzdGFydHAgZW5kcCAtPiAodG9rZW4sIHN0YXJ0cCwgZW5kcCkpXG4gICAgICBwYXJzZXJcblxuZW5kXG5lbmRcbm1vZHVsZSBJbmNyZW1lbnRhbEVuZ2luZSA9IHN0cnVjdFxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IElucmlhLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgICAgICopXG4oKiAgIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIsIHdpdGggYSAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nLCBhcyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHBvc2l0aW9uID0gTGV4aW5nLnBvc2l0aW9uXG5cbm9wZW4gR2VuZXJhbFxuXG4oKiBUaGlzIHNpZ25hdHVyZSBkZXNjcmliZXMgdGhlIGluY3JlbWVudGFsIExSIGVuZ2luZS4gKilcblxuKCogSW4gdGhpcyBtb2RlLCB0aGUgdXNlciBjb250cm9scyB0aGUgbGV4ZXIsIGFuZCB0aGUgcGFyc2VyIHN1c3BlbmRzXG4gICBpdHNlbGYgd2hlbiBpdCBuZWVkcyB0byByZWFkIGEgbmV3IHRva2VuLiAqKVxuXG5tb2R1bGUgdHlwZSBJTkNSRU1FTlRBTF9FTkdJTkUgPSBzaWdcblxuICB0eXBlIHRva2VuXG5cbiAgKCogQSB2YWx1ZSBvZiB0eXBlIFtwcm9kdWN0aW9uXSBpcyAoYW4gaW5kZXggZm9yKSBhIHByb2R1Y3Rpb24uIFRoZSBzdGFydFxuICAgICBwcm9kdWN0aW9ucyAod2hpY2ggZG8gbm90IGV4aXN0IGluIGFuIFxcbWx5IGZpbGUsIGJ1dCBhcmUgY29uc3RydWN0ZWQgYnlcbiAgICAgTWVuaGlyIGludGVybmFsbHkpIGFyZSBub3QgcGFydCBvZiB0aGlzIHR5cGUuICopXG5cbiAgdHlwZSBwcm9kdWN0aW9uXG5cbiAgKCogVGhlIHR5cGUgWydhIGNoZWNrcG9pbnRdIHJlcHJlc2VudHMgYW4gaW50ZXJtZWRpYXRlIG9yIGZpbmFsIHN0YXRlIG9mIHRoZVxuICAgICBwYXJzZXIuIEFuIGludGVybWVkaWF0ZSBjaGVja3BvaW50IGlzIGEgc3VzcGVuc2lvbjogaXQgcmVjb3JkcyB0aGUgcGFyc2VyJ3NcbiAgICAgY3VycmVudCBzdGF0ZSwgYW5kIGFsbG93cyBwYXJzaW5nIHRvIGJlIHJlc3VtZWQuIFRoZSBwYXJhbWV0ZXIgWydhXSBpc1xuICAgICB0aGUgdHlwZSBvZiB0aGUgc2VtYW50aWMgdmFsdWUgdGhhdCB3aWxsIGV2ZW50dWFsbHkgYmUgcHJvZHVjZWQgaWYgdGhlXG4gICAgIHBhcnNlciBzdWNjZWVkcy4gKilcblxuICAoKiBbQWNjZXB0ZWRdIGFuZCBbUmVqZWN0ZWRdIGFyZSBmaW5hbCBjaGVja3BvaW50cy4gW0FjY2VwdGVkXSBjYXJyaWVzIGFcbiAgICAgc2VtYW50aWMgdmFsdWUuICopXG5cbiAgKCogW0lucHV0TmVlZGVkXSBpcyBhbiBpbnRlcm1lZGlhdGUgY2hlY2twb2ludC4gSXQgbWVhbnMgdGhhdCB0aGUgcGFyc2VyIHdpc2hlc1xuICAgICB0byByZWFkIG9uZSB0b2tlbiBiZWZvcmUgY29udGludWluZy4gKilcblxuICAoKiBbU2hpZnRpbmddIGlzIGFuIGludGVybWVkaWF0ZSBjaGVja3BvaW50LiBJdCBtZWFucyB0aGF0IHRoZSBwYXJzZXIgaXMgdGFraW5nXG4gICAgIGEgc2hpZnQgdHJhbnNpdGlvbi4gSXQgZXhwb3NlcyB0aGUgc3RhdGUgb2YgdGhlIHBhcnNlciBiZWZvcmUgYW5kIGFmdGVyXG4gICAgIHRoZSB0cmFuc2l0aW9uLiBUaGUgQm9vbGVhbiBwYXJhbWV0ZXIgdGVsbHMgd2hldGhlciB0aGUgcGFyc2VyIGludGVuZHMgdG9cbiAgICAgcmVxdWVzdCBhIG5ldyB0b2tlbiBhZnRlciB0aGlzIHRyYW5zaXRpb24uIChJdCBhbHdheXMgZG9lcywgZXhjZXB0IHdoZW5cbiAgICAgaXQgaXMgYWJvdXQgdG8gYWNjZXB0LikgKilcblxuICAoKiBbQWJvdXRUb1JlZHVjZV0gaXMgYW4gaW50ZXJtZWRpYXRlIGNoZWNrcG9pbnQuIEl0IG1lYW5zIHRoYXQgdGhlIHBhcnNlciBpc1xuICAgICBhYm91dCB0byBwZXJmb3JtIGEgcmVkdWN0aW9uIHN0ZXAuIEl0IGV4cG9zZXMgdGhlIHBhcnNlcidzIGN1cnJlbnRcbiAgICAgc3RhdGUgYXMgd2VsbCBhcyB0aGUgcHJvZHVjdGlvbiB0aGF0IGlzIGFib3V0IHRvIGJlIHJlZHVjZWQuICopXG5cbiAgKCogW0hhbmRsaW5nRXJyb3JdIGlzIGFuIGludGVybWVkaWF0ZSBjaGVja3BvaW50LiBJdCBtZWFucyB0aGF0IHRoZSBwYXJzZXIgaGFzXG4gICAgIGRldGVjdGVkIGFuIGVycm9yIGFuZCBpcyBjdXJyZW50bHkgaGFuZGxpbmcgaXQsIGluIHNldmVyYWwgc3RlcHMuICopXG5cbiAgKCogQSB2YWx1ZSBvZiB0eXBlIFsnYSBlbnZdIHJlcHJlc2VudHMgYSBjb25maWd1cmF0aW9uIG9mIHRoZSBhdXRvbWF0b246XG4gICAgIGN1cnJlbnQgc3RhdGUsIHN0YWNrLCBsb29rYWhlYWQgdG9rZW4sIGV0Yy4gVGhlIHBhcmFtZXRlciBbJ2FdIGlzIHRoZVxuICAgICB0eXBlIG9mIHRoZSBzZW1hbnRpYyB2YWx1ZSB0aGF0IHdpbGwgZXZlbnR1YWxseSBiZSBwcm9kdWNlZCBpZiB0aGUgcGFyc2VyXG4gICAgIHN1Y2NlZWRzLiAqKVxuXG4gICgqIEluIG5vcm1hbCBvcGVyYXRpb24sIHRoZSBwYXJzZXIgd29ya3Mgd2l0aCBjaGVja3BvaW50czogc2VlIHRoZSBmdW5jdGlvbnNcbiAgICAgW29mZmVyXSBhbmQgW3Jlc3VtZV0uIEhvd2V2ZXIsIGl0IGlzIGFsc28gcG9zc2libGUgdG8gd29yayBkaXJlY3RseSB3aXRoXG4gICAgIGVudmlyb25tZW50cyAoc2VlIHRoZSBmdW5jdGlvbnMgW3BvcF0sIFtmb3JjZV9yZWR1Y3Rpb25dLCBhbmQgW2ZlZWRdKSBhbmRcbiAgICAgdG8gcmVjb25zdHJ1Y3QgYSBjaGVja3BvaW50IG91dCBvZiBhbiBlbnZpcm9ubWVudCAoc2VlIFtpbnB1dF9uZWVkZWRdKS5cbiAgICAgVGhpcyBpcyBjb25zaWRlcmVkIGFkdmFuY2VkIGZ1bmN0aW9uYWxpdHk7IGl0cyBwdXJwb3NlIGlzIHRvIGFsbG93IGVycm9yXG4gICAgIHJlY292ZXJ5IHN0cmF0ZWdpZXMgdG8gYmUgcHJvZ3JhbW1lZCBieSB0aGUgdXNlci4gKilcblxuICB0eXBlICdhIGVudlxuXG4gIHR5cGUgJ2EgY2hlY2twb2ludCA9IHByaXZhdGVcbiAgICB8IElucHV0TmVlZGVkIG9mICdhIGVudlxuICAgIHwgU2hpZnRpbmcgb2YgJ2EgZW52ICogJ2EgZW52ICogYm9vbFxuICAgIHwgQWJvdXRUb1JlZHVjZSBvZiAnYSBlbnYgKiBwcm9kdWN0aW9uXG4gICAgfCBIYW5kbGluZ0Vycm9yIG9mICdhIGVudlxuICAgIHwgQWNjZXB0ZWQgb2YgJ2FcbiAgICB8IFJlamVjdGVkXG5cbiAgKCogW29mZmVyXSBhbGxvd3MgdGhlIHVzZXIgdG8gcmVzdW1lIHRoZSBwYXJzZXIgYWZ0ZXIgaXQgaGFzIHN1c3BlbmRlZFxuICAgICBpdHNlbGYgd2l0aCBhIGNoZWNrcG9pbnQgb2YgdGhlIGZvcm0gW0lucHV0TmVlZGVkIGVudl0uIFtvZmZlcl0gZXhwZWN0c1xuICAgICB0aGUgb2xkIGNoZWNrcG9pbnQgYXMgd2VsbCBhcyBhIG5ldyB0b2tlbiBhbmQgcHJvZHVjZXMgYSBuZXcgY2hlY2twb2ludC5cbiAgICAgSXQgZG9lcyBub3QgcmFpc2UgYW55IGV4Y2VwdGlvbi4gKilcblxuICB2YWwgb2ZmZXI6XG4gICAgJ2EgY2hlY2twb2ludCAtPlxuICAgIHRva2VuICogcG9zaXRpb24gKiBwb3NpdGlvbiAtPlxuICAgICdhIGNoZWNrcG9pbnRcblxuICAoKiBbcmVzdW1lXSBhbGxvd3MgdGhlIHVzZXIgdG8gcmVzdW1lIHRoZSBwYXJzZXIgYWZ0ZXIgaXQgaGFzIHN1c3BlbmRlZFxuICAgICBpdHNlbGYgd2l0aCBhIGNoZWNrcG9pbnQgb2YgdGhlIGZvcm0gW1NoaWZ0aW5nIF9dLCBbQWJvdXRUb1JlZHVjZSBfXSwgb3JcbiAgICAgW0hhbmRsaW5nRXJyb3IgX10uIFtyZXN1bWVdIGV4cGVjdHMgdGhlIG9sZCBjaGVja3BvaW50IGFuZCBwcm9kdWNlcyBhXG4gICAgIG5ldyBjaGVja3BvaW50LiBJdCBkb2VzIG5vdCByYWlzZSBhbnkgZXhjZXB0aW9uLiAqKVxuXG4gICgqIFRoZSBvcHRpb25hbCBhcmd1bWVudCBbc3RyYXRlZ3ldIGluZmx1ZW5jZXMgdGhlIG1hbm5lciBpbiB3aGljaCBbcmVzdW1lXVxuICAgICBkZWFscyB3aXRoIGNoZWNrcG9pbnRzIG9mIHRoZSBmb3JtIFtIYW5kbGluZ0Vycm9yIF9dLiBJdHMgZGVmYXVsdCB2YWx1ZVxuICAgICBpcyBbYExlZ2FjeV0uIEl0IGNhbiBiZSBicmllZmx5IGRlc2NyaWJlZCBhcyBmb2xsb3dzOlxuXG4gICAgIC0gSWYgdGhlIFtlcnJvcl0gdG9rZW4gaXMgdXNlZCBvbmx5IHRvIHJlcG9ydCBlcnJvcnMgKHRoYXQgaXMsIGlmIHRoZVxuICAgICAgIFtlcnJvcl0gdG9rZW4gYXBwZWFycyBvbmx5IGF0IHRoZSBlbmQgb2YgYSBwcm9kdWN0aW9uLCB3aG9zZSBzZW1hbnRpY1xuICAgICAgIGFjdGlvbiByYWlzZXMgYW4gZXhjZXB0aW9uKSB0aGVuIHRoZSBzaW1wbGlmaWVkIHN0cmF0ZWd5IHNob3VsZCBiZVxuICAgICAgIHByZWZlcnJlZC4gKFRoaXMgaW5jbHVkZXMgdGhlIGNhc2Ugd2hlcmUgdGhlIFtlcnJvcl0gdG9rZW4gZG9lcyBub3RcbiAgICAgICBhcHBlYXIgYXQgYWxsIGluIHRoZSBncmFtbWFyLilcblxuICAgICAtIElmIHRoZSBbZXJyb3JdIHRva2VuIGlzIHVzZWQgdG8gcmVjb3ZlciBhZnRlciBhbiBlcnJvciwgb3IgaWZcbiAgICAgICBwZXJmZWN0IGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgaXMgcmVxdWlyZWQsIHRoZSBsZWdhY3kgc3RyYXRlZ3lcbiAgICAgICBzaG91bGQgYmUgc2VsZWN0ZWQuXG5cbiAgICAgTW9yZSBkZXRhaWxzIG9uIHRoZXNlIHN0cmF0ZWdpZXMgYXBwZWFyIGluIHRoZSBmaWxlIFtFbmdpbmUubWxdLiAqKVxuXG4gIHR5cGUgc3RyYXRlZ3kgPVxuICAgIFsgYExlZ2FjeSB8IGBTaW1wbGlmaWVkIF1cblxuICB2YWwgcmVzdW1lOlxuICAgID9zdHJhdGVneTpzdHJhdGVneSAtPlxuICAgICdhIGNoZWNrcG9pbnQgLT5cbiAgICAnYSBjaGVja3BvaW50XG5cbiAgKCogQSB0b2tlbiBzdXBwbGllciBpcyBhIGZ1bmN0aW9uIG9mIG5vIGFyZ3VtZW50cyB3aGljaCBkZWxpdmVycyBhIG5ldyB0b2tlblxuICAgICAodG9nZXRoZXIgd2l0aCBpdHMgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMpIGV2ZXJ5IHRpbWUgaXQgaXMgY2FsbGVkLiAqKVxuXG4gIHR5cGUgc3VwcGxpZXIgPVxuICAgIHVuaXQgLT4gdG9rZW4gKiBwb3NpdGlvbiAqIHBvc2l0aW9uXG5cbiAgKCogQSBwYWlyIG9mIGEgbGV4ZXIgYW5kIGEgbGV4aW5nIGJ1ZmZlciBjYW4gYmUgZWFzaWx5IHR1cm5lZCBpbnRvIGFcbiAgICAgc3VwcGxpZXIuICopXG5cbiAgdmFsIGxleGVyX2xleGJ1Zl90b19zdXBwbGllcjpcbiAgICAoTGV4aW5nLmxleGJ1ZiAtPiB0b2tlbikgLT5cbiAgICBMZXhpbmcubGV4YnVmIC0+XG4gICAgc3VwcGxpZXJcblxuICAoKiBUaGUgZnVuY3Rpb25zIFtvZmZlcl0gYW5kIFtyZXN1bWVdIGFyZSBzdWZmaWNpZW50IHRvIHdyaXRlIGEgcGFyc2VyIGxvb3AuXG4gICAgIE9uZSBjYW4gaW1hZ2luZSBtYW55IHZhcmlhdGlvbnMgKHdoaWNoIGlzIHdoeSB3ZSBleHBvc2UgdGhlc2UgZnVuY3Rpb25zXG4gICAgIGluIHRoZSBmaXJzdCBwbGFjZSEpLiBIZXJlLCB3ZSBleHBvc2UgYSBmZXcgdmFyaWF0aW9ucyBvZiB0aGUgbWFpbiBsb29wLFxuICAgICByZWFkeSBmb3IgdXNlLiAqKVxuXG4gICgqIFtsb29wIHN1cHBsaWVyIGNoZWNrcG9pbnRdIGJlZ2lucyBwYXJzaW5nIGZyb20gW2NoZWNrcG9pbnRdLCByZWFkaW5nXG4gICAgIHRva2VucyBmcm9tIFtzdXBwbGllcl0uIEl0IGNvbnRpbnVlcyBwYXJzaW5nIHVudGlsIGl0IHJlYWNoZXMgYVxuICAgICBjaGVja3BvaW50IG9mIHRoZSBmb3JtIFtBY2NlcHRlZCB2XSBvciBbUmVqZWN0ZWRdLiBJbiB0aGUgZm9ybWVyIGNhc2UsIGl0XG4gICAgIHJldHVybnMgW3ZdLiBJbiB0aGUgbGF0dGVyIGNhc2UsIGl0IHJhaXNlcyB0aGUgZXhjZXB0aW9uIFtFcnJvcl0uXG4gICAgIFRoZSBvcHRpb25hbCBhcmd1bWVudCBbc3RyYXRlZ3ldLCB3aG9zZSBkZWZhdWx0IHZhbHVlIGlzIFtMZWdhY3ldLFxuICAgICBpcyBwYXNzZWQgdG8gW3Jlc3VtZV0gYW5kIGluZmx1ZW5jZXMgdGhlIGVycm9yLWhhbmRsaW5nIHN0cmF0ZWd5LiAqKVxuXG4gIHZhbCBsb29wOiA/c3RyYXRlZ3k6c3RyYXRlZ3kgLT4gc3VwcGxpZXIgLT4gJ2EgY2hlY2twb2ludCAtPiAnYVxuXG4gICgqIFtsb29wX2hhbmRsZSBzdWNjZWVkIGZhaWwgc3VwcGxpZXIgY2hlY2twb2ludF0gYmVnaW5zIHBhcnNpbmcgZnJvbVxuICAgICBbY2hlY2twb2ludF0sIHJlYWRpbmcgdG9rZW5zIGZyb20gW3N1cHBsaWVyXS4gSXQgY29udGludWVzIHBhcnNpbmcgdW50aWxcbiAgICAgaXQgcmVhY2hlcyBhIGNoZWNrcG9pbnQgb2YgdGhlIGZvcm0gW0FjY2VwdGVkIHZdIG9yIFtIYW5kbGluZ0Vycm9yIGVudl1cbiAgICAgKG9yIFtSZWplY3RlZF0sIGJ1dCB0aGF0IHNob3VsZCBub3QgaGFwcGVuLCBhcyBbSGFuZGxpbmdFcnJvciBfXSB3aWxsIGJlXG4gICAgIG9ic2VydmVkIGZpcnN0KS4gSW4gdGhlIGZvcm1lciBjYXNlLCBpdCBjYWxscyBbc3VjY2VlZCB2XS4gSW4gdGhlIGxhdHRlclxuICAgICBjYXNlLCBpdCBjYWxscyBbZmFpbF0gd2l0aCB0aGlzIGNoZWNrcG9pbnQuIEl0IGNhbm5vdCByYWlzZSBbRXJyb3JdLlxuXG4gICAgIFRoaXMgbWVhbnMgdGhhdCBNZW5oaXIncyBlcnJvci1oYW5kbGluZyBwcm9jZWR1cmUgZG9lcyBub3QgZ2V0IGEgY2hhbmNlXG4gICAgIHRvIHJ1bi4gRm9yIHRoaXMgcmVhc29uLCB0aGVyZSBpcyBubyBbc3RyYXRlZ3ldIHBhcmFtZXRlci4gSW5zdGVhZCwgdGhlXG4gICAgIHVzZXIgY2FuIGltcGxlbWVudCBoZXIgb3duIGVycm9yIGhhbmRsaW5nIGNvZGUsIGluIHRoZSBbZmFpbF1cbiAgICAgY29udGludWF0aW9uLiAqKVxuXG4gIHZhbCBsb29wX2hhbmRsZTpcbiAgICAoJ2EgLT4gJ2Fuc3dlcikgLT5cbiAgICAoJ2EgY2hlY2twb2ludCAtPiAnYW5zd2VyKSAtPlxuICAgIHN1cHBsaWVyIC0+ICdhIGNoZWNrcG9pbnQgLT4gJ2Fuc3dlclxuXG4gICgqIFtsb29wX2hhbmRsZV91bmRvXSBpcyBhbmFsb2dvdXMgdG8gW2xvb3BfaGFuZGxlXSwgZXhjZXB0IGl0IHBhc3NlcyBhIHBhaXJcbiAgICAgb2YgY2hlY2twb2ludHMgdG8gdGhlIGZhaWx1cmUgY29udGludWF0aW9uLlxuXG4gICAgIFRoZSBmaXJzdCAoYW5kIG9sZGVzdCkgY2hlY2twb2ludCBpcyB0aGUgbGFzdCBbSW5wdXROZWVkZWRdIGNoZWNrcG9pbnQgdGhhdFxuICAgICB3YXMgZW5jb3VudGVyZWQgYmVmb3JlIHRoZSBlcnJvciB3YXMgZGV0ZWN0ZWQuIFRoZSBzZWNvbmQgKGFuZCBuZXdlc3QpXG4gICAgIGNoZWNrcG9pbnQgaXMgd2hlcmUgdGhlIGVycm9yIHdhcyBkZXRlY3RlZCwgYXMgaW4gW2xvb3BfaGFuZGxlXS4gR29pbmcgYmFja1xuICAgICB0byB0aGUgZmlyc3QgY2hlY2twb2ludCBjYW4gYmUgdGhvdWdodCBvZiBhcyB1bmRvaW5nIGFueSByZWR1Y3Rpb25zIHRoYXRcbiAgICAgd2VyZSBwZXJmb3JtZWQgYWZ0ZXIgc2VlaW5nIHRoZSBwcm9ibGVtYXRpYyB0b2tlbi4gKFRoZXNlIHJlZHVjdGlvbnMgbXVzdFxuICAgICBiZSBkZWZhdWx0IHJlZHVjdGlvbnMgb3Igc3B1cmlvdXMgcmVkdWN0aW9ucy4pXG5cbiAgICAgW2xvb3BfaGFuZGxlX3VuZG9dIG11c3QgaW5pdGlhbGx5IGJlIGFwcGxpZWQgdG8gYW4gW0lucHV0TmVlZGVkXSBjaGVja3BvaW50LlxuICAgICBUaGUgcGFyc2VyJ3MgaW5pdGlhbCBjaGVja3BvaW50cyBzYXRpc2Z5IHRoaXMgY29uc3RyYWludC4gKilcblxuICB2YWwgbG9vcF9oYW5kbGVfdW5kbzpcbiAgICAoJ2EgLT4gJ2Fuc3dlcikgLT5cbiAgICAoJ2EgY2hlY2twb2ludCAtPiAnYSBjaGVja3BvaW50IC0+ICdhbnN3ZXIpIC0+XG4gICAgc3VwcGxpZXIgLT4gJ2EgY2hlY2twb2ludCAtPiAnYW5zd2VyXG5cbiAgKCogW3NoaWZ0cyBjaGVja3BvaW50XSBhc3N1bWVzIHRoYXQgW2NoZWNrcG9pbnRdIGhhcyBiZWVuIG9idGFpbmVkIGJ5XG4gICAgIHN1Ym1pdHRpbmcgYSB0b2tlbiB0byB0aGUgcGFyc2VyLiBJdCBydW5zIHRoZSBwYXJzZXIgZnJvbSBbY2hlY2twb2ludF0sXG4gICAgIHRocm91Z2ggYW4gYXJiaXRyYXJ5IG51bWJlciBvZiByZWR1Y3Rpb25zLCB1bnRpbCB0aGUgcGFyc2VyIGVpdGhlclxuICAgICBhY2NlcHRzIHRoaXMgdG9rZW4gKGkuZS4sIHNoaWZ0cykgb3IgcmVqZWN0cyBpdCAoaS5lLiwgc2lnbmFscyBhbiBlcnJvcikuXG4gICAgIElmIHRoZSBwYXJzZXIgZGVjaWRlcyB0byBzaGlmdCwgdGhlbiBbU29tZSBlbnZdIGlzIHJldHVybmVkLCB3aGVyZSBbZW52XVxuICAgICBpcyB0aGUgcGFyc2VyJ3Mgc3RhdGUganVzdCBiZWZvcmUgc2hpZnRpbmcuIE90aGVyd2lzZSwgW05vbmVdIGlzXG4gICAgIHJldHVybmVkLiAqKVxuXG4gICgqIEl0IGlzIGRlc2lyYWJsZSB0aGF0IHRoZSBzZW1hbnRpYyBhY3Rpb25zIGJlIHNpZGUtZWZmZWN0IGZyZWUsIG9yIHRoYXRcbiAgICAgdGhlaXIgc2lkZS1lZmZlY3RzIGJlIGhhcm1sZXNzIChyZXBsYXlhYmxlKS4gKilcblxuICB2YWwgc2hpZnRzOiAnYSBjaGVja3BvaW50IC0+ICdhIGVudiBvcHRpb25cblxuICAoKiBUaGUgZnVuY3Rpb24gW2FjY2VwdGFibGVdIGFsbG93cyB0ZXN0aW5nLCBhZnRlciBhbiBlcnJvciBoYXMgYmVlblxuICAgICBkZXRlY3RlZCwgd2hpY2ggdG9rZW5zIHdvdWxkIGhhdmUgYmVlbiBhY2NlcHRlZCBhdCB0aGlzIHBvaW50LiBJdCBpc1xuICAgICBpbXBsZW1lbnRlZCB1c2luZyBbc2hpZnRzXS4gSXRzIGFyZ3VtZW50IHNob3VsZCBiZSBhbiBbSW5wdXROZWVkZWRdXG4gICAgIGNoZWNrcG9pbnQuICopXG5cbiAgKCogRm9yIGNvbXBsZXRlbmVzcywgb25lIG11c3QgdW5kbyBhbnkgc3B1cmlvdXMgcmVkdWN0aW9ucyBiZWZvcmUgY2Fycnlpbmcgb3V0XG4gICAgIHRoaXMgdGVzdCAtLSB0aGF0IGlzLCBvbmUgbXVzdCBhcHBseSBbYWNjZXB0YWJsZV0gdG8gdGhlIEZJUlNUIGNoZWNrcG9pbnRcbiAgICAgdGhhdCBpcyBwYXNzZWQgYnkgW2xvb3BfaGFuZGxlX3VuZG9dIHRvIGl0cyBmYWlsdXJlIGNvbnRpbnVhdGlvbi4gKilcblxuICAoKiBUaGlzIHRlc3QgY2F1c2VzIHNvbWUgc2VtYW50aWMgYWN0aW9ucyB0byBiZSBydW4hIFRoZSBzZW1hbnRpYyBhY3Rpb25zXG4gICAgIHNob3VsZCBiZSBzaWRlLWVmZmVjdCBmcmVlLCBvciB0aGVpciBzaWRlLWVmZmVjdHMgc2hvdWxkIGJlIGhhcm1sZXNzLiAqKVxuXG4gICgqIFRoZSBwb3NpdGlvbiBbcG9zXSBpcyB1c2VkIGFzIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBvZiB0aGVcbiAgICAgaHlwb3RoZXRpY2FsIHRva2VuLCBhbmQgbWF5IGJlIHBpY2tlZCB1cCBieSB0aGUgc2VtYW50aWMgYWN0aW9ucy4gV2VcbiAgICAgc3VnZ2VzdCB1c2luZyB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIGVycm9yIHdhcyBkZXRlY3RlZC4gKilcblxuICB2YWwgYWNjZXB0YWJsZTogJ2EgY2hlY2twb2ludCAtPiB0b2tlbiAtPiBwb3NpdGlvbiAtPiBib29sXG5cbiAgKCogVGhlIGFic3RyYWN0IHR5cGUgWydhIGxyMXN0YXRlXSBkZXNjcmliZXMgdGhlIG5vbi1pbml0aWFsIHN0YXRlcyBvZiB0aGVcbiAgICAgTFIoMSkgYXV0b21hdG9uLiBUaGUgaW5kZXggWydhXSByZXByZXNlbnRzIHRoZSB0eXBlIG9mIHRoZSBzZW1hbnRpYyB2YWx1ZVxuICAgICBhc3NvY2lhdGVkIHdpdGggdGhpcyBzdGF0ZSdzIGluY29taW5nIHN5bWJvbC4gKilcblxuICB0eXBlICdhIGxyMXN0YXRlXG5cbiAgKCogVGhlIHN0YXRlcyBvZiB0aGUgTFIoMSkgYXV0b21hdG9uIGFyZSBudW1iZXJlZCAoZnJvbSAwIGFuZCB1cCkuICopXG5cbiAgdmFsIG51bWJlcjogXyBscjFzdGF0ZSAtPiBpbnRcblxuICAoKiBQcm9kdWN0aW9ucyBhcmUgbnVtYmVyZWQuICopXG5cbiAgKCogW2ZpbmRfcHJvZHVjdGlvbiBpXSByZXF1aXJlcyB0aGUgaW5kZXggW2ldIHRvIGJlIHZhbGlkLiBVc2Ugd2l0aCBjYXJlLiAqKVxuXG4gIHZhbCBwcm9kdWN0aW9uX2luZGV4OiBwcm9kdWN0aW9uIC0+IGludFxuICB2YWwgZmluZF9wcm9kdWN0aW9uOiBpbnQgLT4gcHJvZHVjdGlvblxuXG4gICgqIEFuIGVsZW1lbnQgaXMgYSBwYWlyIG9mIGEgbm9uLWluaXRpYWwgc3RhdGUgW3NdIGFuZCBhIHNlbWFudGljIHZhbHVlIFt2XVxuICAgICBhc3NvY2lhdGVkIHdpdGggdGhlIGluY29taW5nIHN5bWJvbCBvZiB0aGlzIHN0YXRlLiBUaGUgaWRlYSBpcywgdGhlIHZhbHVlXG4gICAgIFt2XSB3YXMgcHVzaGVkIG9udG8gdGhlIHN0YWNrIGp1c3QgYmVmb3JlIHRoZSBzdGF0ZSBbc10gd2FzIGVudGVyZWQuIFRodXMsXG4gICAgIGZvciBzb21lIHR5cGUgWydhXSwgdGhlIHN0YXRlIFtzXSBoYXMgdHlwZSBbJ2EgbHIxc3RhdGVdIGFuZCB0aGUgdmFsdWUgW3ZdXG4gICAgIGhhcyB0eXBlIFsnYV0uIEluIG90aGVyIHdvcmRzLCB0aGUgdHlwZSBbZWxlbWVudF0gaXMgYW4gZXhpc3RlbnRpYWwgdHlwZS4gKilcblxuICB0eXBlIGVsZW1lbnQgPVxuICAgIHwgRWxlbWVudDogJ2EgbHIxc3RhdGUgKiAnYSAqIHBvc2l0aW9uICogcG9zaXRpb24gLT4gZWxlbWVudFxuXG4gICgqIFRoZSBwYXJzZXIncyBzdGFjayBpcyAob3IsIG1vcmUgcHJlY2lzZWx5LCBjYW4gYmUgdmlld2VkIGFzKSBhIHN0cmVhbSBvZlxuICAgICBlbGVtZW50cy4gVGhlIHR5cGUgW3N0cmVhbV0gaXMgZGVmaW5lZCBieSB0aGUgbW9kdWxlIFtHZW5lcmFsXS4gKilcblxuICAoKiBBcyBvZiAyMDE3LzAzLzMxLCB0aGUgdHlwZXMgW3N0cmVhbV0gYW5kIFtzdGFja10gYW5kIHRoZSBmdW5jdGlvbiBbc3RhY2tdXG4gICAgIGFyZSBERVBSRUNBVEVELiBUaGV5IG1pZ2h0IGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gQW4gYWx0ZXJuYXRpdmUgd2F5XG4gICAgIG9mIGluc3BlY3RpbmcgdGhlIHN0YWNrIGlzIHZpYSB0aGUgZnVuY3Rpb25zIFt0b3BdIGFuZCBbcG9wXS4gKilcblxuICB0eXBlIHN0YWNrID0gKCogREVQUkVDQVRFRCAqKVxuICAgIGVsZW1lbnQgc3RyZWFtXG5cbiAgKCogVGhpcyBpcyB0aGUgcGFyc2VyJ3Mgc3RhY2ssIGEgc3RyZWFtIG9mIGVsZW1lbnRzLiBUaGlzIHN0cmVhbSBpcyBlbXB0eSBpZlxuICAgICB0aGUgcGFyc2VyIGlzIGluIGFuIGluaXRpYWwgc3RhdGU7IG90aGVyd2lzZSwgaXQgaXMgbm9uLWVtcHR5LiAgVGhlIExSKDEpXG4gICAgIGF1dG9tYXRvbidzIGN1cnJlbnQgc3RhdGUgaXMgdGhlIG9uZSBmb3VuZCBpbiB0aGUgdG9wIGVsZW1lbnQgb2YgdGhlXG4gICAgIHN0YWNrLiAqKVxuXG4gIHZhbCBzdGFjazogJ2EgZW52IC0+IHN0YWNrICgqIERFUFJFQ0FURUQgKilcblxuICAoKiBbdG9wIGVudl0gcmV0dXJucyB0aGUgcGFyc2VyJ3MgdG9wIHN0YWNrIGVsZW1lbnQuIFRoZSBzdGF0ZSBjb250YWluZWQgaW5cbiAgICAgdGhpcyBzdGFjayBlbGVtZW50IGlzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBhdXRvbWF0b24uIElmIHRoZSBzdGFjayBpc1xuICAgICBlbXB0eSwgW05vbmVdIGlzIHJldHVybmVkLiBJbiB0aGF0IGNhc2UsIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZVxuICAgICBhdXRvbWF0b24gbXVzdCBiZSBhbiBpbml0aWFsIHN0YXRlLiAqKVxuXG4gIHZhbCB0b3A6ICdhIGVudiAtPiBlbGVtZW50IG9wdGlvblxuXG4gICgqIFtwb3BfbWFueSBpIGVudl0gcG9wcyBbaV0gY2VsbHMgb2ZmIHRoZSBhdXRvbWF0b24ncyBzdGFjay4gVGhpcyBpcyBkb25lXG4gICAgIHZpYSBbaV0gc3VjY2Vzc2l2ZSBpbnZvY2F0aW9ucyBvZiBbcG9wXS4gVGh1cywgW3BvcF9tYW55IDFdIGlzIFtwb3BdLiBUaGVcbiAgICAgaW5kZXggW2ldIG11c3QgYmUgbm9ubmVnYXRpdmUuIFRoZSB0aW1lIGNvbXBsZXhpdHkgaXMgTyhpKS4gKilcblxuICB2YWwgcG9wX21hbnk6IGludCAtPiAnYSBlbnYgLT4gJ2EgZW52IG9wdGlvblxuXG4gICgqIFtnZXQgaSBlbnZdIHJldHVybnMgdGhlIHBhcnNlcidzIFtpXS10aCBzdGFjayBlbGVtZW50LiBUaGUgaW5kZXggW2ldIGlzXG4gICAgIDAtYmFzZWQ6IHRodXMsIFtnZXQgMF0gaXMgW3RvcF0uIElmIFtpXSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlXG4gICAgIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgc3RhY2ssIFtOb25lXSBpcyByZXR1cm5lZC4gVGhlIHRpbWUgY29tcGxleGl0eVxuICAgICBpcyBPKGkpLiAqKVxuXG4gIHZhbCBnZXQ6IGludCAtPiAnYSBlbnYgLT4gZWxlbWVudCBvcHRpb25cblxuICAoKiBbY3VycmVudF9zdGF0ZV9udW1iZXIgZW52XSBpcyAodGhlIGludGVnZXIgbnVtYmVyIG9mKSB0aGUgYXV0b21hdG9uJ3NcbiAgICAgY3VycmVudCBzdGF0ZS4gVGhpcyB3b3JrcyBldmVuIGlmIHRoZSBhdXRvbWF0b24ncyBzdGFjayBpcyBlbXB0eSwgaW5cbiAgICAgd2hpY2ggY2FzZSB0aGUgY3VycmVudCBzdGF0ZSBpcyBhbiBpbml0aWFsIHN0YXRlLiBUaGlzIG51bWJlciBjYW4gYmVcbiAgICAgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIGEgW21lc3NhZ2VdIGZ1bmN0aW9uIGdlbmVyYXRlZCBieSBbbWVuaGlyXG4gICAgIC0tY29tcGlsZS1lcnJvcnNdLiAqKVxuXG4gIHZhbCBjdXJyZW50X3N0YXRlX251bWJlcjogJ2EgZW52IC0+IGludFxuXG4gICgqIFtlcXVhbCBlbnYxIGVudjJdIHRlbGxzIHdoZXRoZXIgdGhlIHBhcnNlciBjb25maWd1cmF0aW9ucyBbZW52MV0gYW5kXG4gICAgIFtlbnYyXSBhcmUgZXF1YWwgaW4gdGhlIHNlbnNlIHRoYXQgdGhlIGF1dG9tYXRvbidzIGN1cnJlbnQgc3RhdGUgaXMgdGhlXG4gICAgIHNhbWUgaW4gW2VudjFdIGFuZCBbZW52Ml0gYW5kIHRoZSBzdGFjayBpcyAqcGh5c2ljYWxseSogdGhlIHNhbWUgaW5cbiAgICAgW2VudjFdIGFuZCBbZW52Ml0uIElmIFtlcXVhbCBlbnYxIGVudjJdIGlzIFt0cnVlXSwgdGhlbiB0aGUgc2VxdWVuY2Ugb2ZcbiAgICAgdGhlIHN0YWNrIGVsZW1lbnRzLCBhcyBvYnNlcnZlZCB2aWEgW3BvcF0gYW5kIFt0b3BdLCBtdXN0IGJlIHRoZSBzYW1lIGluXG4gICAgIFtlbnYxXSBhbmQgW2VudjJdLiBBbHNvLCBpZiBbZXF1YWwgZW52MSBlbnYyXSBob2xkcywgdGhlbiB0aGUgY2hlY2twb2ludHNcbiAgICAgW2lucHV0X25lZWRlZCBlbnYxXSBhbmQgW2lucHV0X25lZWRlZCBlbnYyXSBtdXN0IGJlIGVxdWl2YWxlbnQuIFRoZVxuICAgICBmdW5jdGlvbiBbZXF1YWxdIGhhcyB0aW1lIGNvbXBsZXhpdHkgTygxKS4gKilcblxuICB2YWwgZXF1YWw6ICdhIGVudiAtPiAnYSBlbnYgLT4gYm9vbFxuXG4gICgqIFRoZXNlIGFyZSB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgb2YgdGhlIGN1cnJlbnQgbG9va2FoZWFkIHRva2VuLiBJZlxuICAgICBpbnZva2VkIGluIGFuIGluaXRpYWwgc3RhdGUsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHBhaXIgb2YgdHdpY2UgdGhlXG4gICAgIGluaXRpYWwgcG9zaXRpb24uICopXG5cbiAgdmFsIHBvc2l0aW9uczogJ2EgZW52IC0+IHBvc2l0aW9uICogcG9zaXRpb25cblxuICAoKiBXaGVuIGFwcGxpZWQgdG8gYW4gZW52aXJvbm1lbnQgdGFrZW4gZnJvbSBhIGNoZWNrcG9pbnQgb2YgdGhlIGZvcm1cbiAgICAgW0Fib3V0VG9SZWR1Y2UgKGVudiwgcHJvZCldLCB0aGUgZnVuY3Rpb24gW2Vudl9oYXNfZGVmYXVsdF9yZWR1Y3Rpb25dXG4gICAgIHRlbGxzIHdoZXRoZXIgdGhlIHJlZHVjdGlvbiB0aGF0IGlzIGFib3V0IHRvIHRha2UgcGxhY2UgaXMgYSBkZWZhdWx0XG4gICAgIHJlZHVjdGlvbi4gKilcblxuICB2YWwgZW52X2hhc19kZWZhdWx0X3JlZHVjdGlvbjogJ2EgZW52IC0+IGJvb2xcblxuICAoKiBbc3RhdGVfaGFzX2RlZmF1bHRfcmVkdWN0aW9uIHNdIHRlbGxzIHdoZXRoZXIgdGhlIHN0YXRlIFtzXSBoYXMgYSBkZWZhdWx0XG4gICAgIHJlZHVjdGlvbi4gVGhpcyBpbmNsdWRlcyB0aGUgY2FzZSB3aGVyZSBbc10gaXMgYW4gYWNjZXB0aW5nIHN0YXRlLiAqKVxuXG4gIHZhbCBzdGF0ZV9oYXNfZGVmYXVsdF9yZWR1Y3Rpb246IF8gbHIxc3RhdGUgLT4gYm9vbFxuXG4gICgqIFtwb3AgZW52XSByZXR1cm5zIGEgbmV3IGVudmlyb25tZW50LCB3aGVyZSB0aGUgcGFyc2VyJ3MgdG9wIHN0YWNrIGNlbGxcbiAgICAgaGFzIGJlZW4gcG9wcGVkIG9mZi4gKElmIHRoZSBzdGFjayBpcyBlbXB0eSwgW05vbmVdIGlzIHJldHVybmVkLikgVGhpc1xuICAgICBhbW91bnRzIHRvIHByZXRlbmRpbmcgdGhhdCB0aGUgKHRlcm1pbmFsIG9yIG5vbnRlcm1pbmFsKSBzeW1ib2wgdGhhdFxuICAgICBjb3JyZXNwb25kcyB0byB0aGlzIHN0YWNrIGNlbGwgaGFzIG5vdCBiZWVuIHJlYWQuICopXG5cbiAgdmFsIHBvcDogJ2EgZW52IC0+ICdhIGVudiBvcHRpb25cblxuICAoKiBbZm9yY2VfcmVkdWN0aW9uIHByb2QgZW52XSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgaWYgaW4gdGhlIHN0YXRlIFtlbnZdXG4gICAgIHRoZSBwYXJzZXIgaXMgY2FwYWJsZSBvZiByZWR1Y2luZyB0aGUgcHJvZHVjdGlvbiBbcHJvZF0uIElmIHRoaXNcbiAgICAgY29uZGl0aW9uIGlzIHNhdGlzZmllZCwgdGhlbiB0aGlzIHByb2R1Y3Rpb24gaXMgcmVkdWNlZCwgd2hpY2ggbWVhbnMgdGhhdFxuICAgICBpdHMgc2VtYW50aWMgYWN0aW9uIGlzIGV4ZWN1dGVkICh0aGlzIGNhbiBoYXZlIHNpZGUgZWZmZWN0cyEpIGFuZCB0aGVcbiAgICAgYXV0b21hdG9uIG1ha2VzIGEgZ290byAobm9udGVybWluYWwpIHRyYW5zaXRpb24uIElmIHRoaXMgY29uZGl0aW9uIGlzIG5vdFxuICAgICBzYXRpc2ZpZWQsIFtJbnZhbGlkX2FyZ3VtZW50IF9dIGlzIHJhaXNlZC4gKilcblxuICB2YWwgZm9yY2VfcmVkdWN0aW9uOiBwcm9kdWN0aW9uIC0+ICdhIGVudiAtPiAnYSBlbnZcblxuICAoKiBbaW5wdXRfbmVlZGVkIGVudl0gcmV0dXJucyBbSW5wdXROZWVkZWQgZW52XS4gVGhhdCBpcywgb3V0IG9mIGFuIFtlbnZdXG4gICAgIHRoYXQgbWlnaHQgaGF2ZSBiZWVuIG9idGFpbmVkIHZpYSBhIHNlcmllcyBvZiBjYWxscyB0byB0aGUgZnVuY3Rpb25zXG4gICAgIFtwb3BdLCBbZm9yY2VfcmVkdWN0aW9uXSwgW2ZlZWRdLCBldGMuLCBpdCBwcm9kdWNlcyBhIGNoZWNrcG9pbnQsIHdoaWNoXG4gICAgIGNhbiBiZSB1c2VkIHRvIHJlc3VtZSBub3JtYWwgcGFyc2luZywgYnkgc3VwcGx5aW5nIHRoaXMgY2hlY2twb2ludCBhcyBhblxuICAgICBhcmd1bWVudCB0byBbb2ZmZXJdLiAqKVxuXG4gICgqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQgd2l0aCBzb21lIGNhcmUuIEl0IGNvdWxkIFwibWVzcyB1cCB0aGVcbiAgICAgbG9va2FoZWFkXCIgaW4gdGhlIHNlbnNlIHRoYXQgaXQgYWxsb3dzIHBhcnNpbmcgdG8gcmVzdW1lIGluIGFuIGFyYml0cmFyeVxuICAgICBzdGF0ZSBbc10gd2l0aCBhbiBhcmJpdHJhcnkgbG9va2FoZWFkIHN5bWJvbCBbdF0sIGV2ZW4gdGhvdWdoIE1lbmhpcidzXG4gICAgIHJlYWNoYWJpbGl0eSBhbmFseXNpcyAobWVuaGlyIC0tbGlzdC1lcnJvcnMpIG1pZ2h0IHdlbGwgdGhpbmsgdGhhdCBpdCBpc1xuICAgICBpbXBvc3NpYmxlIHRvIHJlYWNoIHRoaXMgcGFydGljdWxhciBjb25maWd1cmF0aW9uLiBJZiBvbmUgaXMgdXNpbmdcbiAgICAgTWVuaGlyJ3MgbmV3IGVycm9yIHJlcG9ydGluZyBmYWNpbGl0eSwgdGhpcyBjb3VsZCBjYXVzZSB0aGUgcGFyc2VyIHRvXG4gICAgIHJlYWNoIGFuIGVycm9yIHN0YXRlIGZvciB3aGljaCBubyBlcnJvciBtZXNzYWdlIGhhcyBiZWVuIHByZXBhcmVkLiAqKVxuXG4gIHZhbCBpbnB1dF9uZWVkZWQ6ICdhIGVudiAtPiAnYSBjaGVja3BvaW50XG5cbmVuZFxuXG4oKiBUaGlzIHNpZ25hdHVyZSBpcyBhIGZyYWdtZW50IG9mIHRoZSBpbnNwZWN0aW9uIEFQSSB0aGF0IGlzIG1hZGUgYXZhaWxhYmxlXG4gICB0byB0aGUgdXNlciB3aGVuIFstLWluc3BlY3Rpb25dIGlzIHVzZWQuIFRoaXMgZnJhZ21lbnQgY29udGFpbnMgdHlwZVxuICAgZGVmaW5pdGlvbnMgZm9yIHN5bWJvbHMuICopXG5cbm1vZHVsZSB0eXBlIFNZTUJPTFMgPSBzaWdcblxuICAoKiBUaGUgdHlwZSBbJ2EgdGVybWluYWxdIHJlcHJlc2VudHMgYSB0ZXJtaW5hbCBzeW1ib2wuIFRoZSB0eXBlIFsnYVxuICAgICBub250ZXJtaW5hbF0gcmVwcmVzZW50cyBhIG5vbnRlcm1pbmFsIHN5bWJvbC4gSW4gYm90aCBjYXNlcywgdGhlIGluZGV4XG4gICAgIFsnYV0gcmVwcmVzZW50cyB0aGUgdHlwZSBvZiB0aGUgc2VtYW50aWMgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzXG4gICAgIHN5bWJvbC4gVGhlIGNvbmNyZXRlIGRlZmluaXRpb25zIG9mIHRoZXNlIHR5cGVzIGFyZSBnZW5lcmF0ZWQuICopXG5cbiAgdHlwZSAnYSB0ZXJtaW5hbFxuICB0eXBlICdhIG5vbnRlcm1pbmFsXG5cbiAgKCogVGhlIHR5cGUgWydhIHN5bWJvbF0gcmVwcmVzZW50cyBhIHRlcm1pbmFsIG9yIG5vbnRlcm1pbmFsIHN5bWJvbC4gSXQgaXNcbiAgICAgdGhlIGRpc2pvaW50IHVuaW9uIG9mIHRoZSB0eXBlcyBbJ2EgdGVybWluYWxdIGFuZCBbJ2Egbm9udGVybWluYWxdLiAqKVxuXG4gIHR5cGUgJ2Egc3ltYm9sID1cbiAgICB8IFQgOiAnYSB0ZXJtaW5hbCAtPiAnYSBzeW1ib2xcbiAgICB8IE4gOiAnYSBub250ZXJtaW5hbCAtPiAnYSBzeW1ib2xcblxuICAoKiBUaGUgdHlwZSBbeHN5bWJvbF0gaXMgYW4gZXhpc3RlbnRpYWxseSBxdWFudGlmaWVkIHZlcnNpb24gb2YgdGhlIHR5cGVcbiAgICAgWydhIHN5bWJvbF0uIFRoaXMgdHlwZSBpcyB1c2VmdWwgaW4gc2l0dWF0aW9ucyB3aGVyZSB0aGUgaW5kZXggWydhXVxuICAgICBpcyBub3Qgc3RhdGljYWxseSBrbm93bi4gKilcblxuICB0eXBlIHhzeW1ib2wgPVxuICAgIHwgWCA6ICdhIHN5bWJvbCAtPiB4c3ltYm9sXG5cbmVuZFxuXG4oKiBUaGlzIHNpZ25hdHVyZSBkZXNjcmliZXMgdGhlIGluc3BlY3Rpb24gQVBJIHRoYXQgaXMgbWFkZSBhdmFpbGFibGUgdG8gdGhlXG4gICB1c2VyIHdoZW4gWy0taW5zcGVjdGlvbl0gaXMgdXNlZC4gKilcblxubW9kdWxlIHR5cGUgSU5TUEVDVElPTiA9IHNpZ1xuXG4gICgqIFRoZSB0eXBlcyBvZiBzeW1ib2xzIGFyZSBkZXNjcmliZWQgYWJvdmUuICopXG5cbiAgaW5jbHVkZSBTWU1CT0xTXG5cbiAgKCogVGhlIHR5cGUgWydhIGxyMXN0YXRlXSBpcyBtZWFudCB0byBiZSB0aGUgc2FtZSBhcyBpbiBbSU5DUkVNRU5UQUxfRU5HSU5FXS4gKilcblxuICB0eXBlICdhIGxyMXN0YXRlXG5cbiAgKCogVGhlIHR5cGUgW3Byb2R1Y3Rpb25dIGlzIG1lYW50IHRvIGJlIHRoZSBzYW1lIGFzIGluIFtJTkNSRU1FTlRBTF9FTkdJTkVdLlxuICAgICBJdCByZXByZXNlbnRzIGEgcHJvZHVjdGlvbiBvZiB0aGUgZ3JhbW1hci4gQSBwcm9kdWN0aW9uIGNhbiBiZSBleGFtaW5lZFxuICAgICB2aWEgdGhlIGZ1bmN0aW9ucyBbbGhzXSBhbmQgW3Joc10gYmVsb3cuICopXG5cbiAgdHlwZSBwcm9kdWN0aW9uXG5cbiAgKCogQW4gTFIoMCkgaXRlbSBpcyBhIHBhaXIgb2YgYSBwcm9kdWN0aW9uIFtwcm9kXSBhbmQgYSB2YWxpZCBpbmRleCBbaV0gaW50b1xuICAgICB0aGlzIHByb2R1Y3Rpb24uIFRoYXQgaXMsIGlmIHRoZSBsZW5ndGggb2YgW3JocyBwcm9kXSBpcyBbbl0sIHRoZW4gW2ldIGlzXG4gICAgIGNvbXByaXNlZCBiZXR3ZWVuIDAgYW5kIFtuXSwgaW5jbHVzaXZlLiAqKVxuXG4gIHR5cGUgaXRlbSA9XG4gICAgICBwcm9kdWN0aW9uICogaW50XG5cbiAgKCogT3JkZXJpbmcgZnVuY3Rpb25zLiAqKVxuXG4gIHZhbCBjb21wYXJlX3Rlcm1pbmFsczogXyB0ZXJtaW5hbCAtPiBfIHRlcm1pbmFsIC0+IGludFxuICB2YWwgY29tcGFyZV9ub250ZXJtaW5hbHM6IF8gbm9udGVybWluYWwgLT4gXyBub250ZXJtaW5hbCAtPiBpbnRcbiAgdmFsIGNvbXBhcmVfc3ltYm9sczogeHN5bWJvbCAtPiB4c3ltYm9sIC0+IGludFxuICB2YWwgY29tcGFyZV9wcm9kdWN0aW9uczogcHJvZHVjdGlvbiAtPiBwcm9kdWN0aW9uIC0+IGludFxuICB2YWwgY29tcGFyZV9pdGVtczogaXRlbSAtPiBpdGVtIC0+IGludFxuXG4gICgqIFtpbmNvbWluZ19zeW1ib2wgc10gaXMgdGhlIGluY29taW5nIHN5bWJvbCBvZiB0aGUgc3RhdGUgW3NdLCB0aGF0IGlzLFxuICAgICB0aGUgc3ltYm9sIHRoYXQgdGhlIHBhcnNlciBtdXN0IHJlY29nbml6ZSBiZWZvcmUgKGhhcyByZWNvZ25pemVkIHdoZW4pXG4gICAgIGl0IGVudGVycyB0aGUgc3RhdGUgW3NdLiBUaGlzIGZ1bmN0aW9uIGdpdmVzIGFjY2VzcyB0byB0aGUgc2VtYW50aWNcbiAgICAgdmFsdWUgW3ZdIHN0b3JlZCBpbiBhIHN0YWNrIGVsZW1lbnQgW0VsZW1lbnQgKHMsIHYsIF8sIF8pXS4gSW5kZWVkLFxuICAgICBieSBjYXNlIGFuYWx5c2lzIG9uIHRoZSBzeW1ib2wgW2luY29taW5nX3N5bWJvbCBzXSwgb25lIGRpc2NvdmVycyB0aGVcbiAgICAgdHlwZSBbJ2FdIG9mIHRoZSB2YWx1ZSBbdl0uICopXG5cbiAgdmFsIGluY29taW5nX3N5bWJvbDogJ2EgbHIxc3RhdGUgLT4gJ2Egc3ltYm9sXG5cbiAgKCogW2l0ZW1zIHNdIGlzIHRoZSBzZXQgb2YgdGhlIExSKDApIGl0ZW1zIGluIHRoZSBMUigwKSBjb3JlIG9mIHRoZSBMUigxKVxuICAgICBzdGF0ZSBbc10uIFRoaXMgc2V0IGlzIG5vdCBlcHNpbG9uLWNsb3NlZC4gVGhpcyBzZXQgaXMgcHJlc2VudGVkIGFzIGFcbiAgICAgbGlzdCwgaW4gYW4gYXJiaXRyYXJ5IG9yZGVyLiAqKVxuXG4gIHZhbCBpdGVtczogXyBscjFzdGF0ZSAtPiBpdGVtIGxpc3RcblxuICAoKiBbbGhzIHByb2RdIGlzIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiB0aGUgcHJvZHVjdGlvbiBbcHJvZF0uIFRoaXMgaXNcbiAgICAgYWx3YXlzIGEgbm9uLXRlcm1pbmFsIHN5bWJvbC4gKilcblxuICB2YWwgbGhzOiBwcm9kdWN0aW9uIC0+IHhzeW1ib2xcblxuICAoKiBbcmhzIHByb2RdIGlzIHRoZSByaWdodC1oYW5kIHNpZGUgb2YgdGhlIHByb2R1Y3Rpb24gW3Byb2RdLiBUaGlzIGlzXG4gICAgIGEgKHBvc3NpYmx5IGVtcHR5KSBzZXF1ZW5jZSBvZiAodGVybWluYWwgb3Igbm9udGVybWluYWwpIHN5bWJvbHMuICopXG5cbiAgdmFsIHJoczogcHJvZHVjdGlvbiAtPiB4c3ltYm9sIGxpc3RcblxuICAoKiBbbnVsbGFibGUgbnRdIHRlbGxzIHdoZXRoZXIgdGhlIG5vbi10ZXJtaW5hbCBzeW1ib2wgW250XSBpcyBudWxsYWJsZS5cbiAgICAgVGhhdCBpcywgaXQgaXMgdHJ1ZSBpZiBhbmQgb25seSBpZiB0aGlzIHN5bWJvbCBwcm9kdWNlcyB0aGUgZW1wdHlcbiAgICAgd29yZCBbZXBzaWxvbl0uICopXG5cbiAgdmFsIG51bGxhYmxlOiBfIG5vbnRlcm1pbmFsIC0+IGJvb2xcblxuICAoKiBbZmlyc3QgbnQgdF0gdGVsbHMgd2hldGhlciB0aGUgRklSU1Qgc2V0IG9mIHRoZSBub250ZXJtaW5hbCBzeW1ib2wgW250XVxuICAgICBjb250YWlucyB0aGUgdGVybWluYWwgc3ltYm9sIFt0XS4gVGhhdCBpcywgaXQgaXMgdHJ1ZSBpZiBhbmQgb25seSBpZlxuICAgICBbbnRdIHByb2R1Y2VzIGEgd29yZCB0aGF0IGJlZ2lucyB3aXRoIFt0XS4gKilcblxuICB2YWwgZmlyc3Q6IF8gbm9udGVybWluYWwgLT4gXyB0ZXJtaW5hbCAtPiBib29sXG5cbiAgKCogW3hmaXJzdF0gaXMgYW5hbG9nb3VzIHRvIFtmaXJzdF0sIGJ1dCBleHBlY3RzIGEgZmlyc3QgYXJndW1lbnQgb2YgdHlwZVxuICAgICBbeHN5bWJvbF0gaW5zdGVhZCBvZiBbXyB0ZXJtaW5hbF0uICopXG5cbiAgdmFsIHhmaXJzdDogeHN5bWJvbCAtPiBfIHRlcm1pbmFsIC0+IGJvb2xcblxuICAoKiBbZm9yZWFjaF90ZXJtaW5hbF0gZW51bWVyYXRlcyB0aGUgdGVybWluYWwgc3ltYm9scywgaW5jbHVkaW5nIFtlcnJvcl0uXG4gICAgIFtmb3JlYWNoX3Rlcm1pbmFsX2J1dF9lcnJvcl0gZW51bWVyYXRlcyB0aGUgdGVybWluYWwgc3ltYm9scywgZXhjbHVkaW5nXG4gICAgIFtlcnJvcl0uICopXG5cbiAgdmFsIGZvcmVhY2hfdGVybWluYWw6ICAgICAgICAgICAoeHN5bWJvbCAtPiAnYSAtPiAnYSkgLT4gJ2EgLT4gJ2FcbiAgdmFsIGZvcmVhY2hfdGVybWluYWxfYnV0X2Vycm9yOiAoeHN5bWJvbCAtPiAnYSAtPiAnYSkgLT4gJ2EgLT4gJ2FcblxuICAoKiBUaGUgdHlwZSBbZW52XSBpcyBtZWFudCB0byBiZSB0aGUgc2FtZSBhcyBpbiBbSU5DUkVNRU5UQUxfRU5HSU5FXS4gKilcblxuICB0eXBlICdhIGVudlxuXG4gICgqIFtmZWVkIHN5bWJvbCBzdGFydHAgc2VtdiBlbmRwIGVudl0gY2F1c2VzIHRoZSBwYXJzZXIgdG8gY29uc3VtZSB0aGVcbiAgICAgKHRlcm1pbmFsIG9yIG5vbnRlcm1pbmFsKSBzeW1ib2wgW3N5bWJvbF0sIGFjY29tcGFuaWVkIHdpdGggdGhlIHNlbWFudGljXG4gICAgIHZhbHVlIFtzZW12XSBhbmQgd2l0aCB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgW3N0YXJ0cF0gYW5kIFtlbmRwXS5cbiAgICAgVGh1cywgdGhlIGF1dG9tYXRvbiBtYWtlcyBhIHRyYW5zaXRpb24sIGFuZCByZWFjaGVzIGEgbmV3IHN0YXRlLiBUaGVcbiAgICAgc3RhY2sgZ3Jvd3MgYnkgb25lIGNlbGwuIFRoaXMgb3BlcmF0aW9uIGlzIHBlcm1pdHRlZCBvbmx5IGlmIHRoZSBjdXJyZW50XG4gICAgIHN0YXRlIChhcyBkZXRlcm1pbmVkIGJ5IFtlbnZdKSBoYXMgYW4gb3V0Z29pbmcgdHJhbnNpdGlvbiBsYWJlbGVkIHdpdGhcbiAgICAgW3N5bWJvbF0uIE90aGVyd2lzZSwgW0ludmFsaWRfYXJndW1lbnQgX10gaXMgcmFpc2VkLiAqKVxuXG4gIHZhbCBmZWVkOiAnYSBzeW1ib2wgLT4gcG9zaXRpb24gLT4gJ2EgLT4gcG9zaXRpb24gLT4gJ2IgZW52IC0+ICdiIGVudlxuXG5lbmRcblxuKCogVGhpcyBzaWduYXR1cmUgY29tYmluZXMgdGhlIGluY3JlbWVudGFsIEFQSSBhbmQgdGhlIGluc3BlY3Rpb24gQVBJLiAqKVxuXG5tb2R1bGUgdHlwZSBFVkVSWVRISU5HID0gc2lnXG5cbiAgaW5jbHVkZSBJTkNSRU1FTlRBTF9FTkdJTkVcblxuICBpbmNsdWRlIElOU1BFQ1RJT05cbiAgICB3aXRoIHR5cGUgJ2EgbHIxc3RhdGUgOj0gJ2EgbHIxc3RhdGVcbiAgICB3aXRoIHR5cGUgcHJvZHVjdGlvbiA6PSBwcm9kdWN0aW9uXG4gICAgd2l0aCB0eXBlICdhIGVudiA6PSAnYSBlbnZcblxuZW5kXG5lbmRcbm1vZHVsZSBFbmdpbmVUeXBlcyA9IHN0cnVjdFxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IElucmlhLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgICAgICopXG4oKiAgIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIsIHdpdGggYSAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nLCBhcyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBUaGlzIGZpbGUgZGVmaW5lcyBzZXZlcmFsIHR5cGVzIGFuZCBtb2R1bGUgdHlwZXMgdGhhdCBhcmUgdXNlZCBpbiB0aGVcbiAgIHNwZWNpZmljYXRpb24gb2YgbW9kdWxlIFtFbmdpbmVdLiAqKVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuKCogSXQgd291bGQgYmUgbmljZSBpZiB3ZSBjb3VsZCBrZWVwIHRoZSBzdHJ1Y3R1cmUgb2Ygc3RhY2tzIGFuZCBlbnZpcm9ubWVudHNcbiAgIGhpZGRlbi4gSG93ZXZlciwgc3RhY2tzIGFuZCBlbnZpcm9ubWVudHMgbXVzdCBiZSBhY2Nlc3NpYmxlIHRvIHNlbWFudGljXG4gICBhY3Rpb25zLCBzbyB0aGUgZm9sbG93aW5nIGRhdGEgc3RydWN0dXJlIGRlZmluaXRpb25zIG11c3QgYmUgcHVibGljLiAqKVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuKCogQSBzdGFjayBpcyBhIGxpbmtlZCBsaXN0IG9mIGNlbGxzLiBBIHNlbnRpbmVsIGNlbGwgLS0gd2hpY2ggaXMgaXRzIG93blxuICAgc3VjY2Vzc29yIC0tIGlzIHVzZWQgdG8gbWFyayB0aGUgYm90dG9tIG9mIHRoZSBzdGFjay4gVGhlIHNlbnRpbmVsIGNlbGxcbiAgIGl0c2VsZiBpcyBub3Qgc2lnbmlmaWNhbnQgLS0gaXQgY29udGFpbnMgZHVtbXkgdmFsdWVzLiAqKVxuXG50eXBlICgnc3RhdGUsICdzZW1hbnRpY192YWx1ZSkgc3RhY2sgPSB7XG5cbiAgKCogVGhlIHN0YXRlIHRoYXQgd2Ugc2hvdWxkIGdvIGJhY2sgdG8gaWYgd2UgcG9wIHRoaXMgc3RhY2sgY2VsbC4gKilcblxuICAoKiBUaGlzIGNvbnZlbnRpb24gbWVhbnMgdGhhdCB0aGUgc3RhdGUgY29udGFpbmVkIGluIHRoZSB0b3Agc3RhY2sgY2VsbCBpc1xuICAgICBub3QgdGhlIGN1cnJlbnQgc3RhdGUgW2Vudi5jdXJyZW50XS4gSXQgYWxzbyBtZWFucyB0aGF0IHRoZSBzdGF0ZSBmb3VuZFxuICAgICB3aXRoaW4gdGhlIHNlbnRpbmVsIGlzIGEgZHVtbXkgLS0gaXQgaXMgbmV2ZXIgY29uc3VsdGVkLiBUaGlzIGNvbnZlbnRpb25cbiAgICAgaXMgdGhlIHNhbWUgYXMgdGhhdCBhZG9wdGVkIGJ5IHRoZSBjb2RlLWJhc2VkIGJhY2stZW5kLiAqKVxuXG4gIHN0YXRlOiAnc3RhdGU7XG5cbiAgKCogVGhlIHNlbWFudGljIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2h1bmsgb2YgaW5wdXQgdGhhdCB0aGlzIGNlbGxcbiAgICAgcmVwcmVzZW50cy4gKilcblxuICBzZW12OiAnc2VtYW50aWNfdmFsdWU7XG5cbiAgKCogVGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zIG9mIHRoZSBjaHVuayBvZiBpbnB1dCB0aGF0IHRoaXMgY2VsbFxuICAgICByZXByZXNlbnRzLiAqKVxuXG4gIHN0YXJ0cDogTGV4aW5nLnBvc2l0aW9uO1xuICBlbmRwOiBMZXhpbmcucG9zaXRpb247XG5cbiAgKCogVGhlIG5leHQgY2VsbCBkb3duIGluIHRoZSBzdGFjay4gSWYgdGhpcyBpcyBhIHNlbGYtcG9pbnRlciwgdGhlbiB0aGlzXG4gICAgIGNlbGwgaXMgdGhlIHNlbnRpbmVsLCBhbmQgdGhlIHN0YWNrIGlzIGNvbmNlcHR1YWxseSBlbXB0eS4gKilcblxuICBuZXh0OiAoJ3N0YXRlLCAnc2VtYW50aWNfdmFsdWUpIHN0YWNrO1xuXG59XG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4oKiBBIHBhcnNpbmcgZW52aXJvbm1lbnQgY29udGFpbnMgYWxsIG9mIHRoZSBwYXJzZXIncyBzdGF0ZSAoZXhjZXB0IGZvciB0aGVcbiAgIGN1cnJlbnQgcHJvZ3JhbSBwb2ludCkuICopXG5cbnR5cGUgKCdzdGF0ZSwgJ3NlbWFudGljX3ZhbHVlLCAndG9rZW4pIGVudiA9IHtcblxuICAoKiBJZiB0aGlzIGZsYWcgaXMgdHJ1ZSwgdGhlbiB0aGUgZmlyc3QgY29tcG9uZW50IG9mIFtlbnYudHJpcGxlXSBzaG91bGRcbiAgICAgYmUgaWdub3JlZCwgYXMgaXQgaGFzIGJlZW4gbG9naWNhbGx5IG92ZXJ3cml0dGVuIHdpdGggdGhlIFtlcnJvcl1cbiAgICAgcHNldWRvLXRva2VuLiAqKVxuXG4gIGVycm9yOiBib29sO1xuXG4gICgqIFRoZSBsYXN0IHRva2VuIHRoYXQgd2FzIG9idGFpbmVkIGZyb20gdGhlIGxleGVyLCB0b2dldGhlciB3aXRoIGl0cyBzdGFydFxuICAgICBhbmQgZW5kIHBvc2l0aW9ucy4gV2FybmluZzogYmVmb3JlIHRoZSBmaXJzdCBjYWxsIHRvIHRoZSBsZXhlciBoYXMgdGFrZW5cbiAgICAgcGxhY2UsIGEgZHVtbXkgKGFuZCBwb3NzaWJseSBpbnZhbGlkKSB0b2tlbiBpcyBzdG9yZWQgaGVyZS4gKilcblxuICB0cmlwbGU6ICd0b2tlbiAqIExleGluZy5wb3NpdGlvbiAqIExleGluZy5wb3NpdGlvbjtcblxuICAoKiBUaGUgc3RhY2suIEluIFtDb2RlQmFja2VuZF0sIGl0IGlzIHBhc3NlZCBhcm91bmQgb24gaXRzIG93bixcbiAgICAgd2hlcmVhcywgaGVyZSwgaXQgaXMgYWNjZXNzZWQgdmlhIHRoZSBlbnZpcm9ubWVudC4gKilcblxuICBzdGFjazogKCdzdGF0ZSwgJ3NlbWFudGljX3ZhbHVlKSBzdGFjaztcblxuICAoKiBUaGUgY3VycmVudCBzdGF0ZS4gSW4gW0NvZGVCYWNrZW5kXSwgaXQgaXMgcGFzc2VkIGFyb3VuZCBvbiBpdHNcbiAgICAgb3duLCB3aGVyZWFzLCBoZXJlLCBpdCBpcyBhY2Nlc3NlZCB2aWEgdGhlIGVudmlyb25tZW50LiAqKVxuXG4gIGN1cnJlbnQ6ICdzdGF0ZTtcblxufVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuKCogQSBudW1iZXIgb2YgbG9nZ2luZyBob29rcyBhcmUgdXNlZCB0byAob3B0aW9uYWxseSkgZW1pdCBsb2dnaW5nIG1lc3NhZ2VzLiAqKVxuXG4oKiBUaGUgY29tbWVudHMgaW5kaWNhdGUgdGhlIGNvbnZlbnRpb25hbCBtZXNzYWdlcyB0aGF0IGNvcnJlc3BvbmRcbiAgIHRvIHRoZXNlIGhvb2tzIGluIHRoZSBjb2RlLWJhc2VkIGJhY2stZW5kOyBzZWUgW0NvZGVCYWNrZW5kXS4gKilcblxubW9kdWxlIHR5cGUgTE9HID0gc2lnXG5cbiAgdHlwZSBzdGF0ZVxuICB0eXBlIHRlcm1pbmFsXG4gIHR5cGUgcHJvZHVjdGlvblxuXG4gICgqIFN0YXRlICVkOiAqKVxuXG4gIHZhbCBzdGF0ZTogc3RhdGUgLT4gdW5pdFxuXG4gICgqIFNoaWZ0aW5nICg8dGVybWluYWw+KSB0byBzdGF0ZSA8c3RhdGU+ICopXG5cbiAgdmFsIHNoaWZ0OiB0ZXJtaW5hbCAtPiBzdGF0ZSAtPiB1bml0XG5cbiAgKCogUmVkdWNpbmcgYSBwcm9kdWN0aW9uIHNob3VsZCBiZSBsb2dnZWQgZWl0aGVyIGFzIGEgcmVkdWN0aW9uXG4gICAgIGV2ZW50IChmb3IgcmVndWxhciBwcm9kdWN0aW9ucykgb3IgYXMgYW4gYWNjZXB0YW5jZSBldmVudCAoZm9yXG4gICAgIHN0YXJ0IHByb2R1Y3Rpb25zKS4gKilcblxuICAoKiBSZWR1Y2luZyBwcm9kdWN0aW9uIDxwcm9kdWN0aW9uPiAvIEFjY2VwdGluZyAqKVxuXG4gIHZhbCByZWR1Y2Vfb3JfYWNjZXB0OiBwcm9kdWN0aW9uIC0+IHVuaXRcblxuICAoKiBMb29rYWhlYWQgdG9rZW4gaXMgbm93IDx0ZXJtaW5hbD4gKDxwb3M+LTxwb3M+KSAqKVxuXG4gIHZhbCBsb29rYWhlYWRfdG9rZW46IHRlcm1pbmFsIC0+IExleGluZy5wb3NpdGlvbiAtPiBMZXhpbmcucG9zaXRpb24gLT4gdW5pdFxuXG4gICgqIEluaXRpYXRpbmcgZXJyb3IgaGFuZGxpbmcgKilcblxuICB2YWwgaW5pdGlhdGluZ19lcnJvcl9oYW5kbGluZzogdW5pdCAtPiB1bml0XG5cbiAgKCogUmVzdW1pbmcgZXJyb3IgaGFuZGxpbmcgKilcblxuICB2YWwgcmVzdW1pbmdfZXJyb3JfaGFuZGxpbmc6IHVuaXQgLT4gdW5pdFxuXG4gICgqIEhhbmRsaW5nIGVycm9yIGluIHN0YXRlIDxzdGF0ZT4gKilcblxuICB2YWwgaGFuZGxpbmdfZXJyb3I6IHN0YXRlIC0+IHVuaXRcblxuZW5kXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4oKiBUaGlzIHNpZ25hdHVyZSBkZXNjcmliZXMgdGhlIHBhcmFtZXRlcnMgdGhhdCBtdXN0IGJlIHN1cHBsaWVkIHRvIHRoZSBMUlxuICAgZW5naW5lLiAqKVxuXG5tb2R1bGUgdHlwZSBUQUJMRSA9IHNpZ1xuXG4gICgqIFRoZSB0eXBlIG9mIGF1dG9tYXRvbiBzdGF0ZXMuICopXG5cbiAgdHlwZSBzdGF0ZVxuXG4gICgqIFN0YXRlcyBhcmUgbnVtYmVyZWQuICopXG5cbiAgdmFsIG51bWJlcjogc3RhdGUgLT4gaW50XG5cbiAgKCogVGhlIHR5cGUgb2YgdG9rZW5zLiBUaGVzZSBjYW4gYmUgdGhvdWdodCBvZiBhcyByZWFsIHRva2VucywgdGhhdCBpcyxcbiAgICAgdG9rZW5zIHJldHVybmVkIGJ5IHRoZSBsZXhlci4gVGhleSBjYXJyeSBhIHNlbWFudGljIHZhbHVlLiBUaGlzIHR5cGVcbiAgICAgZG9lcyBub3QgaW5jbHVkZSB0aGUgW2Vycm9yXSBwc2V1ZG8tdG9rZW4uICopXG5cbiAgdHlwZSB0b2tlblxuXG4gICgqIFRoZSB0eXBlIG9mIHRlcm1pbmFsIHN5bWJvbHMuIFRoZXNlIGNhbiBiZSB0aG91Z2h0IG9mIGFzIGludGVnZXIgY29kZXMuXG4gICAgIFRoZXkgZG8gbm90IGNhcnJ5IGEgc2VtYW50aWMgdmFsdWUuIFRoaXMgdHlwZSBkb2VzIGluY2x1ZGUgdGhlIFtlcnJvcl1cbiAgICAgcHNldWRvLXRva2VuLiAqKVxuXG4gIHR5cGUgdGVybWluYWxcblxuICAoKiBUaGUgdHlwZSBvZiBub250ZXJtaW5hbCBzeW1ib2xzLiAqKVxuXG4gIHR5cGUgbm9udGVybWluYWxcblxuICAoKiBUaGUgdHlwZSBvZiBzZW1hbnRpYyB2YWx1ZXMuICopXG5cbiAgdHlwZSBzZW1hbnRpY192YWx1ZVxuXG4gICgqIEEgdG9rZW4gaXMgY29uY2VwdHVhbGx5IGEgcGFpciBvZiBhIChub24tW2Vycm9yXSkgdGVybWluYWwgc3ltYm9sIGFuZFxuICAgICBhIHNlbWFudGljIHZhbHVlLiBUaGUgZm9sbG93aW5nIHR3byBmdW5jdGlvbnMgYXJlIHRoZSBwYWlyIHByb2plY3Rpb25zLiAqKVxuXG4gIHZhbCB0b2tlbjJ0ZXJtaW5hbDogdG9rZW4gLT4gdGVybWluYWxcbiAgdmFsIHRva2VuMnZhbHVlOiB0b2tlbiAtPiBzZW1hbnRpY192YWx1ZVxuXG4gICgqIEV2ZW4gdGhvdWdoIHRoZSBbZXJyb3JdIHBzZXVkby10b2tlbiBpcyBub3QgYSByZWFsIHRva2VuLCBpdCBpcyBhXG4gICAgIHRlcm1pbmFsIHN5bWJvbC4gRnVydGhlcm1vcmUsIGZvciByZWd1bGFyaXR5LCBpdCBtdXN0IGhhdmUgYSBzZW1hbnRpY1xuICAgICB2YWx1ZS4gKilcblxuICB2YWwgZXJyb3JfdGVybWluYWw6IHRlcm1pbmFsXG4gIHZhbCBlcnJvcl92YWx1ZTogc2VtYW50aWNfdmFsdWVcblxuICAoKiBbZm9yZWFjaF90ZXJtaW5hbF0gYWxsb3dzIGl0ZXJhdGluZyBvdmVyIGFsbCB0ZXJtaW5hbCBzeW1ib2xzLiAqKVxuXG4gIHZhbCBmb3JlYWNoX3Rlcm1pbmFsOiAodGVybWluYWwgLT4gJ2EgLT4gJ2EpIC0+ICdhIC0+ICdhXG5cbiAgKCogVGhlIHR5cGUgb2YgcHJvZHVjdGlvbnMuICopXG5cbiAgdHlwZSBwcm9kdWN0aW9uXG5cbiAgdmFsIHByb2R1Y3Rpb25faW5kZXg6IHByb2R1Y3Rpb24gLT4gaW50XG4gIHZhbCBmaW5kX3Byb2R1Y3Rpb246IGludCAtPiBwcm9kdWN0aW9uXG5cbiAgKCogSWYgYSBzdGF0ZSBbc10gaGFzIGEgZGVmYXVsdCByZWR1Y3Rpb24gb24gcHJvZHVjdGlvbiBbcHJvZF0sIHRoZW4sIHVwb25cbiAgICAgZW50ZXJpbmcgW3NdLCB0aGUgYXV0b21hdG9uIHNob3VsZCByZWR1Y2UgW3Byb2RdIHdpdGhvdXQgY29uc3VsdGluZyB0aGVcbiAgICAgbG9va2FoZWFkIHRva2VuLiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9uIGFsbG93cyBkZXRlcm1pbmluZyB3aGljaCBzdGF0ZXNcbiAgICAgaGF2ZSBkZWZhdWx0IHJlZHVjdGlvbnMuICopXG5cbiAgKCogSW5zdGVhZCBvZiByZXR1cm5pbmcgYSB2YWx1ZSBvZiBhIHN1bSB0eXBlIC0tIGVpdGhlciBbRGVmUmVkIHByb2RdLCBvclxuICAgICBbTm9EZWZSZWRdIC0tIGl0IGFjY2VwdHMgdHdvIGNvbnRpbnVhdGlvbnMsIGFuZCBpbnZva2VzIGp1c3Qgb25lIG9mXG4gICAgIHRoZW0uIFRoaXMgbWVjaGFuaXNtIGFsbG93cyBhdm9pZGluZyBhIG1lbW9yeSBhbGxvY2F0aW9uLiAqKVxuXG4gIHZhbCBkZWZhdWx0X3JlZHVjdGlvbjpcbiAgICBzdGF0ZSAtPlxuICAgICgnZW52IC0+IHByb2R1Y3Rpb24gLT4gJ2Fuc3dlcikgLT5cbiAgICAoJ2VudiAtPiAnYW5zd2VyKSAtPlxuICAgICdlbnYgLT4gJ2Fuc3dlclxuXG4gICgqIEFuIExSIGF1dG9tYXRvbiBjYW4gbm9ybWFsbHkgdGFrZSB0aHJlZSBraW5kcyBvZiBhY3Rpb25zOiBzaGlmdCwgcmVkdWNlLFxuICAgICBvciBmYWlsLiAoQWNjZXB0YW5jZSBpcyBhIHBhcnRpY3VsYXIgY2FzZSBvZiByZWR1Y3Rpb246IGl0IGNvbnNpc3RzIGluXG4gICAgIHJlZHVjaW5nIGEgc3RhcnQgcHJvZHVjdGlvbi4pICopXG5cbiAgKCogVGhlcmUgYXJlIHR3byB2YXJpYW50cyBvZiB0aGUgc2hpZnQgYWN0aW9uLiBbc2hpZnQvZGlzY2FyZCBzXSBpbnN0cnVjdHNcbiAgICAgdGhlIGF1dG9tYXRvbiB0byBkaXNjYXJkIHRoZSBjdXJyZW50IHRva2VuLCByZXF1ZXN0IGEgbmV3IG9uZSBmcm9tIHRoZVxuICAgICBsZXhlciwgYW5kIG1vdmUgdG8gc3RhdGUgW3NdLiBbc2hpZnQvbm9kaXNjYXJkIHNdIGluc3RydWN0cyBpdCB0byBtb3ZlIHRvXG4gICAgIHN0YXRlIFtzXSB3aXRob3V0IHJlcXVlc3RpbmcgYSBuZXcgdG9rZW4uIFRoaXMgaW5zdHJ1Y3Rpb24gc2hvdWxkIGJlIHVzZWRcbiAgICAgd2hlbiBbc10gaGFzIGEgZGVmYXVsdCByZWR1Y3Rpb24gb24gWyNdLiBTZWUgW0NvZGVCYWNrZW5kLmdldHRva2VuXSBmb3JcbiAgICAgZGV0YWlscy4gKilcblxuICAoKiBUaGlzIGlzIHRoZSBhdXRvbWF0b24ncyBhY3Rpb24gdGFibGUuIEl0IG1hcHMgYSBwYWlyIG9mIGEgc3RhdGUgYW5kIGFcbiAgICAgdGVybWluYWwgc3ltYm9sIHRvIGFuIGFjdGlvbi4gKilcblxuICAoKiBJbnN0ZWFkIG9mIHJldHVybmluZyBhIHZhbHVlIG9mIGEgc3VtIHR5cGUgLS0gb25lIG9mIHNoaWZ0L2Rpc2NhcmQsXG4gICAgIHNoaWZ0L25vZGlzY2FyZCwgcmVkdWNlLCBvciBmYWlsIC0tIHRoaXMgZnVuY3Rpb24gYWNjZXB0cyB0aHJlZVxuICAgICBjb250aW51YXRpb25zLCBhbmQgaW52b2tlcyBqdXN0IG9uZSB0aGVtLiBUaGlzIG1lY2hhbmlzbSBhbGxvd3MgYXZvaWRpbmdcbiAgICAgYSBtZW1vcnkgYWxsb2NhdGlvbi4gKilcblxuICAoKiBJbiBzdW1tYXJ5LCB0aGUgcGFyYW1ldGVycyB0byBbYWN0aW9uXSBhcmUgYXMgZm9sbG93czpcblxuICAgICAtIHRoZSBmaXJzdCB0d28gcGFyYW1ldGVycywgYSBzdGF0ZSBhbmQgYSB0ZXJtaW5hbCBzeW1ib2wsIGFyZSB1c2VkIHRvXG4gICAgICAgbG9vayB1cCB0aGUgYWN0aW9uIHRhYmxlO1xuXG4gICAgIC0gdGhlIG5leHQgcGFyYW1ldGVyIGlzIHRoZSBzZW1hbnRpYyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFib3ZlXG4gICAgICAgdGVybWluYWwgc3ltYm9sOyBpdCBpcyBub3QgdXNlZCwgb25seSBwYXNzZWQgYWxvbmcgdG8gdGhlIHNoaWZ0XG4gICAgICAgY29udGludWF0aW9uLCBhcyBleHBsYWluZWQgYmVsb3c7XG5cbiAgICAgLSB0aGUgc2hpZnQgY29udGludWF0aW9uIGV4cGVjdHMgYW4gZW52aXJvbm1lbnQ7IGEgZmxhZyB0aGF0IHRlbGxzXG4gICAgICAgd2hldGhlciB0byBkaXNjYXJkIHRoZSBjdXJyZW50IHRva2VuOyB0aGUgdGVybWluYWwgc3ltYm9sIHRoYXRcbiAgICAgICBpcyBiZWluZyBzaGlmdGVkOyBpdHMgc2VtYW50aWMgdmFsdWU7IGFuZCB0aGUgdGFyZ2V0IHN0YXRlIG9mXG4gICAgICAgdGhlIHRyYW5zaXRpb247XG5cbiAgICAgLSB0aGUgcmVkdWNlIGNvbnRpbnVhdGlvbiBleHBlY3RzIGFuIGVudmlyb25tZW50IGFuZCBhIHByb2R1Y3Rpb247XG5cbiAgICAgLSB0aGUgZmFpbCBjb250aW51YXRpb24gZXhwZWN0cyBhbiBlbnZpcm9ubWVudDtcblxuICAgICAtIHRoZSBsYXN0IHBhcmFtZXRlciBpcyB0aGUgZW52aXJvbm1lbnQ7IGl0IGlzIG5vdCB1c2VkLCBvbmx5IHBhc3NlZFxuICAgICAgIGFsb25nIHRvIHRoZSBzZWxlY3RlZCBjb250aW51YXRpb24uICopXG5cbiAgdmFsIGFjdGlvbjpcbiAgICBzdGF0ZSAtPlxuICAgIHRlcm1pbmFsIC0+XG4gICAgc2VtYW50aWNfdmFsdWUgLT5cbiAgICAoJ2VudiAtPiBib29sIC0+IHRlcm1pbmFsIC0+IHNlbWFudGljX3ZhbHVlIC0+IHN0YXRlIC0+ICdhbnN3ZXIpIC0+XG4gICAgKCdlbnYgLT4gcHJvZHVjdGlvbiAtPiAnYW5zd2VyKSAtPlxuICAgICgnZW52IC0+ICdhbnN3ZXIpIC0+XG4gICAgJ2VudiAtPiAnYW5zd2VyXG5cbiAgKCoqW21heWJlX3NoaWZ0X3QgcyB0XSBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlcmUgZXhpc3RzIGEgdHJhbnNpdGlvbiBvdXQgb2ZcbiAgICAgdGhlIHN0YXRlIFtzXSwgbGFiZWxlZCB3aXRoIHRoZSB0ZXJtaW5hbCBzeW1ib2wgW3RdLCB0byBzb21lIHN0YXRlXG4gICAgIFtzJ10uIElmIHNvLCBpdCByZXR1cm5zIFtTb21lIHMnXS4gT3RoZXJ3aXNlLCBpdCByZXR1cm5zIFtOb25lXS4gKilcbiAgdmFsIG1heWJlX3NoaWZ0X3QgOiBzdGF0ZSAtPiB0ZXJtaW5hbCAtPiBzdGF0ZSBvcHRpb25cblxuICAoKipbbWF5X3JlZHVjZV9wcm9kIHMgdCBwcm9kXSBkZXRlcm1pbmVzIHdoZXRoZXIgaW4gdGhlIHN0YXRlIFtzXSwgd2l0aFxuICAgICBsb29rYWhlYWQgc3ltYm9sIFt0XSwgdGhlIGF1dG9tYXRvbiByZWR1Y2VzIHByb2R1Y3Rpb24gW3Byb2RdLiBUaGlzIHRlc3RcbiAgICAgYWNjb3VudHMgZm9yIHRoZSBwb3NzaWJsZSBleGlzdGVuY2Ugb2YgYSBkZWZhdWx0IHJlZHVjdGlvbi4gKilcbiAgdmFsIG1heV9yZWR1Y2VfcHJvZCA6IHN0YXRlIC0+IHRlcm1pbmFsIC0+IHByb2R1Y3Rpb24gLT4gYm9vbFxuXG4gICgqIFRoaXMgaXMgdGhlIGF1dG9tYXRvbidzIGdvdG8gdGFibGUuIFRoaXMgdGFibGUgbWFwcyBhIHBhaXIgb2YgYSBzdGF0ZVxuICAgICBhbmQgYSBub250ZXJtaW5hbCBzeW1ib2wgdG8gYSBuZXcgc3RhdGUuIEJ5IGV4dGVuc2lvbiwgaXQgYWxzbyBtYXBzIGFcbiAgICAgcGFpciBvZiBhIHN0YXRlIGFuZCBhIHByb2R1Y3Rpb24gdG8gYSBuZXcgc3RhdGUuICopXG5cbiAgKCogVGhlIGZ1bmN0aW9uIFtnb3RvX250XSBjYW4gYmUgYXBwbGllZCB0byBbc10gYW5kIFtudF0gT05MWSBpZiB0aGUgc3RhdGVcbiAgICAgW3NdIGhhcyBhbiBvdXRnb2luZyB0cmFuc2l0aW9uIGxhYmVsZWQgW250XS4gT3RoZXJ3aXNlLCBpdHMgcmVzdWx0IGlzXG4gICAgIHVuZGVmaW5lZC4gU2ltaWxhcmx5LCB0aGUgY2FsbCBbZ290b19wcm9kIHByb2Qgc10gaXMgcGVybWl0dGVkIE9OTFkgaWZcbiAgICAgdGhlIHN0YXRlIFtzXSBoYXMgYW4gb3V0Z29pbmcgdHJhbnNpdGlvbiBsYWJlbGVkIHdpdGggdGhlIG5vbnRlcm1pbmFsXG4gICAgIHN5bWJvbCBbbGhzIHByb2RdLiBUaGUgZnVuY3Rpb24gW21heWJlX2dvdG9fbnRdIGludm9sdmVzIGFuIGFkZGl0aW9uYWxcbiAgICAgZHluYW1pYyBjaGVjayBhbmQgQ0FOIGJlIGNhbGxlZCBldmVuIGlmIHRoZXJlIGlzIG5vIG91dGdvaW5nIHRyYW5zaXRpb24uICopXG5cbiAgdmFsICAgICAgIGdvdG9fbnQgIDogc3RhdGUgLT4gbm9udGVybWluYWwgLT4gc3RhdGVcbiAgdmFsICAgICAgIGdvdG9fcHJvZDogc3RhdGUgLT4gcHJvZHVjdGlvbiAgLT4gc3RhdGVcbiAgdmFsIG1heWJlX2dvdG9fbnQ6ICAgc3RhdGUgLT4gbm9udGVybWluYWwgLT4gc3RhdGUgb3B0aW9uXG5cbiAgKCogW2xocyBwcm9kXSByZXR1cm5zIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiBwcm9kdWN0aW9uIFtwcm9kXSxcbiAgICAgYSBub250ZXJtaW5hbCBzeW1ib2wuICopXG5cbiAgdmFsIGxoczogcHJvZHVjdGlvbiAtPiBub250ZXJtaW5hbFxuXG4gICgqIFtpc19zdGFydCBwcm9kXSB0ZWxscyB3aGV0aGVyIHRoZSBwcm9kdWN0aW9uIFtwcm9kXSBpcyBhIHN0YXJ0IHByb2R1Y3Rpb24uICopXG5cbiAgdmFsIGlzX3N0YXJ0OiBwcm9kdWN0aW9uIC0+IGJvb2xcblxuICAoKiBCeSBjb252ZW50aW9uLCBhIHNlbWFudGljIGFjdGlvbiBpcyByZXNwb25zaWJsZSBmb3I6XG5cbiAgICAgMS4gZmV0Y2hpbmcgd2hhdGV2ZXIgc2VtYW50aWMgdmFsdWVzIGFuZCBwb3NpdGlvbnMgaXQgbmVlZHMgb2ZmIHRoZSBzdGFjaztcblxuICAgICAyLiBwb3BwaW5nIGFuIGFwcHJvcHJpYXRlIG51bWJlciBvZiBjZWxscyBvZmYgdGhlIHN0YWNrLCBhcyBkaWN0YXRlZFxuICAgICAgICBieSB0aGUgbGVuZ3RoIG9mIHRoZSByaWdodC1oYW5kIHNpZGUgb2YgdGhlIHByb2R1Y3Rpb247XG5cbiAgICAgMy4gY29tcHV0aW5nIGEgbmV3IHNlbWFudGljIHZhbHVlLCBhcyB3ZWxsIGFzIG5ldyBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucztcblxuICAgICA0LiBwdXNoaW5nIGEgbmV3IHN0YWNrIGNlbGwsIHdoaWNoIGNvbnRhaW5zIHRoZSB0aHJlZSB2YWx1ZXNcbiAgICAgICAgY29tcHV0ZWQgaW4gc3RlcCAzO1xuXG4gICAgIDUuIHJldHVybmluZyB0aGUgbmV3IHN0YWNrIGNvbXB1dGVkIGluIHN0ZXBzIDIgYW5kIDQuXG5cbiAgICAgUG9pbnQgMSBpcyBlc3NlbnRpYWxseSBmb3JjZWQgdXBvbiB1czogaWYgc2VtYW50aWMgdmFsdWVzIHdlcmUgZmV0Y2hlZFxuICAgICBvZmYgdGhlIHN0YWNrIGJ5IHRoaXMgaW50ZXJwcmV0ZXIsIHRoZW4gdGhlIGNhbGxpbmcgY29udmVudGlvbiBmb3JcbiAgICAgc2VtYW50aWMgYWN0aW9ucyB3b3VsZCBiZSB2YXJpYWRpYzogbm90IGFsbCBzZW1hbnRpYyBhY3Rpb25zIHdvdWxkIGhhdmVcbiAgICAgdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cy4gVGhlIHJlc3QgZm9sbG93cyByYXRoZXIgbmF0dXJhbGx5LiAqKVxuXG4gICgqIFNlbWFudGljIGFjdGlvbnMgYXJlIGFsbG93ZWQgdG8gcmFpc2UgW0Vycm9yXS4gKilcblxuICBleGNlcHRpb24gRXJyb3JcblxuICB0eXBlIHNlbWFudGljX2FjdGlvbiA9XG4gICAgICAoc3RhdGUsIHNlbWFudGljX3ZhbHVlLCB0b2tlbikgZW52IC0+IChzdGF0ZSwgc2VtYW50aWNfdmFsdWUpIHN0YWNrXG5cbiAgdmFsIHNlbWFudGljX2FjdGlvbjogcHJvZHVjdGlvbiAtPiBzZW1hbnRpY19hY3Rpb25cblxuICAoKiBbbWF5X3JlZHVjZSBzdGF0ZSBwcm9kXSB0ZXN0cyB3aGV0aGVyIHRoZSBzdGF0ZSBbc3RhdGVdIGlzIGNhcGFibGUgb2ZcbiAgICAgcmVkdWNpbmcgdGhlIHByb2R1Y3Rpb24gW3Byb2RdLiBUaGlzIGZ1bmN0aW9uIGlzIGN1cnJlbnRseSBjb3N0bHkgYW5kXG4gICAgIGlzIG5vdCB1c2VkIGJ5IHRoZSBjb3JlIExSIGVuZ2luZS4gSXQgaXMgdXNlZCBpbiB0aGUgaW1wbGVtZW50YXRpb25cbiAgICAgb2YgY2VydGFpbiBmdW5jdGlvbnMsIHN1Y2ggYXMgW2ZvcmNlX3JlZHVjdGlvbl0sIHdoaWNoIGFsbG93IHRoZSBlbmdpbmVcbiAgICAgdG8gYmUgZHJpdmVuIHByb2dyYW1tYXRpY2FsbHkuICopXG5cbiAgdmFsIG1heV9yZWR1Y2U6IHN0YXRlIC0+IHByb2R1Y3Rpb24gLT4gYm9vbFxuXG4gICgqIElmIHRoZSBmbGFnIFtsb2ddIGlzIGZhbHNlLCB0aGVuIHRoZSBsb2dnaW5nIGZ1bmN0aW9ucyBhcmUgbm90IGNhbGxlZC5cbiAgICAgSWYgaXQgaXMgW3RydWVdLCB0aGVuIHRoZXkgYXJlIGNhbGxlZC4gKilcblxuICB2YWwgbG9nIDogYm9vbFxuXG4gICgqIFRoZSBsb2dnaW5nIGhvb2tzIHJlcXVpcmVkIGJ5IHRoZSBMUiBlbmdpbmUuICopXG5cbiAgbW9kdWxlIExvZyA6IExPR1xuICAgIHdpdGggdHlwZSBzdGF0ZSA6PSBzdGF0ZVxuICAgICBhbmQgdHlwZSB0ZXJtaW5hbCA6PSB0ZXJtaW5hbFxuICAgICBhbmQgdHlwZSBwcm9kdWN0aW9uIDo9IHByb2R1Y3Rpb25cblxuZW5kXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4oKiBUaGlzIHNpZ25hdHVyZSBkZXNjcmliZXMgdGhlIG1vbm9saXRoaWMgKHRyYWRpdGlvbmFsKSBMUiBlbmdpbmUuICopXG5cbigqIEluIHRoaXMgaW50ZXJmYWNlLCB0aGUgcGFyc2VyIGNvbnRyb2xzIHRoZSBsZXhlci4gKilcblxubW9kdWxlIHR5cGUgTU9OT0xJVEhJQ19FTkdJTkUgPSBzaWdcblxuICB0eXBlIHN0YXRlXG5cbiAgdHlwZSB0b2tlblxuXG4gIHR5cGUgc2VtYW50aWNfdmFsdWVcblxuICAoKiBBbiBlbnRyeSBwb2ludCB0byB0aGUgZW5naW5lIHJlcXVpcmVzIGEgc3RhcnQgc3RhdGUsIGEgbGV4ZXIsIGFuZCBhIGxleGluZ1xuICAgICBidWZmZXIuIEl0IGVpdGhlciBzdWNjZWVkcyBhbmQgcHJvZHVjZXMgYSBzZW1hbnRpYyB2YWx1ZSwgb3IgZmFpbHMgYW5kXG4gICAgIHJhaXNlcyBbRXJyb3JdLiAqKVxuXG4gIGV4Y2VwdGlvbiBFcnJvclxuXG4gIHZhbCBlbnRyeTpcbiAgICAoKiBzdHJhdGVneTogKikgWyBgTGVnYWN5IHwgYFNpbXBsaWZpZWQgXSAtPiAoKiBzZWUgW0luY3JlbWVudGFsRW5naW5lXSAqKVxuICAgIHN0YXRlIC0+XG4gICAgKExleGluZy5sZXhidWYgLT4gdG9rZW4pIC0+XG4gICAgTGV4aW5nLmxleGJ1ZiAtPlxuICAgIHNlbWFudGljX3ZhbHVlXG5cbmVuZFxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuKCogVGhlIGZvbGxvd2luZyBzaWduYXR1cmVzIGRlc2NyaWJlIHRoZSBpbmNyZW1lbnRhbCBMUiBlbmdpbmUuICopXG5cbigqIEZpcnN0LCBzZWUgW0lOQ1JFTUVOVEFMX0VOR0lORV0gaW4gdGhlIGZpbGUgW0luY3JlbWVudGFsRW5naW5lLm1sXS4gKilcblxuKCogVGhlIFtzdGFydF0gZnVuY3Rpb24gaXMgc2V0IGFwYXJ0IGJlY2F1c2Ugd2UgZG8gbm90IHdpc2ggdG8gcHVibGlzaFxuICAgaXQgYXMgcGFydCBvZiB0aGUgZ2VuZXJhdGVkIFtwYXJzZXIubWxpXSBmaWxlLiBJbnN0ZWFkLCB0aGUgdGFibGVcbiAgIGJhY2stZW5kIHdpbGwgcHVibGlzaCBzcGVjaWFsaXplZCB2ZXJzaW9ucyBvZiBpdCwgd2l0aCBhIHN1aXRhYmxlXG4gICB0eXBlIGNhc3QuICopXG5cbm1vZHVsZSB0eXBlIElOQ1JFTUVOVEFMX0VOR0lORV9TVEFSVCA9IHNpZ1xuXG4gICgqIFtzdGFydF0gaXMgYW4gZW50cnkgcG9pbnQuIEl0IHJlcXVpcmVzIGEgc3RhcnQgc3RhdGUgYW5kIGEgc3RhcnQgcG9zaXRpb25cbiAgICAgYW5kIGJlZ2lucyB0aGUgcGFyc2luZyBwcm9jZXNzLiBJZiB0aGUgbGV4ZXIgaXMgYmFzZWQgb24gYW4gT0NhbWwgbGV4aW5nXG4gICAgIGJ1ZmZlciwgdGhlIHN0YXJ0IHBvc2l0aW9uIHNob3VsZCBiZSBbbGV4YnVmLmxleF9jdXJyX3BdLiBbc3RhcnRdIHByb2R1Y2VzXG4gICAgIGEgY2hlY2twb2ludCwgd2hpY2ggdXN1YWxseSB3aWxsIGJlIGFuIFtJbnB1dE5lZWRlZF0gY2hlY2twb2ludC4gKEl0IGNvdWxkXG4gICAgIGJlIFtBY2NlcHRlZF0gaWYgdGhpcyBzdGFydGluZyBzdGF0ZSBhY2NlcHRzIG9ubHkgdGhlIGVtcHR5IHdvcmQuIEl0IGNvdWxkXG4gICAgIGJlIFtSZWplY3RlZF0gaWYgdGhpcyBzdGFydGluZyBzdGF0ZSBhY2NlcHRzIG5vIHdvcmQgYXQgYWxsLikgSXQgZG9lcyBub3RcbiAgICAgcmFpc2UgYW55IGV4Y2VwdGlvbi4gKilcblxuICAoKiBbc3RhcnQgcyBwb3NdIHNob3VsZCByZWFsbHkgcHJvZHVjZSBhIGNoZWNrcG9pbnQgb2YgdHlwZSBbJ2EgY2hlY2twb2ludF0sXG4gICAgIGZvciBhIGZpeGVkIFsnYV0gdGhhdCBkZXBlbmRzIG9uIHRoZSBzdGF0ZSBbc10uIFdlIGNhbm5vdCBleHByZXNzIHRoaXMsIHNvXG4gICAgIHdlIHVzZSBbc2VtYW50aWNfdmFsdWUgY2hlY2twb2ludF0sIHdoaWNoIGlzIHNhZmUuIFRoZSB0YWJsZSBiYWNrLWVuZCB1c2VzXG4gICAgIFtPYmoubWFnaWNdIHRvIHByb2R1Y2Ugc2FmZSBzcGVjaWFsaXplZCB2ZXJzaW9ucyBvZiBbc3RhcnRdLiAqKVxuXG4gIHR5cGUgc3RhdGVcbiAgdHlwZSBzZW1hbnRpY192YWx1ZVxuICB0eXBlICdhIGNoZWNrcG9pbnRcblxuICB2YWwgc3RhcnQ6XG4gICAgc3RhdGUgLT5cbiAgICBMZXhpbmcucG9zaXRpb24gLT5cbiAgICBzZW1hbnRpY192YWx1ZSBjaGVja3BvaW50XG5cbmVuZFxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuKCogVGhpcyBzaWduYXR1cmUgZGVzY3JpYmVzIHRoZSBMUiBlbmdpbmUsIHdoaWNoIGNvbWJpbmVzIHRoZSBtb25vbGl0aGljXG4gICBhbmQgaW5jcmVtZW50YWwgaW50ZXJmYWNlcy4gKilcblxubW9kdWxlIHR5cGUgRU5HSU5FID0gc2lnXG5cbiAgaW5jbHVkZSBNT05PTElUSElDX0VOR0lORVxuXG4gIGluY2x1ZGUgSW5jcmVtZW50YWxFbmdpbmUuSU5DUkVNRU5UQUxfRU5HSU5FXG4gICAgd2l0aCB0eXBlIHRva2VuIDo9IHRva2VuXG4gICAgIGFuZCB0eXBlICdhIGxyMXN0YXRlID0gc3RhdGUgKCogdXNlZnVsIGZvciB1czsgaGlkZGVuIGZyb20gdGhlIGVuZCB1c2VyICopXG5cbiAgaW5jbHVkZSBJTkNSRU1FTlRBTF9FTkdJTkVfU1RBUlRcbiAgICB3aXRoIHR5cGUgc3RhdGUgOj0gc3RhdGVcbiAgICAgYW5kIHR5cGUgc2VtYW50aWNfdmFsdWUgOj0gc2VtYW50aWNfdmFsdWVcbiAgICAgYW5kIHR5cGUgJ2EgY2hlY2twb2ludCA6PSAnYSBjaGVja3BvaW50XG5cbmVuZFxuZW5kXG5tb2R1bGUgRW5naW5lID0gc3RydWN0XG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgSW5yaWEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciAgICAgKilcbigqICAgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGlicmFyeSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMiwgd2l0aCBhICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcsIGFzIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgcG9zaXRpb24gPSBMZXhpbmcucG9zaXRpb25cbm9wZW4gRW5naW5lVHlwZXNcblxuKCogVGhlIExSIHBhcnNpbmcgZW5naW5lLiAqKVxuXG4oKiBUaGlzIG1vZHVsZSBpcyB1c2VkOlxuXG4gICAtIGF0IGNvbXBpbGUgdGltZSwgaWYgc28gcmVxdWVzdGVkIGJ5IHRoZSB1c2VyLCB2aWEgdGhlIC0taW50ZXJwcmV0IG9wdGlvbnM7XG4gICAtIGF0IHJ1biB0aW1lLCBpbiB0aGUgdGFibGUtYmFzZWQgYmFjay1lbmQuICopXG5cbm1vZHVsZSBNYWtlIChUIDogVEFCTEUpID0gc3RydWN0XG5cbiAgKCogVGhpcyBwcm9wYWdhdGVzIHR5cGUgYW5kIGV4Y2VwdGlvbiBkZWZpbml0aW9ucy4gVGhlIGZ1bmN0aW9ucyBbbnVtYmVyXSxcbiAgICAgW3Byb2R1Y3Rpb25faW5kZXhdLCBbZmluZF9wcm9kdWN0aW9uXSwgdG9vLCBhcmUgZGVmaW5lZCBieSB0aGlzIFtpbmNsdWRlXVxuICAgICBkZWNsYXJhdGlvbi4gKilcblxuICBpbmNsdWRlIFRcblxuICB0eXBlICdhIGVudiA9XG4gICAgICAoc3RhdGUsIHNlbWFudGljX3ZhbHVlLCB0b2tlbikgRW5naW5lVHlwZXMuZW52XG5cbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbiAgKCogVGhlIHR5cGUgW2NoZWNrcG9pbnRdIHJlcHJlc2VudHMgYW4gaW50ZXJtZWRpYXRlIG9yIGZpbmFsIHJlc3VsdCBvZiB0aGVcbiAgICAgcGFyc2VyLiBTZWUgW0VuZ2luZVR5cGVzXS4gKilcblxuICAoKiBUaGUgdHlwZSBbY2hlY2twb2ludF0gaXMgcHJlc2VudGVkIHRvIHRoZSB1c2VyIGFzIGEgcHJpdmF0ZSB0eXBlIChzZWVcbiAgICAgW0luY3JlbWVudGFsRW5naW5lXSkuIFRoaXMgcHJldmVudHMgdGhlIHVzZXIgZnJvbSBtYW51ZmFjdHVyaW5nXG4gICAgIGNoZWNrcG9pbnRzIChpLmUuLCBjb250aW51YXRpb25zKSB0aGF0IGRvIG5vdCBtYWtlIHNlbnNlLiAoU3VjaFxuICAgICBjb250aW51YXRpb25zIGNvdWxkIHBvdGVudGlhbGx5IHZpb2xhdGUgdGhlIExSIGludmFyaWFudCBhbmQgbGVhZCB0b1xuICAgICBjcmFzaGVzLikgKilcblxuICAoKiAyMDE3LzAzLzI5IEFsdGhvdWdoIFtjaGVja3BvaW50XSBpcyBhIHByaXZhdGUgdHlwZSwgd2Ugbm93IGV4cG9zZSBhXG4gICAgIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCBbaW5wdXRfbmVlZGVkXS4gVGhpcyBmdW5jdGlvbiBhbGxvd3MgbWFudWZhY3R1cmluZ1xuICAgICBhIGNoZWNrcG9pbnQgb3V0IG9mIGFuIGVudmlyb25tZW50LiBGb3IgdGhpcyByZWFzb24sIHRoZSB0eXBlIFtlbnZdIG11c3RcbiAgICAgYWxzbyBiZSBwYXJhbWV0ZXJpemVkIHdpdGggWydhXS4gKilcblxuICB0eXBlICdhIGNoZWNrcG9pbnQgPVxuICAgIHwgSW5wdXROZWVkZWQgb2YgJ2EgZW52XG4gICAgfCBTaGlmdGluZyBvZiAnYSBlbnYgKiAnYSBlbnYgKiBib29sXG4gICAgfCBBYm91dFRvUmVkdWNlIG9mICdhIGVudiAqIHByb2R1Y3Rpb25cbiAgICB8IEhhbmRsaW5nRXJyb3Igb2YgJ2EgZW52XG4gICAgfCBBY2NlcHRlZCBvZiAnYVxuICAgIHwgUmVqZWN0ZWRcblxuICAoKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuICAoKiBBcyBvZiAyMDIwLzEyLzE2LCB3ZSBpbnRyb2R1Y2UgYSBjaG9pY2UgYmV0d2VlbiBtdWx0aXBsZSBlcnJvciBoYW5kbGluZ1xuICAgICBzdHJhdGVnaWVzLiAqKVxuXG4gICgqIFJlZ2FyZGxlc3Mgb2YgdGhlIHN0cmF0ZWd5LCB3aGVuIGEgc3ludGF4IGVycm9yIGlzIGVuY291bnRlcmVkLCB0aGVcbiAgICAgZnVuY3Rpb24gW2luaXRpYXRlXSBpcyBjYWxsZWQsIGEgW0hhbmRsaW5nRXJyb3JdIGNoZWNrcG9pbnQgaXMgcHJvZHVjZWQsXG4gICAgIGFuZCAoYWZ0ZXIgcmVzdW1pbmcpIHRoZSBmdW5jdGlvbiBbZXJyb3JdIGlzIGNhbGxlZC4gVGhpcyBmdW5jdGlvbiBjaGVja3NcbiAgICAgd2hldGhlciB0aGUgY3VycmVudCBzdGF0ZSBhbGxvd3Mgc2hpZnRpbmcsIHJlZHVjaW5nLCBvciBuZWl0aGVyLCB3aGVuIHRoZVxuICAgICBsb29rYWhlYWQgdG9rZW4gaXMgW2Vycm9yXS4gSXRzIGJlaGF2aW9yLCB0aGVuLCBkZXBlbmRzIG9uIHRoZSBzdHJhdGVneSxcbiAgICAgYXMgZm9sbG93cy4gKilcblxuICAoKiBJbiB0aGUgbGVnYWN5IHN0cmF0ZWd5LCB3aGljaCB1bnRpbCBub3cgd2FzIHRoZSBvbmx5IHN0cmF0ZWd5LFxuXG4gICAgIC0gSWYgc2hpZnRpbmcgaXMgcG9zc2libGUsIHRoZW4gYSBbU2hpZnRpbmddIGNoZWNrcG9pbnQgaXMgcHJvZHVjZWQsXG4gICAgICAgd2hvc2UgZmllbGQgW3BsZWFzZV9kaXNjYXJkXSBpcyBbdHJ1ZV0sIHNvIChhZnRlciByZXN1bWluZykgYW5cbiAgICAgICBbSW5wdXROZWVkZWRdIGNoZWNrcG9pbnQgaXMgcHJvZHVjZWQsIGFuZCAoYWZ0ZXIgYSBuZXcgdG9rZW5cbiAgICAgICBoYXMgYmVlbiBwcm92aWRlZCkgdGhlIHBhcnNlciBsZWF2ZXMgZXJyb3ItaGFuZGxpbmcgbW9kZSBhbmRcbiAgICAgICByZXR1cm5zIHRvIG5vcm1hbCBtb2RlLlxuXG4gICAgIC0gSWYgcmVkdWNpbmcgaXMgcG9zc2libGUsIHRoZW4gb25lIG9yIG1vcmUgcmVkdWN0aW9ucyBhcmUgcGVyZm9ybWVkLlxuICAgICAgIERlZmF1bHQgcmVkdWN0aW9ucyBhcmUgYW5ub3VuY2VkIHZpYSBbQWJvdXRUb1JlZHVjZV0gY2hlY2twb2ludHMsXG4gICAgICAgd2hlcmVhcyBvcmRpbmFyeSByZWR1Y3Rpb25zIGFyZSBwZXJmb3JtZWQgc2lsZW50bHkuIChJdCBpcyB1bmNsZWFyXG4gICAgICAgd2h5IHRoaXMgaXMgc28uKSBUaGUgcGFyc2VyIHJlbWFpbnMgaW4gZXJyb3ItaGFuZGxpbmcgbW9kZSwgc29cbiAgICAgICBhbm90aGVyIFtIYW5kbGluZ0Vycm9yXSBjaGVja3BvaW50IGlzIHByb2R1Y2VkLCBhbmQgdGhlIGZ1bmN0aW9uXG4gICAgICAgW2Vycm9yXSBpcyBjYWxsZWQgYWdhaW4uXG5cbiAgICAgLSBJZiBuZWl0aGVyIGFjdGlvbiBpcyBwb3NzaWJsZSBhbmQgaWYgdGhlIHN0YWNrIGlzIG5vbmVtcHR5LCB0aGVuIGFcbiAgICAgICBjZWxsIGlzIHBvcHBlZCBvZmYgdGhlIHN0YWNrLCB0aGVuIGEgW0hhbmRsaW5nRXJyb3JdIGNoZWNrcG9pbnQgaXNcbiAgICAgICBwcm9kdWNlZCwgYW5kIHRoZSBmdW5jdGlvbiBbZXJyb3JdIGlzIGNhbGxlZCBhZ2Fpbi5cblxuICAgICAtIElmIG5laXRoZXIgYWN0aW9uIGlzIHBvc3NpYmxlIGFuZCBpZiB0aGUgc3RhY2sgaXMgZW1wdHksIHRoZW4gdGhlXG4gICAgICAgcGFyc2UgZGllcyB3aXRoIGEgW1JlamVjdF0gY2hlY2twb2ludC4gKilcblxuICAoKiBUaGUgc2ltcGxpZmllZCBzdHJhdGVneSBkaWZmZXJzIGZyb20gdGhlIGxlZ2FjeSBzdHJhdGVneSBhcyBmb2xsb3dzOlxuXG4gICAgIC0gV2hlbiBzaGlmdGluZywgYSBbU2hpZnRpbmddIGNoZWNrcG9pbnQgaXMgcHJvZHVjZWQsIHdob3NlIGZpZWxkXG4gICAgICAgW3BsZWFzZV9kaXNjYXJkXSBpcyBbZmFsc2VdLCBzbyB0aGUgcGFyc2VyIGRvZXMgbm90IHJlcXVlc3QgYW5vdGhlclxuICAgICAgIHRva2VuLCBhbmQgdGhlIHBhcnNlciByZW1haW5zIGluIGVycm9yLWhhbmRsaW5nIG1vZGUuIChJZiB0aGVcbiAgICAgICBkZXN0aW5hdGlvbiBzdGF0ZSBvZiB0aGlzIHNoaWZ0IHRyYW5zaXRpb24gaGFzIGEgZGVmYXVsdCByZWR1Y3Rpb24sXG4gICAgICAgdGhlbiB0aGUgcGFyc2VyIHdpbGwgcGVyZm9ybSB0aGlzIHJlZHVjdGlvbiBhcyBpdHMgbmV4dCBzdGVwLilcblxuICAgICAtIFdoZW4gcmVkdWNpbmcsIGFsbCByZWR1Y3Rpb25zIGFyZSBhbm5vdW5jZWQgYnkgW0Fib3V0VG9SZWR1Y2VdXG4gICAgICAgY2hlY2twb2ludHMuXG5cbiAgICAgLSBJZiBuZWl0aGVyIHNoaWZ0aW5nIFtlcnJvcl0gbm9yIHJlZHVjaW5nIG9uIFtlcnJvcl0gaXMgcG9zc2libGUsXG4gICAgICAgdGhlbiB0aGUgcGFyc2VyIGRpZXMgd2l0aCBhIFtSZWplY3RdIGNoZWNrcG9pbnQuIChUaGUgcGFyc2VyIGRvZXNcbiAgICAgICBub3QgYXR0ZW1wdCB0byBwb3AgY2VsbHMgb2ZmIHRoZSBzdGFjayBvbmUgYnkgb25lLilcblxuICAgICBUaGlzIHNpbXBsaWZpZWQgc3RyYXRlZ3kgaXMgYXBwcm9wcmlhdGUgd2hlbiB0aGUgZ3JhbW1hciB1c2VzIHRoZSBbZXJyb3JdXG4gICAgIHRva2VuIGluIGEgbGltaXRlZCB3YXksIHdoZXJlIHRoZSBbZXJyb3JdIHRva2VuIGFsd2F5cyBhcHBlYXJzIGF0IHRoZSBlbmRcbiAgICAgb2YgYSBwcm9kdWN0aW9uIHdob3NlIHNlbWFudGljIGFjdGlvbiByYWlzZXMgYW4gZXhjZXB0aW9uICh3aG9zZSBwdXJwb3NlXG4gICAgIGlzIHRvIHNpZ25hbCBhIHN5bnRheCBlcnJvciBhbmQgcGVyaGFwcyBwcm9kdWNlIGEgY3VzdG9tIG1lc3NhZ2UpLiBUaGVuLFxuICAgICB0aGUgcGFyc2VyIG11c3Qgbm90IHJlcXVlc3Qgb25lIHRva2VuIHBhc3QgdGhlIHN5bnRheCBlcnJvci4gKEluIGEgUkVQTCxcbiAgICAgdGhhdCB3b3VsZCBiZSB1bmRlc2lyYWJsZS4pIEl0IG11c3QgcGVyZm9ybSBhcyBtYW55IHJlZHVjdGlvbnMgb24gW2Vycm9yXVxuICAgICBhcyBwb3NzaWJsZSwgdGhlbiAoaWYgcG9zc2libGUpIHNoaWZ0IHRoZSBbZXJyb3JdIHRva2VuIGFuZCBtb3ZlIHRvIGEgbmV3XG4gICAgIHN0YXRlIHdoZXJlIGEgZGVmYXVsdCByZWR1Y3Rpb24gd2lsbCBiZSBwb3NzaWJsZS4gKEJlY2F1c2UgdGhlIFtlcnJvcl1cbiAgICAgdG9rZW4gYWx3YXlzIGFwcGVhcnMgYXQgdGhlIGVuZCBvZiBhIHByb2R1Y3Rpb24sIG5vIG90aGVyIGFjdGlvbiBjYW5cbiAgICAgZXhpc3QgaW4gdGhhdCBzdGF0ZSwgc28gYSBkZWZhdWx0IHJlZHVjdGlvbiBtdXN0IGV4aXN0LikgVGhlIHNlbWFudGljXG4gICAgIGFjdGlvbiByYWlzZXMgYW4gZXhjZXB0aW9uLCBhbmQgdGhhdCBpcyBpdC4gKilcblxuICAoKiBMZXQgdXMgbm90ZSB0aGF0IGl0IGlzIGFsc28gcG9zc2libGUgdG8gcGVyZm9ybSBubyBlcnJvciBoYW5kbGluZyBhdFxuICAgICBhbGwsIG9yIHRvIHBlcmZvcm0gY3VzdG9taXplZCBlcnJvciBoYW5kbGluZywgYnkgc3RvcHBpbmcgYXMgc29vbiBhc1xuICAgICB0aGUgZmlyc3QgW0Vycm9ySGFuZGxpbmddIGNoZWNrcG9pbnQgYXBwZWFycy4gKilcblxuICB0eXBlIHN0cmF0ZWd5ID1cbiAgICBbIGBMZWdhY3kgfCBgU2ltcGxpZmllZCBdXG5cbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbiAgKCogSW4gdGhlIGNvZGUtYmFzZWQgYmFjay1lbmQsIHRoZSBbcnVuXSBmdW5jdGlvbiBpcyBzb21ldGltZXMgcmVzcG9uc2libGVcbiAgICAgZm9yIHB1c2hpbmcgYSBuZXcgY2VsbCBvbiB0aGUgc3RhY2suIFRoaXMgaXMgbW90aXZhdGVkIGJ5IGNvZGUgc2hhcmluZ1xuICAgICBjb25jZXJucy4gSW4gdGhpcyBpbnRlcnByZXRlciwgdGhlcmUgaXMgbm8gc3VjaCBjb25jZXJuOyBbcnVuXSdzIGNhbGxlclxuICAgICBpcyBhbHdheXMgcmVzcG9uc2libGUgZm9yIHVwZGF0aW5nIHRoZSBzdGFjay4gKilcblxuICAoKiBJbiB0aGUgY29kZS1iYXNlZCBiYWNrLWVuZCwgdGhlcmUgaXMgYSBbcnVuXSBmdW5jdGlvbiBmb3IgZWFjaCBzdGF0ZVxuICAgICBbc10uIFRoaXMgZnVuY3Rpb24gY2FuIGJlaGF2ZSBpbiB0d28gc2xpZ2h0bHkgZGlmZmVyZW50IHdheXMsIGRlcGVuZGluZ1xuICAgICBvbiB3aGVuIGl0IGlzIGludm9rZWQsIG9yIChlcXVpdmFsZW50bHkpIGRlcGVuZGluZyBvbiBbc10uXG5cbiAgICAgSWYgW3J1bl0gaXMgaW52b2tlZCBhZnRlciBzaGlmdGluZyBhIHRlcm1pbmFsIHN5bWJvbCAob3IsIGVxdWl2YWxlbnRseSxcbiAgICAgaWYgW3NdIGhhcyBhIHRlcm1pbmFsIGluY29taW5nIHN5bWJvbCksIHRoZW4gW3J1bl0gZGlzY2FyZHMgYSB0b2tlbixcbiAgICAgdW5sZXNzIFtzXSBoYXMgYSBkZWZhdWx0IHJlZHVjdGlvbiBvbiBbI10uIChJbmRlZWQsIGluIHRoYXQgY2FzZSxcbiAgICAgcmVxdWVzdGluZyB0aGUgbmV4dCB0b2tlbiBtaWdodCBkcml2ZSB0aGUgbGV4ZXIgb2ZmIHRoZSBlbmQgb2YgdGhlIGlucHV0XG4gICAgIHN0cmVhbS4pXG5cbiAgICAgSWYsIG9uIHRoZSBvdGhlciBoYW5kLCBbcnVuXSBpcyBpbnZva2VkIGFmdGVyIHBlcmZvcm1pbmcgYSBnb3RvXG4gICAgIHRyYW5zaXRpb24sIG9yIGludm9rZWQgZGlyZWN0bHkgYnkgYW4gZW50cnkgcG9pbnQsIHRoZW4gdGhlcmUgaXMgbm90aGluZ1xuICAgICB0byBkaXNjYXJkLlxuXG4gICAgIFRoZXNlIHR3byBjYXNlcyBhcmUgcmVmbGVjdGVkIGluIFtDb2RlQmFja2VuZC5nZXR0b2tlbl0uXG5cbiAgICAgSGVyZSwgdGhlIGNvZGUgaXMgc3RydWN0dXJlZCBpbiBhIHNsaWdodGx5IGRpZmZlcmVudCB3YXkuIEl0IGlzIHVwIHRvIHRoZVxuICAgICBjYWxsZXIgb2YgW3J1bl0gdG8gaW5kaWNhdGUgd2hldGhlciB0byBkaXNjYXJkIGEgdG9rZW4sIHZpYSB0aGUgcGFyYW1ldGVyXG4gICAgIFtwbGVhc2VfZGlzY2FyZF0uIFRoaXMgZmxhZyBpcyBzZXQgd2hlbiBbc10gaXMgYmVpbmcgZW50ZXJlZCBieSBzaGlmdGluZ1xuICAgICBhIHRlcm1pbmFsIHN5bWJvbCBhbmQgW3NdIGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0IHJlZHVjdGlvbiBvbiBbI10uICopXG5cbiAgKCogVGhlIGZvbGxvd2luZyByZWN1cnNpdmUgZ3JvdXAgb2YgZnVuY3Rpb25zIGFyZSB0YWlsIHJlY3Vyc2l2ZSwgcHJvZHVjZSBhXG4gICAgIGNoZWNrcG9pbnQgb2YgdHlwZSBbc2VtYW50aWNfdmFsdWUgY2hlY2twb2ludF0sIGFuZCBjYW5ub3QgcmFpc2UgYW5cbiAgICAgZXhjZXB0aW9uLiAqKVxuXG4gIGxldCByZWMgcnVuIGVudiBwbGVhc2VfZGlzY2FyZCA6IHNlbWFudGljX3ZhbHVlIGNoZWNrcG9pbnQgPVxuXG4gICAgKCogTG9nIHRoZSBmYWN0IHRoYXQgd2UganVzdCBlbnRlcmVkIHRoaXMgc3RhdGUuICopXG5cbiAgICBpZiBsb2cgdGhlblxuICAgICAgTG9nLnN0YXRlIGVudi5jdXJyZW50O1xuXG4gICAgKCogSWYgW3BsZWFzZV9kaXNjYXJkXSBpcyBzZXQsIHdlIGRpc2NhcmQgdGhlIGN1cnJlbnQgbG9va2FoZWFkIHRva2VuIGFuZFxuICAgICAgIGZldGNoIHRoZSBuZXh0IG9uZS4gSW4gb3JkZXIgdG8gcmVxdWVzdCBhIHRva2VuIGZyb20gdGhlIHVzZXIsIHdlXG4gICAgICAgcmV0dXJuIGFuIFtJbnB1dE5lZWRlZF0gY29udGludWF0aW9uLCB3aGljaCwgd2hlbiBpbnZva2VkIGJ5IHRoZSB1c2VyLFxuICAgICAgIHdpbGwgdGFrZSB1cyB0byBbZGlzY2FyZF0uIElmIFtwbGVhc2VfZGlzY2FyZF0gaXMgbm90IHNldCwgd2Ugc2tpcCB0aGlzXG4gICAgICAgc3RlcCBhbmQganVtcCBkaXJlY3RseSB0byBbY2hlY2tfZm9yX2RlZmF1bHRfcmVkdWN0aW9uXS4gKilcblxuICAgIGlmIHBsZWFzZV9kaXNjYXJkIHRoZW5cbiAgICAgIElucHV0TmVlZGVkIGVudlxuICAgIGVsc2VcbiAgICAgIGNoZWNrX2Zvcl9kZWZhdWx0X3JlZHVjdGlvbiBlbnZcblxuICAoKiBbZGlzY2FyZCBlbnYgdHJpcGxlXSBzdG9yZXMgW3RyaXBsZV0gaW50byBbZW52XSwgb3ZlcndyaXRpbmcgdGhlIHByZXZpb3VzXG4gICAgIHRva2VuLiBJdCBpcyBpbnZva2VkIGJ5IFtvZmZlcl0sIHdoaWNoIGl0c2VsZiBpcyBpbnZva2VkIGJ5IHRoZSB1c2VyIGluXG4gICAgIHJlc3BvbnNlIHRvIGFuIFtJbnB1dE5lZWRlZF0gY2hlY2twb2ludC4gKilcblxuICBhbmQgZGlzY2FyZCBlbnYgdHJpcGxlID1cbiAgICBpZiBsb2cgdGhlbiBiZWdpblxuICAgICAgbGV0ICh0b2tlbiwgc3RhcnRwLCBlbmRwKSA9IHRyaXBsZSBpblxuICAgICAgTG9nLmxvb2thaGVhZF90b2tlbiAoVC50b2tlbjJ0ZXJtaW5hbCB0b2tlbikgc3RhcnRwIGVuZHBcbiAgICBlbmQ7XG4gICAgbGV0IGVudiA9IHsgZW52IHdpdGggZXJyb3IgPSBmYWxzZTsgdHJpcGxlIH0gaW5cbiAgICBjaGVja19mb3JfZGVmYXVsdF9yZWR1Y3Rpb24gZW52XG5cbiAgYW5kIGNoZWNrX2Zvcl9kZWZhdWx0X3JlZHVjdGlvbiBlbnYgPVxuXG4gICAgKCogRXhhbWluZSB3aGF0IHNpdHVhdGlvbiB3ZSBhcmUgaW4uIFRoaXMgY2FzZSBhbmFseXNpcyBpcyBhbmFsb2dvdXMgdG9cbiAgICAgICB0aGF0IHBlcmZvcm1lZCBpbiBbQ29kZUJhY2tlbmQuZ2V0dG9rZW5dLCBpbiB0aGUgc3ViLWNhc2Ugd2hlcmUgd2UgZG9cbiAgICAgICBub3QgaGF2ZSBhIHRlcm1pbmFsIGluY29taW5nIHN5bWJvbC4gKilcblxuICAgIFQuZGVmYXVsdF9yZWR1Y3Rpb25cbiAgICAgIGVudi5jdXJyZW50XG4gICAgICBhbm5vdW5jZV9yZWR1Y2UgICAgICAgKCogdGhlcmUgaXMgYSBkZWZhdWx0IHJlZHVjdGlvbjsgcGVyZm9ybSBpdCAqKVxuICAgICAgY2hlY2tfZm9yX2Vycm9yX3Rva2VuICgqIHRoZXJlIGlzIG5vbmU7IGNvbnRpbnVlIGJlbG93ICopXG4gICAgICBlbnZcblxuICBhbmQgY2hlY2tfZm9yX2Vycm9yX3Rva2VuIGVudiA9XG5cbiAgICAoKiBUaGVyZSBpcyBubyBkZWZhdWx0IHJlZHVjdGlvbi4gQ29uc3VsdCB0aGUgY3VycmVudCBsb29rYWhlYWQgdG9rZW5cbiAgICAgICBzbyBhcyB0byBkZXRlcm1pbmUgd2hpY2ggYWN0aW9uIHNob3VsZCBiZSB0YWtlbi4gKilcblxuICAgICgqIFBlZWtpbmcgYXQgdGhlIGZpcnN0IGlucHV0IHRva2VuLCB3aXRob3V0IHRha2luZyBpdCBvZmYgdGhlIGlucHV0XG4gICAgICAgc3RyZWFtLCBpcyBkb25lIGJ5IHJlYWRpbmcgW2Vudi50cmlwbGVdLiBXZSBhcmUgY2FyZWZ1bCB0byBmaXJzdFxuICAgICAgIGNoZWNrIFtlbnYuZXJyb3JdLiAqKVxuXG4gICAgKCogTm90ZSB0aGF0LCBpZiBbcGxlYXNlX2Rpc2NhcmRdIHdhcyB0cnVlLCB0aGVuIHdlIGhhdmUganVzdCBjYWxsZWRcbiAgICAgICBbZGlzY2FyZF0sIHNvIHRoZSBsb29rYWhlYWQgdG9rZW4gY2Fubm90IGJlIFtlcnJvcl0uICopXG5cbiAgICAoKiBSZXR1cm5pbmcgW0hhbmRsaW5nRXJyb3IgZW52XSBpcyBsaWtlIGNhbGxpbmcgW2Vycm9yIH5zdHJhdGVneSBlbnZdXG4gICAgICAgZGlyZWN0bHksIGV4Y2VwdCBpdCBhbGxvd3MgdGhlIHVzZXIgdG8gcmVnYWluIGNvbnRyb2wgYW5kIGNob29zZSBhblxuICAgICAgIGVycm9yLWhhbmRsaW5nIHN0cmF0ZWd5LiAqKVxuXG4gICAgaWYgZW52LmVycm9yIHRoZW4gYmVnaW5cbiAgICAgIGlmIGxvZyB0aGVuXG4gICAgICAgIExvZy5yZXN1bWluZ19lcnJvcl9oYW5kbGluZygpO1xuICAgICAgSGFuZGxpbmdFcnJvciBlbnZcbiAgICBlbmRcbiAgICBlbHNlXG4gICAgICBsZXQgKHRva2VuLCBfLCBfKSA9IGVudi50cmlwbGUgaW5cblxuICAgICAgKCogV2UgY29uc3VsdCB0aGUgdHdvLWRpbWVuc2lvbmFsIGFjdGlvbiB0YWJsZSwgaW5kZXhlZCBieSB0aGVcbiAgICAgICAgIGN1cnJlbnQgc3RhdGUgYW5kIHRoZSBjdXJyZW50IGxvb2thaGVhZCB0b2tlbiwgaW4gb3JkZXIgdG9cbiAgICAgICAgIGRldGVybWluZSB3aGljaCBhY3Rpb24gc2hvdWxkIGJlIHRha2VuLiAqKVxuXG4gICAgICBULmFjdGlvblxuICAgICAgICBlbnYuY3VycmVudCAgICAgICAgICAgICAgICAgICAgKCogZGV0ZXJtaW5lcyBhIHJvdyAqKVxuICAgICAgICAoVC50b2tlbjJ0ZXJtaW5hbCB0b2tlbikgICAgICAgKCogZGV0ZXJtaW5lcyBhIGNvbHVtbiAqKVxuICAgICAgICAoVC50b2tlbjJ2YWx1ZSB0b2tlbilcbiAgICAgICAgc2hpZnQgICAgICAgICAgICAgICAgICAgICAgICAgICgqIHNoaWZ0IGNvbnRpbnVhdGlvbiAqKVxuICAgICAgICBhbm5vdW5jZV9yZWR1Y2UgICAgICAgICAgICAgICAgKCogcmVkdWNlIGNvbnRpbnVhdGlvbiAqKVxuICAgICAgICBpbml0aWF0ZSAgICAgICAgICAgICAgICAgICAgICAgKCogZmFpbHVyZSBjb250aW51YXRpb24gKilcbiAgICAgICAgZW52XG5cbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbiAgKCogVGhpcyBmdW5jdGlvbiB0YWtlcyBjYXJlIG9mIHNoaWZ0IHRyYW5zaXRpb25zIGFsb25nIGEgdGVybWluYWwgc3ltYm9sLlxuICAgICAoR290byB0cmFuc2l0aW9ucyBhcmUgdGFrZW4gY2FyZSBvZiB3aXRoaW4gW3JlZHVjZV0gYmVsb3cuKSBUaGUgc3ltYm9sXG4gICAgIGNhbiBiZSBlaXRoZXIgYW4gYWN0dWFsIHRva2VuIG9yIHRoZSBbZXJyb3JdIHBzZXVkby10b2tlbi4gKilcblxuICAoKiBIZXJlLCB0aGUgbG9va2FoZWFkIHRva2VuIENBTiBiZSBbZXJyb3JdLiAqKVxuXG4gIGFuZCBzaGlmdCBlbnZcbiAgICAgIChwbGVhc2VfZGlzY2FyZCA6IGJvb2wpXG4gICAgICAodGVybWluYWwgOiB0ZXJtaW5hbClcbiAgICAgICh2YWx1ZSA6IHNlbWFudGljX3ZhbHVlKVxuICAgICAgKHMnIDogc3RhdGUpID1cblxuICAgICgqIExvZyB0aGUgdHJhbnNpdGlvbi4gKilcblxuICAgIGlmIGxvZyB0aGVuXG4gICAgICBMb2cuc2hpZnQgdGVybWluYWwgcyc7XG5cbiAgICAoKiBQdXNoIGEgbmV3IGNlbGwgb250byB0aGUgc3RhY2ssIGNvbnRhaW5pbmcgdGhlIGlkZW50aXR5IG9mIHRoZVxuICAgICAgIHN0YXRlIHRoYXQgd2UgYXJlIGxlYXZpbmcuICopXG5cbiAgICBsZXQgKF8sIHN0YXJ0cCwgZW5kcCkgPSBlbnYudHJpcGxlIGluXG4gICAgbGV0IHN0YWNrID0ge1xuICAgICAgc3RhdGUgPSBlbnYuY3VycmVudDtcbiAgICAgIHNlbXYgPSB2YWx1ZTtcbiAgICAgIHN0YXJ0cDtcbiAgICAgIGVuZHA7XG4gICAgICBuZXh0ID0gZW52LnN0YWNrO1xuICAgIH0gaW5cblxuICAgICgqIFN3aXRjaCB0byBzdGF0ZSBbcyddLiAqKVxuXG4gICAgbGV0IG5ld19lbnYgPSB7IGVudiB3aXRoIHN0YWNrOyBjdXJyZW50ID0gcycgfSBpblxuXG4gICAgKCogRXhwb3NlIHRoZSB0cmFuc2l0aW9uIHRvIHRoZSB1c2VyLiAoSW4gcHJpbmNpcGxlLCB3ZSBoYXZlIGEgY2hvaWNlXG4gICAgICAgYmV0d2VlbiBleHBvc2luZyB0aGUgdHJhbnNpdGlvbiBiZWZvcmUgd2UgdGFrZSBpdCwgYWZ0ZXIgd2UgdGFrZVxuICAgICAgIGl0LCBvciBhdCBzb21lIHBvaW50IGluIGJldHdlZW4uIFRoaXMgYWZmZWN0cyB0aGUgbnVtYmVyIGFuZCB0eXBlXG4gICAgICAgb2YgdGhlIHBhcmFtZXRlcnMgY2FycmllZCBieSBbU2hpZnRpbmddLiBIZXJlLCB3ZSBjaG9vc2UgdG8gZXhwb3NlXG4gICAgICAgdGhlIHRyYW5zaXRpb24gYWZ0ZXIgd2UgdGFrZSBpdDsgdGhpcyBhbGxvd3MgW1NoaWZ0aW5nXSB0byBjYXJyeVxuICAgICAgIG9ubHkgdGhyZWUgcGFyYW1ldGVycywgd2hvc2UgbWVhbmluZyBpcyBzaW1wbGUuKSAqKVxuXG4gICAgU2hpZnRpbmcgKGVudiwgbmV3X2VudiwgcGxlYXNlX2Rpc2NhcmQpXG5cbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbiAgKCogVGhlIGZ1bmN0aW9uIFthbm5vdW5jZV9yZWR1Y2VdIHN0b3BzIHRoZSBwYXJzZXIgYW5kIHJldHVybnMgYSBjaGVja3BvaW50XG4gICAgIHdoaWNoIGFsbG93cyB0aGUgcGFyc2VyIHRvIGJlIHJlc3VtZWQgYnkgY2FsbGluZyBbcmVkdWNlXS4gKilcblxuICAoKiBPbmx5IG9yZGluYXJ5IHByb2R1Y3Rpb25zIGFyZSBleHBvc2VkIHRvIHRoZSB1c2VyLiBTdGFydCBwcm9kdWN0aW9uc1xuICAgICBhcmUgbm90IGV4cG9zZWQgdG8gdGhlIHVzZXIuIFJlZHVjaW5nIGEgc3RhcnQgcHJvZHVjdGlvbiBzaW1wbHkgbGVhZHNcbiAgICAgdG8gdGhlIHN1Y2Nlc3NmdWwgdGVybWluYXRpb24gb2YgdGhlIHBhcnNlci4gKilcblxuICBhbmQgYW5ub3VuY2VfcmVkdWNlIGVudiAocHJvZCA6IHByb2R1Y3Rpb24pID1cbiAgICBpZiBULmlzX3N0YXJ0IHByb2QgdGhlblxuICAgICAgYWNjZXB0IGVudiBwcm9kXG4gICAgZWxzZVxuICAgICAgQWJvdXRUb1JlZHVjZSAoZW52LCBwcm9kKVxuXG4gICgqIFRoZSBmdW5jdGlvbiBbcmVkdWNlXSB0YWtlcyBjYXJlIG9mIHJlZHVjdGlvbnMuIEl0IGlzIGludm9rZWQgYnlcbiAgICAgW3Jlc3VtZV0gYWZ0ZXIgYW4gW0Fib3V0VG9SZWR1Y2VdIGV2ZW50IGhhcyBiZWVuIHByb2R1Y2VkLiAqKVxuXG4gICgqIEhlcmUsIHRoZSBsb29rYWhlYWQgdG9rZW4gQ0FOIGJlIFtlcnJvcl0uICopXG5cbiAgKCogVGhlIHByb2R1Y3Rpb24gW3Byb2RdIENBTk5PVCBiZSBhIHN0YXJ0IHByb2R1Y3Rpb24uICopXG5cbiAgYW5kIHJlZHVjZSBlbnYgKHByb2QgOiBwcm9kdWN0aW9uKSA9XG5cbiAgICAoKiBMb2cgYSByZWR1Y3Rpb24gZXZlbnQuICopXG5cbiAgICBpZiBsb2cgdGhlblxuICAgICAgTG9nLnJlZHVjZV9vcl9hY2NlcHQgcHJvZDtcblxuICAgICgqIEludm9rZSB0aGUgc2VtYW50aWMgYWN0aW9uLiBUaGUgc2VtYW50aWMgYWN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvclxuICAgICAgIHRydW5jYXRpbmcgdGhlIHN0YWNrIGFuZCBwdXNoaW5nIGEgbmV3IGNlbGwgb250byB0aGUgc3RhY2ssIHdoaWNoXG4gICAgICAgY29udGFpbnMgYSBuZXcgc2VtYW50aWMgdmFsdWUuIFRoZSBzZW1hbnRpYyBhY3Rpb24gcmV0dXJucyBhIG5ldyBzdGFjayxcbiAgICAgICB3aGljaCBiZWNvbWVzIHRoZSBjdXJyZW50IHN0YWNrLiAqKVxuXG4gICAgbGV0IHN0YWNrID0gVC5zZW1hbnRpY19hY3Rpb24gcHJvZCBlbnYgaW5cblxuICAgICgqIEJ5IG91ciBjb252ZW50aW9uLCB0aGUgc2VtYW50aWMgYWN0aW9uIGhhcyBwcm9kdWNlZCBhbiB1cGRhdGVkXG4gICAgICAgc3RhY2suIFRoZSBzdGF0ZSBub3cgZm91bmQgaW4gdGhlIHRvcCBzdGFjayBjZWxsIGlzIHRoZSByZXR1cm5cbiAgICAgICBzdGF0ZS4gKilcblxuICAgICgqIFBlcmZvcm0gYSBnb3RvIHRyYW5zaXRpb24uIFRoZSB0YXJnZXQgc3RhdGUgaXMgZGV0ZXJtaW5lZFxuICAgICAgIGJ5IGNvbnN1bHRpbmcgdGhlIGdvdG8gdGFibGUgYXQgdGhlIHJldHVybiBzdGF0ZSBhbmQgYXRcbiAgICAgICBwcm9kdWN0aW9uIFtwcm9kXS4gKilcblxuICAgIGxldCBjdXJyZW50ID0gVC5nb3RvX3Byb2Qgc3RhY2suc3RhdGUgcHJvZCBpblxuICAgIGxldCBlbnYgPSB7IGVudiB3aXRoIHN0YWNrOyBjdXJyZW50IH0gaW5cbiAgICBydW4gZW52IGZhbHNlXG5cbiAgYW5kIGFjY2VwdCBlbnYgcHJvZCA9XG4gICAgKCogTG9nIGFuIGFjY2VwdCBldmVudC4gKilcbiAgICBpZiBsb2cgdGhlblxuICAgICAgTG9nLnJlZHVjZV9vcl9hY2NlcHQgcHJvZDtcbiAgICAoKiBFeHRyYWN0IHRoZSBzZW1hbnRpYyB2YWx1ZSBvdXQgb2YgdGhlIHN0YWNrLiAqKVxuICAgIGxldCB2ID0gZW52LnN0YWNrLnNlbXYgaW5cbiAgICAoKiBGaW5pc2guICopXG4gICAgQWNjZXB0ZWQgdlxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4gICgqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGRlYWwgd2l0aCBlcnJvcnMuICopXG5cbiAgKCogW2luaXRpYXRlXSBpbml0aWF0ZXMgb3IgcmVzdW1lcyBlcnJvciBoYW5kbGluZy4gKilcblxuICAoKiBIZXJlLCB0aGUgbG9va2FoZWFkIHRva2VuIENBTiBiZSBbZXJyb3JdLiAqKVxuXG4gIGFuZCBpbml0aWF0ZSBlbnYgPVxuICAgIGlmIGxvZyB0aGVuXG4gICAgICBMb2cuaW5pdGlhdGluZ19lcnJvcl9oYW5kbGluZygpO1xuICAgIGxldCBlbnYgPSB7IGVudiB3aXRoIGVycm9yID0gdHJ1ZSB9IGluXG4gICAgSGFuZGxpbmdFcnJvciBlbnZcblxuICAoKiBbZXJyb3JdIGhhbmRsZXMgZXJyb3JzLiAqKVxuXG4gIGFuZCBlcnJvciB+c3RyYXRlZ3kgZW52ID1cbiAgICBhc3NlcnQgZW52LmVycm9yO1xuXG4gICAgKCogQ29uc3VsdCB0aGUgY29sdW1uIGFzc29jaWF0ZWQgd2l0aCB0aGUgW2Vycm9yXSBwc2V1ZG8tdG9rZW4gaW4gdGhlXG4gICAgICAgYWN0aW9uIHRhYmxlLiAqKVxuXG4gICAgVC5hY3Rpb25cbiAgICAgIGVudi5jdXJyZW50ICAgICAgICAgICAgICAgICAgICAoKiBkZXRlcm1pbmVzIGEgcm93ICopXG4gICAgICBULmVycm9yX3Rlcm1pbmFsICAgICAgICAgICAgICAgKCogZGV0ZXJtaW5lcyBhIGNvbHVtbiAqKVxuICAgICAgVC5lcnJvcl92YWx1ZVxuICAgICAgKGVycm9yX3NoaWZ0IH5zdHJhdGVneSkgICAgICAgICgqIHNoaWZ0IGNvbnRpbnVhdGlvbiAqKVxuICAgICAgKGVycm9yX3JlZHVjZSB+c3RyYXRlZ3kpICAgICAgICgqIHJlZHVjZSBjb250aW51YXRpb24gKilcbiAgICAgIChlcnJvcl9mYWlsIH5zdHJhdGVneSkgICAgICAgICAoKiBmYWlsdXJlIGNvbnRpbnVhdGlvbiAqKVxuICAgICAgZW52XG5cbiAgYW5kIGVycm9yX3NoaWZ0IH5zdHJhdGVneSBlbnYgcGxlYXNlX2Rpc2NhcmQgdGVybWluYWwgdmFsdWUgcycgPVxuICAgIGFzc2VydCAodGVybWluYWwgPSBULmVycm9yX3Rlcm1pbmFsICYmIHZhbHVlID0gVC5lcnJvcl92YWx1ZSk7XG5cbiAgICAoKiBUaGlzIHN0YXRlIGlzIGNhcGFibGUgb2Ygc2hpZnRpbmcgdGhlIFtlcnJvcl0gdG9rZW4uICopXG5cbiAgICBpZiBsb2cgdGhlblxuICAgICAgTG9nLmhhbmRsaW5nX2Vycm9yIGVudi5jdXJyZW50O1xuXG4gICAgKCogSW4gdGhlIHNpbXBsaWZpZWQgc3RyYXRlZ3ksIHdlIGNoYW5nZSBbcGxlYXNlX2Rpc2NhcmRdIHRvIFtmYWxzZV0sXG4gICAgICAgd2hpY2ggbWVhbnMgdGhhdCB3ZSB3b24ndCByZXF1ZXN0IHRoZSBuZXh0IHRva2VuIGFuZCAodGhlcmVmb3JlKVxuICAgICAgIHdlIHdpbGwgcmVtYWluIGluIGVycm9yLWhhbmRsaW5nIG1vZGUgYWZ0ZXIgc2hpZnRpbmcgdGhlIFtlcnJvcl1cbiAgICAgICB0b2tlbi4gKilcblxuICAgIGxldCBwbGVhc2VfZGlzY2FyZCA9XG4gICAgICBtYXRjaCBzdHJhdGVneSB3aXRoIGBMZWdhY3kgLT4gcGxlYXNlX2Rpc2NhcmQgfCBgU2ltcGxpZmllZCAtPiBmYWxzZVxuICAgIGluXG5cbiAgICBzaGlmdCBlbnYgcGxlYXNlX2Rpc2NhcmQgdGVybWluYWwgdmFsdWUgcydcblxuICBhbmQgZXJyb3JfcmVkdWNlIH5zdHJhdGVneSBlbnYgcHJvZCA9XG5cbiAgICAoKiBUaGlzIHN0YXRlIGlzIGNhcGFibGUgb2YgcGVyZm9ybWluZyBhIHJlZHVjdGlvbiBvbiBbZXJyb3JdLiAqKVxuXG4gICAgaWYgbG9nIHRoZW5cbiAgICAgIExvZy5oYW5kbGluZ19lcnJvciBlbnYuY3VycmVudDtcblxuICAgICgqIEluIHRoZSBsZWdhY3kgc3RyYXRlZ3ksIHdlIGNhbGwgW3JlZHVjZV0gaW5zdGVhZCBvZiBbYW5ub3VuY2VfcmVkdWNlXSxcbiAgICAgICBhcHBhcmVudGx5IGluIGFuIGF0dGVtcHQgdG8gaGlkZSB0aGUgcmVkdWN0aW9uIHN0ZXBzIHBlcmZvcm1lZCBkdXJpbmdcbiAgICAgICBlcnJvciBoYW5kbGluZy4gSW4gdGhlIHNpbXBsaWZpZWQgc3RyYXRlZ3ksIGFsbCByZWR1Y3Rpb25zIHN0ZXBzIGFyZVxuICAgICAgIGFubm91bmNlZC4gKilcblxuICAgIG1hdGNoIHN0cmF0ZWd5IHdpdGhcbiAgICB8IGBMZWdhY3kgLT5cbiAgICAgICAgcmVkdWNlIGVudiBwcm9kXG4gICAgfCBgU2ltcGxpZmllZCAtPlxuICAgICAgICBhbm5vdW5jZV9yZWR1Y2UgZW52IHByb2RcblxuICBhbmQgZXJyb3JfZmFpbCB+c3RyYXRlZ3kgZW52ID1cblxuICAgICgqIFRoaXMgc3RhdGUgaXMgdW5hYmxlIHRvIGhhbmRsZSBlcnJvcnMuIEluIHRoZSBzaW1wbGlmaWVkIHN0cmF0ZWd5LCB3ZVxuICAgICAgIGRpZSBpbW1lZGlhdGVseS4gSW4gdGhlIGxlZ2FjeSBzdHJhdGVneSwgd2UgYXR0ZW1wdCB0byBwb3AgYSBzdGFja1xuICAgICAgIGNlbGwuIChUaGlzIGFtb3VudHMgdG8gZm9yZ2V0dGluZyBwYXJ0IG9mIHdoYXQgd2UgaGF2ZSBqdXN0IHJlYWQsIGluXG4gICAgICAgdGhlIGhvcGUgb2YgcmVhY2hpbmcgYSBzdGF0ZSB3aGVyZSB3ZSBjYW4gc2hpZnQgdGhlIFtlcnJvcl0gdG9rZW4gYW5kXG4gICAgICAgcmVzdW1lIHBhcnNpbmcgaW4gbm9ybWFsIG1vZGUuIEZvcmdldHRpbmcgcGFzdCBpbnB1dCBpcyBub3QgYXBwcm9wcmlhdGVcbiAgICAgICB3aGVuIHRoZSBnb2FsIGlzIG1lcmVseSB0byBwcm9kdWNlIGEgZ29vZCBzeW50YXggZXJyb3IgbWVzc2FnZS4pICopXG5cbiAgICBtYXRjaCBzdHJhdGVneSB3aXRoXG4gICAgfCBgU2ltcGxpZmllZCAtPlxuICAgICAgICBSZWplY3RlZFxuICAgIHwgYExlZ2FjeSAtPlxuXG4gICAgKCogQXR0ZW1wdCB0byBwb3AgYSBzdGFjayBjZWxsLiAqKVxuXG4gICAgbGV0IGNlbGwgPSBlbnYuc3RhY2sgaW5cbiAgICBsZXQgbmV4dCA9IGNlbGwubmV4dCBpblxuICAgIGlmIG5leHQgPT0gY2VsbCB0aGVuXG5cbiAgICAgICgqIFRoZSBzdGFjayBpcyBlbXB0eS4gRGllLiAqKVxuXG4gICAgICBSZWplY3RlZFxuXG4gICAgZWxzZSBiZWdpblxuXG4gICAgICAoKiBUaGUgc3RhY2sgaXMgbm9uZW1wdHkuIFBvcCBhIGNlbGwsIHVwZGF0aW5nIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICAgICB0byB0aGUgc3RhdGUgW2NlbGwuc3RhdGVdIGZvdW5kIGluIHRoZSBwb3BwZWQgY2VsbCwgYW5kIGNvbnRpbnVlXG4gICAgICAgICBlcnJvciBoYW5kbGluZyB0aGVyZS4gKilcblxuICAgICAgKCogSSBub3RlIHRoYXQgaWYgdGhlIG5ldyBzdGF0ZSBbY2VsbC5zdGF0ZV0gaGFzIGEgZGVmYXVsdCByZWR1Y3Rpb24sXG4gICAgICAgICB0aGVuIGl0IGlzIGlnbm9yZWQuIEl0IGlzIHVuY2xlYXIgd2hldGhlciB0aGlzIGlzIGludGVudGlvbmFsLiBJdFxuICAgICAgICAgY291bGQgYmUgYSBnb29kIHRoaW5nLCBhcyBpdCBhdm9pZHMgYSBzY2VuYXJpbyB3aGVyZSB0aGUgcGFyc2VyXG4gICAgICAgICBkaXZlcmdlcyBieSByZXBlYXRlZGx5IHBvcHBpbmcsIHBlcmZvcm1pbmcgYSBkZWZhdWx0IHJlZHVjdGlvbiBvZlxuICAgICAgICAgYW4gZXBzaWxvbiBwcm9kdWN0aW9uLCBwb3BwaW5nLCBldGMuIFN0aWxsLCB0aGUgcXVlc3Rpb24gb2Ygd2hldGhlclxuICAgICAgICAgdG8gb2JleSBkZWZhdWx0IHJlZHVjdGlvbnMgd2hpbGUgZXJyb3IgaGFuZGxpbmcgc2VlbXMgb2JzY3VyZS4gKilcblxuICAgICAgbGV0IGVudiA9IHsgZW52IHdpdGhcbiAgICAgICAgc3RhY2sgPSBuZXh0O1xuICAgICAgICBjdXJyZW50ID0gY2VsbC5zdGF0ZVxuICAgICAgfSBpblxuICAgICAgSGFuZGxpbmdFcnJvciBlbnZcblxuICAgIGVuZFxuXG4gICgqIEVuZCBvZiB0aGUgbmVzdCBvZiB0YWlsIHJlY3Vyc2l2ZSBmdW5jdGlvbnMuICopXG5cbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4gICgqIFRoZSBpbmNyZW1lbnRhbCBpbnRlcmZhY2UuIFNlZSBbRW5naW5lVHlwZXNdLiAqKVxuXG4gICgqIFtzdGFydCBzXSBiZWdpbnMgdGhlIHBhcnNpbmcgcHJvY2Vzcy4gKilcblxuICBsZXQgc3RhcnQgKHMgOiBzdGF0ZSkgKGluaXRpYWwgOiBwb3NpdGlvbikgOiBzZW1hbnRpY192YWx1ZSBjaGVja3BvaW50ID1cblxuICAgICgqIEJ1aWxkIGFuIGVtcHR5IHN0YWNrLiBUaGlzIGlzIGEgZHVtbXkgY2VsbCwgd2hpY2ggaXMgaXRzIG93biBzdWNjZXNzb3IuXG4gICAgICAgSXRzIFtuZXh0XSBmaWVsZCBXSUxMIGJlIGFjY2Vzc2VkIGJ5IFtlcnJvcl9mYWlsXSBpZiBhbiBlcnJvciBvY2N1cnMgYW5kXG4gICAgICAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSB1bnRpbCB0aGUgc3RhY2sgaXMgZW1wdHkuIEl0cyBbZW5kcF0gZmllbGQgV0lMTFxuICAgICAgIGJlIGFjY2Vzc2VkIChieSBhIHNlbWFudGljIGFjdGlvbikgaWYgYW4gZXBzaWxvbiBwcm9kdWN0aW9uIGlzIHJlZHVjZWRcbiAgICAgICB3aGVuIHRoZSBzdGFjayBpcyBlbXB0eS4gKilcblxuICAgIGxldCByZWMgZW1wdHkgPSB7XG4gICAgICBzdGF0ZSA9IHM7ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBkdW1teSAqKVxuICAgICAgc2VtdiA9IFQuZXJyb3JfdmFsdWU7ICAgICAgICAgICAgICAgKCogZHVtbXkgKilcbiAgICAgIHN0YXJ0cCA9IGluaXRpYWw7ICAgICAgICAgICAgICAgICAgICgqIGR1bW15ICopXG4gICAgICBlbmRwID0gaW5pdGlhbDtcbiAgICAgIG5leHQgPSBlbXB0eTtcbiAgICB9IGluXG5cbiAgICAoKiBCdWlsZCBhbiBpbml0aWFsIGVudmlyb25tZW50LiAqKVxuXG4gICAgKCogVW5mb3J0dW5hdGVseSwgdGhlcmUgaXMgbm8gdHlwZS1zYWZlIHdheSBvZiBjb25zdHJ1Y3RpbmcgYVxuICAgICAgIGR1bW15IHRva2VuLiBUb2tlbnMgY2Fycnkgc2VtYW50aWMgdmFsdWVzLCB3aGljaCBpbiBnZW5lcmFsXG4gICAgICAgd2UgY2Fubm90IG1hbnVmYWN0dXJlLiBUaGlzIGluc3RhbmNlIG9mIFtPYmoubWFnaWNdIGNvdWxkXG4gICAgICAgYmUgYXZvaWRlZCBieSBhZG9wdGluZyBhIGRpZmZlcmVudCByZXByZXNlbnRhdGlvbiAoZS5nLiwgbm9cbiAgICAgICBbZW52LmVycm9yXSBmaWVsZCwgYW5kIGFuIG9wdGlvbiBpbiB0aGUgZmlyc3QgY29tcG9uZW50IG9mXG4gICAgICAgW2Vudi50cmlwbGVdKSwgYnV0IEkgbGlrZSB0aGlzIHJlcHJlc2VudGF0aW9uIGJldHRlci4gKilcblxuICAgIGxldCBkdW1teV90b2tlbiA9IE9iai5tYWdpYyAoKSBpblxuICAgIGxldCBlbnYgPSB7XG4gICAgICBlcnJvciA9IGZhbHNlO1xuICAgICAgdHJpcGxlID0gKGR1bW15X3Rva2VuLCBpbml0aWFsLCBpbml0aWFsKTsgKCogZHVtbXkgKilcbiAgICAgIHN0YWNrID0gZW1wdHk7XG4gICAgICBjdXJyZW50ID0gcztcbiAgICB9IGluXG5cbiAgICAoKiBCZWdpbiBwYXJzaW5nLiAqKVxuXG4gICAgKCogVGhlIHBhcmFtZXRlciBbcGxlYXNlX2Rpc2NhcmRdIGhlcmUgaXMgW3RydWVdLCB3aGljaCBtZWFucyB3ZSBrbm93XG4gICAgICAgdGhhdCB3ZSBtdXN0IHJlYWQgYXQgbGVhc3Qgb25lIHRva2VuLiBUaGlzIGNsYWltIHJlbGllcyBvbiB0aGUgZmFjdFxuICAgICAgIHRoYXQgd2UgaGF2ZSBydWxlZCBvdXQgdGhlIHR3byBzcGVjaWFsIGNhc2VzIHdoZXJlIGEgc3RhcnQgc3ltYm9sXG4gICAgICAgcmVjb2duaXplcyB0aGUgZW1wdHkgbGFuZ3VhZ2Ugb3IgdGhlIHNpbmdsZXRvbiBsYW5ndWFnZSB7ZXBzaWxvbn0uICopXG5cbiAgICBydW4gZW52IHRydWVcblxuICAoKiBbb2ZmZXIgY2hlY2twb2ludCB0cmlwbGVdIGlzIGludm9rZWQgYnkgdGhlIHVzZXIgaW4gcmVzcG9uc2UgdG8gYVxuICAgICBjaGVja3BvaW50IG9mIHRoZSBmb3JtIFtJbnB1dE5lZWRlZCBlbnZdLiBJdCBjaGVja3MgdGhhdCBbY2hlY2twb2ludF0gaXNcbiAgICAgaW5kZWVkIG9mIHRoaXMgZm9ybSwgYW5kIGludm9rZXMgW2Rpc2NhcmRdLiAqKVxuXG4gICgqIFtyZXN1bWUgY2hlY2twb2ludF0gaXMgaW52b2tlZCBieSB0aGUgdXNlciBpbiByZXNwb25zZSB0byBhIGNoZWNrcG9pbnRcbiAgICAgb2YgdGhlIGZvcm0gW1NoaWZ0aW5nIF9dLCBbQWJvdXRUb1JlZHVjZSBfXSwgb3IgW0hhbmRsaW5nRXJyb3IgZW52XS4gSXRcbiAgICAgY2hlY2tzIHRoYXQgW2NoZWNrcG9pbnRdIGlzIGluZGVlZCBvZiB0aGlzIGZvcm0sIGFuZCBpbnZva2VzIFtyZWR1Y2VdXG4gICAgIG9yIFtlcnJvcl0sIGFzIGFwcHJvcHJpYXRlLiAqKVxuXG4gICgqIEluIHJlYWxpdHksIFtvZmZlcl0gYW5kIFtyZXN1bWVdIGFjY2VwdCBhbiBhcmd1bWVudCBvZiB0eXBlXG4gICAgIFtzZW1hbnRpY192YWx1ZSBjaGVja3BvaW50XSBhbmQgcHJvZHVjZSBhIGNoZWNrcG9pbnQgb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAgVGhlIGNob2ljZSBvZiBbc2VtYW50aWNfdmFsdWVdIGlzIGZvcmNlZCBieSB0aGUgZmFjdCB0aGF0IHRoaXMgaXMgdGhlXG4gICAgIHBhcmFtZXRlciBvZiB0aGUgY2hlY2twb2ludCBbQWNjZXB0ZWRdLiAqKVxuXG4gICgqIFdlIGNoYW5nZSB0aGlzIGFzIGZvbGxvd3MuICopXG5cbiAgKCogV2UgY2hhbmdlIHRoZSBhcmd1bWVudCBhbmQgcmVzdWx0IHR5cGUgb2YgW29mZmVyXSBhbmQgW3Jlc3VtZV0gZnJvbVxuICAgICBbc2VtYW50aWNfdmFsdWUgY2hlY2twb2ludF0gdG8gWydhIGNoZWNrcG9pbnRdLiBUaGlzIGlzIHNhZmUsIGluIHRoaXNcbiAgICAgY2FzZSwgYmVjYXVzZSB3ZSBnaXZlIHRoZSB1c2VyIGFjY2VzcyB0byB2YWx1ZXMgb2YgdHlwZSBbdCBjaGVja3BvaW50XVxuICAgICBvbmx5IGlmIFt0XSBpcyBpbmRlZWQgdGhlIHR5cGUgb2YgdGhlIGV2ZW50dWFsIHNlbWFudGljIHZhbHVlIGZvciB0aGlzXG4gICAgIHJ1bi4gKE1vcmUgcHJlY2lzZWx5LCBieSBleGFtaW5pbmcgdGhlIHNpZ25hdHVyZXMgW0lOQ1JFTUVOVEFMX0VOR0lORV1cbiAgICAgYW5kIFtJTkNSRU1FTlRBTF9FTkdJTkVfU1RBUlRdLCBvbmUgZmluZHMgdGhhdCB0aGUgdXNlciBjYW4gYnVpbGQgYSB2YWx1ZVxuICAgICBvZiB0eXBlIFsnYSBjaGVja3BvaW50XSBvbmx5IGlmIFsnYV0gaXMgW3NlbWFudGljX3ZhbHVlXS4gVGhlIHRhYmxlXG4gICAgIGJhY2stZW5kIGdvZXMgZnVydGhlciB0aGFuIHRoaXMgYW5kIHByb2R1Y2VzIHZlcnNpb25zIG9mIFtzdGFydF0gY29tcG9zZWRcbiAgICAgd2l0aCBhIHN1aXRhYmxlIGNhc3QsIHdoaWNoIGdpdmUgdGhlIHVzZXIgYWNjZXNzIHRvIGEgdmFsdWUgb2YgdHlwZVxuICAgICBbdCBjaGVja3BvaW50XSB3aGVyZSBbdF0gaXMgdGhlIHR5cGUgb2YgdGhlIHN0YXJ0IHN5bWJvbC4pICopXG5cbiAgbGV0IG9mZmVyIDogJ2EgLiAnYSBjaGVja3BvaW50IC0+XG4gICAgICAgICAgICAgICAgICAgdG9rZW4gKiBwb3NpdGlvbiAqIHBvc2l0aW9uIC0+XG4gICAgICAgICAgICAgICAgICAgJ2EgY2hlY2twb2ludFxuICA9IGZ1bmN0aW9uXG4gICAgfCBJbnB1dE5lZWRlZCBlbnYgLT5cbiAgICAgICAgT2JqLm1hZ2ljIGRpc2NhcmQgZW52XG4gICAgfCBfIC0+XG4gICAgICAgIGludmFsaWRfYXJnIFwib2ZmZXIgZXhwZWN0cyBJbnB1dE5lZWRlZFwiXG5cbiAgbGV0IHJlc3VtZSA6ICdhIC4gP3N0cmF0ZWd5OnN0cmF0ZWd5IC0+ICdhIGNoZWNrcG9pbnQgLT4gJ2EgY2hlY2twb2ludCA9XG4gIGZ1biA/KHN0cmF0ZWd5PWBMZWdhY3kpIGNoZWNrcG9pbnQgLT5cbiAgICBtYXRjaCBjaGVja3BvaW50IHdpdGhcbiAgICB8IEhhbmRsaW5nRXJyb3IgZW52IC0+XG4gICAgICAgIE9iai5tYWdpYyBlcnJvciB+c3RyYXRlZ3kgZW52XG4gICAgfCBTaGlmdGluZyAoXywgZW52LCBwbGVhc2VfZGlzY2FyZCkgLT5cbiAgICAgICAgT2JqLm1hZ2ljIHJ1biBlbnYgcGxlYXNlX2Rpc2NhcmRcbiAgICB8IEFib3V0VG9SZWR1Y2UgKGVudiwgcHJvZCkgLT5cbiAgICAgICAgT2JqLm1hZ2ljIHJlZHVjZSBlbnYgcHJvZFxuICAgIHwgXyAtPlxuICAgICAgICBpbnZhbGlkX2FyZyBcInJlc3VtZSBleHBlY3RzIEhhbmRsaW5nRXJyb3IgfCBTaGlmdGluZyB8IEFib3V0VG9SZWR1Y2VcIlxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuICAoKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuICAoKiBUaGUgdHJhZGl0aW9uYWwgaW50ZXJmYWNlLiBTZWUgW0VuZ2luZVR5cGVzXS4gKilcblxuICAoKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuICAoKiBXcmFwcGluZyBhIGxleGVyIGFuZCBsZXhidWYgYXMgYSB0b2tlbiBzdXBwbGllci4gKilcblxuICB0eXBlIHN1cHBsaWVyID1cbiAgICB1bml0IC0+IHRva2VuICogcG9zaXRpb24gKiBwb3NpdGlvblxuXG4gIGxldCBsZXhlcl9sZXhidWZfdG9fc3VwcGxpZXJcbiAgICAgIChsZXhlciA6IExleGluZy5sZXhidWYgLT4gdG9rZW4pXG4gICAgICAobGV4YnVmIDogTGV4aW5nLmxleGJ1ZilcbiAgOiBzdXBwbGllciA9XG4gICAgZnVuICgpIC0+XG4gICAgICBsZXQgdG9rZW4gPSBsZXhlciBsZXhidWYgaW5cbiAgICAgIGxldCBzdGFydHAgPSBsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wXG4gICAgICBhbmQgZW5kcCA9IGxleGJ1Zi5MZXhpbmcubGV4X2N1cnJfcCBpblxuICAgICAgdG9rZW4sIHN0YXJ0cCwgZW5kcFxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4gICgqIFRoZSBtYWluIGxvb3AgcmVwZWF0ZWRseSBoYW5kbGVzIGludGVybWVkaWF0ZSBjaGVja3BvaW50cywgdW50aWwgYSBmaW5hbFxuICAgICBjaGVja3BvaW50IGlzIG9idGFpbmVkLiBUaGlzIGFsbG93cyBpbXBsZW1lbnRpbmcgdGhlIG1vbm9saXRoaWMgaW50ZXJmYWNlXG4gICAgIChbZW50cnldKSBpbiB0ZXJtcyBvZiB0aGUgaW5jcmVtZW50YWwgaW50ZXJmYWNlIChbc3RhcnRdLCBbb2ZmZXJdLFxuICAgICBbaGFuZGxlXSwgW3JlZHVjZV0pLiAqKVxuXG4gICgqIEJ5IGNvbnZlbnRpb24sIGFjY2VwdGFuY2UgaXMgcmVwb3J0ZWQgYnkgcmV0dXJuaW5nIGEgc2VtYW50aWMgdmFsdWUsXG4gICAgIHdoZXJlYXMgcmVqZWN0aW9uIGlzIHJlcG9ydGVkIGJ5IHJhaXNpbmcgW0Vycm9yXS4gKilcblxuICAoKiBbbG9vcF0gaXMgcG9seW1vcnBoaWMgaW4gWydhXS4gTm8gY2hlYXRpbmcgaXMgaW52b2x2ZWQgaW4gYWNoaWV2aW5nIHRoaXMuXG4gICAgIEFsbCBvZiB0aGUgY2hlYXRpbmcgcmVzaWRlcyBpbiB0aGUgdHlwZXMgYXNzaWduZWQgdG8gW29mZmVyXSBhbmQgW2hhbmRsZV1cbiAgICAgYWJvdmUuICopXG5cbiAgbGV0IHJlYyBsb29wIDogJ2EgLiA/c3RyYXRlZ3k6c3RyYXRlZ3kgLT4gc3VwcGxpZXIgLT4gJ2EgY2hlY2twb2ludCAtPiAnYSA9XG4gICAgZnVuID8oc3RyYXRlZ3k9YExlZ2FjeSkgcmVhZCBjaGVja3BvaW50IC0+XG4gICAgbWF0Y2ggY2hlY2twb2ludCB3aXRoXG4gICAgfCBJbnB1dE5lZWRlZCBfIC0+XG4gICAgICAgICgqIFRoZSBwYXJzZXIgbmVlZHMgYSB0b2tlbi4gUmVxdWVzdCBvbmUgZnJvbSB0aGUgbGV4ZXIsXG4gICAgICAgICAgIGFuZCBvZmZlciBpdCB0byB0aGUgcGFyc2VyLCB3aGljaCB3aWxsIHByb2R1Y2UgYSBuZXdcbiAgICAgICAgICAgY2hlY2twb2ludC4gVGhlbiwgcmVwZWF0LiAqKVxuICAgICAgICBsZXQgdHJpcGxlID0gcmVhZCgpIGluXG4gICAgICAgIGxldCBjaGVja3BvaW50ID0gb2ZmZXIgY2hlY2twb2ludCB0cmlwbGUgaW5cbiAgICAgICAgbG9vcCB+c3RyYXRlZ3kgcmVhZCBjaGVja3BvaW50XG4gICAgfCBTaGlmdGluZyBfXG4gICAgfCBBYm91dFRvUmVkdWNlIF9cbiAgICB8IEhhbmRsaW5nRXJyb3IgXyAtPlxuICAgICAgICAoKiBUaGUgcGFyc2VyIGhhcyBzdXNwZW5kZWQgaXRzZWxmLCBidXQgZG9lcyBub3QgbmVlZFxuICAgICAgICAgICBuZXcgaW5wdXQuIEp1c3QgcmVzdW1lIHRoZSBwYXJzZXIuIFRoZW4sIHJlcGVhdC4gKilcbiAgICAgICAgbGV0IGNoZWNrcG9pbnQgPSByZXN1bWUgfnN0cmF0ZWd5IGNoZWNrcG9pbnQgaW5cbiAgICAgICAgbG9vcCB+c3RyYXRlZ3kgcmVhZCBjaGVja3BvaW50XG4gICAgfCBBY2NlcHRlZCB2IC0+XG4gICAgICAgICgqIFRoZSBwYXJzZXIgaGFzIHN1Y2NlZWRlZCBhbmQgcHJvZHVjZWQgYSBzZW1hbnRpYyB2YWx1ZS5cbiAgICAgICAgICAgUmV0dXJuIHRoaXMgc2VtYW50aWMgdmFsdWUgdG8gdGhlIHVzZXIuICopXG4gICAgICAgIHZcbiAgICB8IFJlamVjdGVkIC0+XG4gICAgICAgICgqIFRoZSBwYXJzZXIgcmVqZWN0cyB0aGlzIGlucHV0LiBSYWlzZSBhbiBleGNlcHRpb24uICopXG4gICAgICAgIHJhaXNlIEVycm9yXG5cbiAgbGV0IGVudHJ5IHN0cmF0ZWd5IChzIDogc3RhdGUpIGxleGVyIGxleGJ1ZiA6IHNlbWFudGljX3ZhbHVlID1cbiAgICBsZXQgaW5pdGlhbCA9IGxleGJ1Zi5MZXhpbmcubGV4X2N1cnJfcCBpblxuICAgIGxvb3AgfnN0cmF0ZWd5IChsZXhlcl9sZXhidWZfdG9fc3VwcGxpZXIgbGV4ZXIgbGV4YnVmKSAoc3RhcnQgcyBpbml0aWFsKVxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4gICgqIFtsb29wX2hhbmRsZV0gc3RvcHMgaWYgaXQgZW5jb3VudGVycyBhbiBlcnJvciwgYW5kIGF0IHRoaXMgcG9pbnQsIGludm9rZXNcbiAgICAgaXRzIGZhaWx1cmUgY29udGludWF0aW9uLCB3aXRob3V0IGxldHRpbmcgTWVuaGlyIGRvIGl0cyBvd24gdHJhZGl0aW9uYWxcbiAgICAgZXJyb3ItaGFuZGxpbmcgKHdoaWNoIGludm9sdmVzIHBvcHBpbmcgdGhlIHN0YWNrLCBldGMuKS4gKilcblxuICBsZXQgcmVjIGxvb3BfaGFuZGxlIHN1Y2NlZWQgZmFpbCByZWFkIGNoZWNrcG9pbnQgPVxuICAgIG1hdGNoIGNoZWNrcG9pbnQgd2l0aFxuICAgIHwgSW5wdXROZWVkZWQgXyAtPlxuICAgICAgICBsZXQgdHJpcGxlID0gcmVhZCgpIGluXG4gICAgICAgIGxldCBjaGVja3BvaW50ID0gb2ZmZXIgY2hlY2twb2ludCB0cmlwbGUgaW5cbiAgICAgICAgbG9vcF9oYW5kbGUgc3VjY2VlZCBmYWlsIHJlYWQgY2hlY2twb2ludFxuICAgIHwgU2hpZnRpbmcgX1xuICAgIHwgQWJvdXRUb1JlZHVjZSBfIC0+XG4gICAgICAgICgqIFdoaWNoIHN0cmF0ZWd5IGlzIHBhc3NlZCB0byBbcmVzdW1lXSBoZXJlIGlzIGlycmVsZXZhbnQsXG4gICAgICAgICAgIHNpbmNlIHRoaXMgY2hlY2twb2ludCBpcyBub3QgW0hhbmRsaW5nRXJyb3IgX10uICopXG4gICAgICAgIGxldCBjaGVja3BvaW50ID0gcmVzdW1lIGNoZWNrcG9pbnQgaW5cbiAgICAgICAgbG9vcF9oYW5kbGUgc3VjY2VlZCBmYWlsIHJlYWQgY2hlY2twb2ludFxuICAgIHwgSGFuZGxpbmdFcnJvciBfXG4gICAgfCBSZWplY3RlZCAtPlxuICAgICAgICAoKiBUaGUgcGFyc2VyIGhhcyBkZXRlY3RlZCBhbiBlcnJvci4gSW52b2tlIHRoZSBmYWlsdXJlIGNvbnRpbnVhdGlvbi4gKilcbiAgICAgICAgZmFpbCBjaGVja3BvaW50XG4gICAgfCBBY2NlcHRlZCB2IC0+XG4gICAgICAgICgqIFRoZSBwYXJzZXIgaGFzIHN1Y2NlZWRlZCBhbmQgcHJvZHVjZWQgYSBzZW1hbnRpYyB2YWx1ZS4gSW52b2tlIHRoZVxuICAgICAgICAgICBzdWNjZXNzIGNvbnRpbnVhdGlvbi4gKilcbiAgICAgICAgc3VjY2VlZCB2XG5cbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbiAgKCogW2xvb3BfaGFuZGxlX3VuZG9dIGlzIGFuYWxvZ291cyB0byBbbG9vcF9oYW5kbGVdLCBleGNlcHQgaXQgcGFzc2VzIGEgcGFpclxuICAgICBvZiBjaGVja3BvaW50cyB0byB0aGUgZmFpbHVyZSBjb250aW51YXRpb24uXG5cbiAgICAgVGhlIGZpcnN0IChhbmQgb2xkZXN0KSBjaGVja3BvaW50IGlzIHRoZSBsYXN0IFtJbnB1dE5lZWRlZF0gY2hlY2twb2ludFxuICAgICB0aGF0IHdhcyBlbmNvdW50ZXJlZCBiZWZvcmUgdGhlIGVycm9yIHdhcyBkZXRlY3RlZC4gVGhlIHNlY29uZCAoYW5kXG4gICAgIG5ld2VzdCkgY2hlY2twb2ludCBpcyB3aGVyZSB0aGUgZXJyb3Igd2FzIGRldGVjdGVkLCBhcyBpbiBbbG9vcF9oYW5kbGVdLlxuICAgICBHb2luZyBiYWNrIHRvIHRoZSBmaXJzdCBjaGVja3BvaW50IGNhbiBiZSB0aG91Z2h0IG9mIGFzIHVuZG9pbmcgYW55XG4gICAgIHJlZHVjdGlvbnMgdGhhdCB3ZXJlIHBlcmZvcm1lZCBhZnRlciBzZWVpbmcgdGhlIHByb2JsZW1hdGljIHRva2VuLiAoVGhlc2VcbiAgICAgcmVkdWN0aW9ucyBtdXN0IGJlIGRlZmF1bHQgcmVkdWN0aW9ucyBvciBzcHVyaW91cyByZWR1Y3Rpb25zLikgKilcblxuICBsZXQgcmVjIGxvb3BfaGFuZGxlX3VuZG8gc3VjY2VlZCBmYWlsIHJlYWQgKGlucHV0bmVlZGVkLCBjaGVja3BvaW50KSA9XG4gICAgbWF0Y2ggY2hlY2twb2ludCB3aXRoXG4gICAgfCBJbnB1dE5lZWRlZCBfIC0+XG4gICAgICAgICgqIFVwZGF0ZSB0aGUgbGFzdCByZWNvcmRlZCBbSW5wdXROZWVkZWRdIGNoZWNrcG9pbnQuICopXG4gICAgICAgIGxldCBpbnB1dG5lZWRlZCA9IGNoZWNrcG9pbnQgaW5cbiAgICAgICAgbGV0IHRyaXBsZSA9IHJlYWQoKSBpblxuICAgICAgICBsZXQgY2hlY2twb2ludCA9IG9mZmVyIGNoZWNrcG9pbnQgdHJpcGxlIGluXG4gICAgICAgIGxvb3BfaGFuZGxlX3VuZG8gc3VjY2VlZCBmYWlsIHJlYWQgKGlucHV0bmVlZGVkLCBjaGVja3BvaW50KVxuICAgIHwgU2hpZnRpbmcgX1xuICAgIHwgQWJvdXRUb1JlZHVjZSBfIC0+XG4gICAgICAgICgqIFdoaWNoIHN0cmF0ZWd5IGlzIHBhc3NlZCB0byBbcmVzdW1lXSBoZXJlIGlzIGlycmVsZXZhbnQsXG4gICAgICAgICAgIHNpbmNlIHRoaXMgY2hlY2twb2ludCBpcyBub3QgW0hhbmRsaW5nRXJyb3IgX10uICopXG4gICAgICAgIGxldCBjaGVja3BvaW50ID0gcmVzdW1lIGNoZWNrcG9pbnQgaW5cbiAgICAgICAgbG9vcF9oYW5kbGVfdW5kbyBzdWNjZWVkIGZhaWwgcmVhZCAoaW5wdXRuZWVkZWQsIGNoZWNrcG9pbnQpXG4gICAgfCBIYW5kbGluZ0Vycm9yIF9cbiAgICB8IFJlamVjdGVkIC0+XG4gICAgICAgIGZhaWwgaW5wdXRuZWVkZWQgY2hlY2twb2ludFxuICAgIHwgQWNjZXB0ZWQgdiAtPlxuICAgICAgICBzdWNjZWVkIHZcblxuICAoKiBGb3Igc2ltcGxpY2l0eSwgd2UgcHVibGlzaCBhIHZlcnNpb24gb2YgW2xvb3BfaGFuZGxlX3VuZG9dIHRoYXQgdGFrZXMgYVxuICAgICBzaW5nbGUgY2hlY2twb2ludCBhcyBhbiBhcmd1bWVudCwgaW5zdGVhZCBvZiBhIHBhaXIgb2YgY2hlY2twb2ludHMuIFdlXG4gICAgIGNoZWNrIHRoYXQgdGhlIGFyZ3VtZW50IGlzIFtJbnB1dE5lZWRlZCBfXSwgYW5kIGR1cGxpY2F0ZSBpdC4gKilcblxuICAoKiBUaGUgcGFyc2VyIGNhbm5vdCBhY2NlcHQgb3IgcmVqZWN0IGJlZm9yZSBpdCBhc2tzIGZvciB0aGUgdmVyeSBmaXJzdFxuICAgICBjaGFyYWN0ZXIgb2YgaW5wdXQuIChJbmRlZWQsIHdlIHN0YXRpY2FsbHkgcmVqZWN0IGEgc3ltYm9sIHRoYXRcbiAgICAgZ2VuZXJhdGVzIHRoZSBlbXB0eSBsYW5ndWFnZSBvciB0aGUgc2luZ2xldG9uIGxhbmd1YWdlIHtlcHNpbG9ufS4pXG4gICAgIFNvLCB0aGUgW3N0YXJ0XSBjaGVja3BvaW50IG11c3QgbWF0Y2ggW0lucHV0TmVlZGVkIF9dLiBIZW5jZSwgaXQgaXNcbiAgICAgcGVybWl0dGVkIHRvIGNhbGwgW2xvb3BfaGFuZGxlX3VuZG9dIHdpdGggYSBbc3RhcnRdIGNoZWNrcG9pbnQuICopXG5cbiAgbGV0IGxvb3BfaGFuZGxlX3VuZG8gc3VjY2VlZCBmYWlsIHJlYWQgY2hlY2twb2ludCA9XG4gICAgYXNzZXJ0IChtYXRjaCBjaGVja3BvaW50IHdpdGggSW5wdXROZWVkZWQgXyAtPiB0cnVlIHwgXyAtPiBmYWxzZSk7XG4gICAgbG9vcF9oYW5kbGVfdW5kbyBzdWNjZWVkIGZhaWwgcmVhZCAoY2hlY2twb2ludCwgY2hlY2twb2ludClcblxuICAoKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuICBsZXQgcmVjIHNoaWZ0cyBjaGVja3BvaW50ID1cbiAgICBtYXRjaCBjaGVja3BvaW50IHdpdGhcbiAgICB8IFNoaWZ0aW5nIChlbnYsIF8sIF8pIC0+XG4gICAgICAgICgqIFRoZSBwYXJzZXIgaXMgYWJvdXQgdG8gc2hpZnQsIHdoaWNoIG1lYW5zIGl0IGlzIHdpbGxpbmcgdG9cbiAgICAgICAgICAgY29uc3VtZSB0aGUgdGVybWluYWwgc3ltYm9sIHRoYXQgd2UgaGF2ZSBmZWQgaXQuIFJldHVybiB0aGVcbiAgICAgICAgICAgc3RhdGUganVzdCBiZWZvcmUgdGhpcyB0cmFuc2l0aW9uLiAqKVxuICAgICAgICBTb21lIGVudlxuICAgIHwgQWJvdXRUb1JlZHVjZSBfIC0+XG4gICAgICAgICgqIFRoZSBwYXJzZXIgd2lzaGVzIHRvIHJlZHVjZS4gSnVzdCBmb2xsb3cuICopXG4gICAgICAgICgqIFdoaWNoIHN0cmF0ZWd5IGlzIHBhc3NlZCB0byBbcmVzdW1lXSBoZXJlIGlzIGlycmVsZXZhbnQsXG4gICAgICAgICAgIHNpbmNlIHRoaXMgY2hlY2twb2ludCBpcyBub3QgW0hhbmRsaW5nRXJyb3IgX10uICopXG4gICAgICAgIHNoaWZ0cyAocmVzdW1lIGNoZWNrcG9pbnQpXG4gICAgfCBIYW5kbGluZ0Vycm9yIF8gLT5cbiAgICAgICAgKCogVGhlIHBhcnNlciBmYWlscywgd2hpY2ggbWVhbnMgaXQgcmVqZWN0cyB0aGUgdGVybWluYWwgc3ltYm9sXG4gICAgICAgICAgIHRoYXQgd2UgaGF2ZSBmZWQgaXQuICopXG4gICAgICAgIE5vbmVcbiAgICB8IElucHV0TmVlZGVkIF9cbiAgICB8IEFjY2VwdGVkIF9cbiAgICB8IFJlamVjdGVkIC0+XG4gICAgICAgICgqIE5vbmUgb2YgdGhlc2UgY2FzZXMgY2FuIGFyaXNlLiBJbmRlZWQsIGFmdGVyIGEgdG9rZW4gaXMgc3VibWl0dGVkXG4gICAgICAgICAgIHRvIGl0LCB0aGUgcGFyc2VyIG11c3Qgc2hpZnQsIHJlZHVjZSwgb3Igc2lnbmFsIGFuIGVycm9yLCBiZWZvcmVcbiAgICAgICAgICAgaXQgY2FuIHJlcXVlc3QgYW5vdGhlciB0b2tlbiBvciB0ZXJtaW5hdGUuICopXG4gICAgICAgIGFzc2VydCBmYWxzZVxuXG4gIGxldCBhY2NlcHRhYmxlIGNoZWNrcG9pbnQgdG9rZW4gcG9zID1cbiAgICBsZXQgdHJpcGxlID0gKHRva2VuLCBwb3MsIHBvcykgaW5cbiAgICBsZXQgY2hlY2twb2ludCA9IG9mZmVyIGNoZWNrcG9pbnQgdHJpcGxlIGluXG4gICAgbWF0Y2ggc2hpZnRzIGNoZWNrcG9pbnQgd2l0aFxuICAgIHwgTm9uZSAgICAgIC0+IGZhbHNlXG4gICAgfCBTb21lIF9lbnYgLT4gdHJ1ZVxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4gICgqIFRoZSB0eXBlIFsnYSBscjFzdGF0ZV0gZGVzY3JpYmVzIHRoZSAobm9uLWluaXRpYWwpIHN0YXRlcyBvZiB0aGUgTFIoMSlcbiAgICAgYXV0b21hdG9uLiBUaGUgaW5kZXggWydhXSByZXByZXNlbnRzIHRoZSB0eXBlIG9mIHRoZSBzZW1hbnRpYyB2YWx1ZVxuICAgICBhc3NvY2lhdGVkIHdpdGggdGhlIHN0YXRlJ3MgaW5jb21pbmcgc3ltYm9sLiAqKVxuXG4gICgqIFRoZSB0eXBlIFsnYSBscjFzdGF0ZV0gaXMgZGVmaW5lZCBhcyBhbiBhbGlhcyBmb3IgW3N0YXRlXSwgd2hpY2ggaXRzZWxmXG4gICAgIGlzIHVzdWFsbHkgZGVmaW5lZCBhcyBbaW50XSAoc2VlIFtUYWJsZUludGVycHJldGVyXSkuIFNvLCBbJ2EgbHIxc3RhdGVdXG4gICAgIGlzIHRlY2huaWNhbGx5IGEgcGhhbnRvbSB0eXBlLCBidXQgc2hvdWxkIHJlYWxseSBiZSB0aG91Z2h0IG9mIGFzIGEgR0FEVFxuICAgICB3aG9zZSBkYXRhIGNvbnN0cnVjdG9ycyBoYXBwZW4gdG8gYmUgcmVwcmVzZW50ZWQgYXMgaW50ZWdlcnMuIEl0IGlzXG4gICAgIHByZXNlbnRlZCB0byB0aGUgdXNlciBhcyBhbiBhYnN0cmFjdCB0eXBlIChzZWUgW0luY3JlbWVudGFsRW5naW5lXSkuICopXG5cbiAgdHlwZSAnYSBscjFzdGF0ZSA9XG4gICAgICBzdGF0ZVxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4gICgqIFN0YWNrIGluc3BlY3Rpb24uICopXG5cbiAgKCogV2Ugb2ZmZXIgYSByZWFkLW9ubHkgdmlldyBvZiB0aGUgcGFyc2VyJ3Mgc3RhdGUgYXMgYSBzdHJlYW0gb2YgZWxlbWVudHMuXG4gICAgIEVhY2ggZWxlbWVudCBjb250YWlucyBhIHBhaXIgb2YgYSAobm9uLWluaXRpYWwpIHN0YXRlIGFuZCBhIHNlbWFudGljXG4gICAgIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCAodGhlIGluY29taW5nIHN5bWJvbCBvZikgdGhpcyBzdGF0ZS4gTm90ZSB0aGF0IHRoZVxuICAgICB0eXBlIFtlbGVtZW50XSBpcyBhbiBleGlzdGVudGlhbCB0eXBlLiAqKVxuXG4gICgqIEFzIG9mIDIwMTcvMDMvMzEsIHRoZSB0eXBlIFtzdGFja10gYW5kIHRoZSBmdW5jdGlvbiBbc3RhY2tdIGFyZSBERVBSRUNBVEVELlxuICAgICBJZiBkZXNpcmVkLCB0aGV5IGNvdWxkIG5vdyBiZSBpbXBsZW1lbnRlZCBvdXRzaWRlIE1lbmhpciwgYnkgcmVseWluZyBvblxuICAgICB0aGUgZnVuY3Rpb25zIFt0b3BdIGFuZCBbcG9wXS4gKilcblxuICB0eXBlIGVsZW1lbnQgPVxuICAgIHwgRWxlbWVudDogJ2EgbHIxc3RhdGUgKiAnYSAqIHBvc2l0aW9uICogcG9zaXRpb24gLT4gZWxlbWVudFxuXG4gIG9wZW4gR2VuZXJhbFxuXG4gIHR5cGUgc3RhY2sgPVxuICAgIGVsZW1lbnQgc3RyZWFtXG5cbiAgKCogSWYgW2N1cnJlbnRdIGlzIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBbY2VsbF0gaXMgdGhlIHRvcCBzdGFjayBjZWxsLFxuICAgICB0aGVuIFtzdGFjayBjZWxsIGN1cnJlbnRdIGlzIGEgdmlldyBvZiB0aGUgcGFyc2VyJ3Mgc3RhdGUgYXMgYSBzdHJlYW1cbiAgICAgb2YgZWxlbWVudHMuICopXG5cbiAgbGV0IHJlYyBzdGFjayBjZWxsIGN1cnJlbnQgOiBlbGVtZW50IHN0cmVhbSA9XG4gICAgbGF6eSAoXG4gICAgICAoKiBUaGUgc3RhY2sgaXMgZW1wdHkgaWZmIHRoZSB0b3Agc3RhY2sgY2VsbCBpcyBpdHMgb3duIHN1Y2Nlc3Nvci4gSW5cbiAgICAgICAgIHRoYXQgY2FzZSwgdGhlIGN1cnJlbnQgc3RhdGUgW2N1cnJlbnRdIHNob3VsZCBiZSBhbiBpbml0aWFsIHN0YXRlXG4gICAgICAgICAod2hpY2ggaGFzIG5vIGluY29taW5nIHN5bWJvbCkuXG4gICAgICAgICBXZSBkbyBub3QgYWxsb3cgdGhlIHVzZXIgdG8gaW5zcGVjdCB0aGlzIHN0YXRlLiAqKVxuICAgICAgbGV0IG5leHQgPSBjZWxsLm5leHQgaW5cbiAgICAgIGlmIG5leHQgPT0gY2VsbCB0aGVuXG4gICAgICAgIE5pbFxuICAgICAgZWxzZVxuICAgICAgICAoKiBDb25zdHJ1Y3QgYW4gZWxlbWVudCBjb250YWluaW5nIHRoZSBjdXJyZW50IHN0YXRlIFtjdXJyZW50XSBhcyB3ZWxsXG4gICAgICAgICAgIGFzIHRoZSBzZW1hbnRpYyB2YWx1ZSBjb250YWluZWQgaW4gdGhlIHRvcCBzdGFjayBjZWxsLiBUaGlzIHNlbWFudGljXG4gICAgICAgICAgIHZhbHVlIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgaW5jb21pbmcgc3ltYm9sIG9mIHRoaXMgc3RhdGUsIHNvIGl0XG4gICAgICAgICAgIG1ha2VzIHNlbnNlIHRvIHBhaXIgdGhlbSB0b2dldGhlci4gVGhlIHN0YXRlIGhhcyB0eXBlIFsnYSBzdGF0ZV0gYW5kXG4gICAgICAgICAgIHRoZSBzZW1hbnRpYyB2YWx1ZSBoYXMgdHlwZSBbJ2FdLCBmb3Igc29tZSB0eXBlIFsnYV0uIEhlcmUsIHRoZSBPQ2FtbFxuICAgICAgICAgICB0eXBlLWNoZWNrZXIgdGhpbmtzIFsnYV0gaXMgW3NlbWFudGljX3ZhbHVlXSBhbmQgY29uc2lkZXJzIHRoaXMgY29kZVxuICAgICAgICAgICB3ZWxsLXR5cGVkLiBPdXRzaWRlLCB3ZSB3aWxsIHVzZSBtYWdpYyB0byBwcm92aWRlIHRoZSB1c2VyIHdpdGggYSB3YXlcbiAgICAgICAgICAgb2YgaW5zcGVjdGluZyBzdGF0ZXMgYW5kIHJlY292ZXJpbmcgdGhlIHZhbHVlIG9mIFsnYV0uICopXG4gICAgICAgIGxldCBlbGVtZW50ID0gRWxlbWVudCAoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBjZWxsLnNlbXYsXG4gICAgICAgICAgY2VsbC5zdGFydHAsXG4gICAgICAgICAgY2VsbC5lbmRwXG4gICAgICAgICkgaW5cbiAgICAgICAgQ29ucyAoZWxlbWVudCwgc3RhY2sgbmV4dCBjZWxsLnN0YXRlKVxuICAgIClcblxuICBsZXQgc3RhY2sgZW52IDogZWxlbWVudCBzdHJlYW0gPVxuICAgIHN0YWNrIGVudi5zdGFjayBlbnYuY3VycmVudFxuXG4gICgqIEFzIGV4cGxhaW5lZCBhYm92ZSwgdGhlIGZ1bmN0aW9uIFt0b3BdIGFsbG93cyBhY2Nlc3MgdG8gdGhlIHRvcCBzdGFja1xuICAgICBlbGVtZW50IG9ubHkgaWYgdGhlIHN0YWNrIGlzIG5vbmVtcHR5LCBpLmUuLCBvbmx5IGlmIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgIGlzIG5vdCBhbiBpbml0aWFsIHN0YXRlLiAqKVxuXG4gIGxldCB0b3AgZW52IDogZWxlbWVudCBvcHRpb24gPVxuICAgIGxldCBjZWxsID0gZW52LnN0YWNrIGluXG4gICAgbGV0IG5leHQgPSBjZWxsLm5leHQgaW5cbiAgICBpZiBuZXh0ID09IGNlbGwgdGhlblxuICAgICAgTm9uZVxuICAgIGVsc2VcbiAgICAgIFNvbWUgKEVsZW1lbnQgKGVudi5jdXJyZW50LCBjZWxsLnNlbXYsIGNlbGwuc3RhcnRwLCBjZWxsLmVuZHApKVxuXG4gICgqIFtlcXVhbF0gY29tcGFyZXMgdGhlIHN0YWNrcyBmb3IgcGh5c2ljYWwgZXF1YWxpdHksIGFuZCBjb21wYXJlcyB0aGVcbiAgICAgY3VycmVudCBzdGF0ZXMgdmlhIHRoZWlyIG51bWJlcnMgKHRoaXMgc2VlbXMgY2xlYW5lciB0aGFuIHVzaW5nIE9DYW1sJ3NcbiAgICAgcG9seW1vcnBoaWMgZXF1YWxpdHkpLiAqKVxuXG4gICgqIFRoZSB0d28gZmllbGRzIHRoYXQgYXJlIG5vdCBjb21wYXJlZCBieSBbZXF1YWxdLCBuYW1lbHkgW2Vycm9yXSBhbmRcbiAgICAgW3RyaXBsZV0sIGFyZSBvdmVyd3JpdHRlbiBieSB0aGUgZnVuY3Rpb24gW2Rpc2NhcmRdLCB3aGljaCBoYW5kbGVzXG4gICAgIFtJbnB1dE5lZWRlZF0gY2hlY2twb2ludHMuIFRodXMsIGlmIFtlcXVhbCBlbnYxIGVudjJdIGhvbGRzLCB0aGVuIHRoZVxuICAgICBjaGVja3BvaW50cyBbaW5wdXRfbmVlZGVkIGVudjFdIGFuZCBbaW5wdXRfbmVlZGVkIGVudjJdIGFyZVxuICAgICBlcXVpdmFsZW50OiB0aGV5IGxlYWQgdGhlIHBhcnNlciB0byBiZWhhdmUgaW4gdGhlIHNhbWUgd2F5LiAqKVxuXG4gIGxldCBlcXVhbCBlbnYxIGVudjIgPVxuICAgIGVudjEuc3RhY2sgPT0gZW52Mi5zdGFjayAmJlxuICAgIG51bWJlciBlbnYxLmN1cnJlbnQgPSBudW1iZXIgZW52Mi5jdXJyZW50XG5cbiAgbGV0IGN1cnJlbnRfc3RhdGVfbnVtYmVyIGVudiA9XG4gICAgbnVtYmVyIGVudi5jdXJyZW50XG5cbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbiAgKCogQWNjZXNzIHRvIHRoZSBwb3NpdGlvbiBvZiB0aGUgbG9va2FoZWFkIHRva2VuLiAqKVxuXG4gIGxldCBwb3NpdGlvbnMgeyB0cmlwbGUgPSAoXywgc3RhcnRwLCBlbmRwKTsgXyB9ID1cbiAgICBzdGFydHAsIGVuZHBcblxuICAoKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuICAoKiBBY2Nlc3MgdG8gaW5mb3JtYXRpb24gYWJvdXQgZGVmYXVsdCByZWR1Y3Rpb25zLiAqKVxuXG4gICgqIFRoaXMgY2FuIGJlIGEgZnVuY3Rpb24gb2Ygc3RhdGVzLCBvciBhIGZ1bmN0aW9uIG9mIGVudmlyb25tZW50cy5cbiAgICAgV2Ugb2ZmZXIgYm90aC4gKilcblxuICAoKiBJbnN0ZWFkIG9mIGEgQm9vbGVhbiByZXN1bHQsIHdlIGNvdWxkIHJldHVybiBhIFtwcm9kdWN0aW9uIG9wdGlvbl0uXG4gICAgIEhvd2V2ZXIsIHdlIHdvdWxkIGhhdmUgdG8gZXhwbGljaXRseSB0ZXN0IHdoZXRoZXIgW3Byb2RdIGlzIGEgc3RhcnRcbiAgICAgcHJvZHVjdGlvbiwgYW5kIGluIHRoYXQgY2FzZSwgcmV0dXJuIFtOb25lXSwgSSBzdXBwb3NlLiBJbmRlZWQsIHdlXG4gICAgIGhhdmUgZGVjaWRlZCBub3QgdG8gZXhwb3NlIHRoZSBzdGFydCBwcm9kdWN0aW9ucy4gKilcblxuICBsZXQgc3RhdGVfaGFzX2RlZmF1bHRfcmVkdWN0aW9uIChzdGF0ZSA6IF8gbHIxc3RhdGUpIDogYm9vbCA9XG4gICAgVC5kZWZhdWx0X3JlZHVjdGlvbiBzdGF0ZVxuICAgICAgKGZ1biBfZW52IF9wcm9kIC0+IHRydWUpXG4gICAgICAoZnVuIF9lbnYgLT4gZmFsc2UpXG4gICAgICAoKVxuXG4gIGxldCBlbnZfaGFzX2RlZmF1bHRfcmVkdWN0aW9uIGVudiA9XG4gICAgc3RhdGVfaGFzX2RlZmF1bHRfcmVkdWN0aW9uIGVudi5jdXJyZW50XG5cbiAgKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbiAgKCogVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgd29yayBhdCB0aGUgbGV2ZWwgb2YgZW52aXJvbm1lbnRzIChhcyBvcHBvc2VkIHRvXG4gICAgIGNoZWNrcG9pbnRzKS4gVGhlIGZ1bmN0aW9uIFtwb3BdIGNhdXNlcyB0aGUgYXV0b21hdG9uIHRvIGdvIGJhY2sgaW50byB0aGVcbiAgICAgcGFzdCwgcHJldGVuZGluZyB0aGF0IHRoZSBsYXN0IGlucHV0IHN5bWJvbCBoYXMgbmV2ZXIgYmVlbiByZWFkLiBUaGVcbiAgICAgZnVuY3Rpb24gW2ZvcmNlX3JlZHVjdGlvbl0gY2F1c2VzIHRoZSBhdXRvbWF0b24gdG8gcmUtaW50ZXJwcmV0IHRoZSBwYXN0LFxuICAgICBieSByZWNvZ25pemluZyB0aGUgcmlnaHQtaGFuZCBzaWRlIG9mIGEgcHJvZHVjdGlvbiBhbmQgcmVkdWNpbmcgdGhpc1xuICAgICBwcm9kdWN0aW9uLiBUaGUgZnVuY3Rpb24gW2ZlZWRdIGNhdXNlcyB0aGUgYXV0b21hdG9uIHRvIHByb2dyZXNzIGludG8gdGhlXG4gICAgIGZ1dHVyZSBieSBwcmV0ZW5kaW5nIHRoYXQgYSAodGVybWluYWwgb3Igbm9udGVybWluYWwpIHN5bWJvbCBoYXMgYmVlblxuICAgICByZWFkLiAqKVxuXG4gICgqIFRoZSBmdW5jdGlvbiBbZmVlZF0gd291bGQgaWRlYWxseSBiZSBkZWZpbmVkIGhlcmUuIEhvd2V2ZXIsIGZvciB0aGlzXG4gICAgIGZ1bmN0aW9uIHRvIGJlIHR5cGUtc2FmZSwgdGhlIEdBRFQgWydhIHN5bWJvbF0gaXMgbmVlZGVkLiBGb3IgdGhpc1xuICAgICByZWFzb24sIHdlIG1vdmUgaXRzIGRlZmluaXRpb24gdG8gW0luc3BlY3Rpb25UYWJsZUludGVycHJldGVyXSwgd2hlcmVcbiAgICAgdGhlIGluc3BlY3Rpb24gQVBJIGlzIGF2YWlsYWJsZS4gKilcblxuICAoKiBbcG9wXSBwb3BzIG9uZSBzdGFjayBjZWxsLiBJdCBjYW5ub3QgZ28gd3JvbmcuICopXG5cbiAgbGV0IHBvcCAoZW52IDogJ2EgZW52KSA6ICdhIGVudiBvcHRpb24gPVxuICAgIGxldCBjZWxsID0gZW52LnN0YWNrIGluXG4gICAgbGV0IG5leHQgPSBjZWxsLm5leHQgaW5cbiAgICBpZiBuZXh0ID09IGNlbGwgdGhlblxuICAgICAgKCogVGhlIHN0YWNrIGlzIGVtcHR5LiAqKVxuICAgICAgTm9uZVxuICAgIGVsc2VcbiAgICAgICgqIFRoZSBzdGFjayBpcyBub25lbXB0eS4gUG9wIG9mZiBvbmUgY2VsbC4gKilcbiAgICAgIFNvbWUgeyBlbnYgd2l0aCBzdGFjayA9IG5leHQ7IGN1cnJlbnQgPSBjZWxsLnN0YXRlIH1cblxuICAoKiBbZm9yY2VfcmVkdWN0aW9uXSBpcyBhbmFsb2dvdXMgdG8gW3JlZHVjZV0sIGV4Y2VwdCB0aGF0IGl0IGRvZXMgbm90XG4gICAgIGNvbnRpbnVlIGJ5IGNhbGxpbmcgW3J1biBlbnZdIG9yIFtpbml0aWF0ZSBlbnZdLiBJbnN0ZWFkLCBpdCByZXR1cm5zXG4gICAgIFtlbnZdIHRvIHRoZSB1c2VyLiAqKVxuXG4gICgqIFtmb3JjZV9yZWR1Y3Rpb25dIGlzIGRhbmdlcm91cyBpbnNvZmFyIGFzIGl0IGV4ZWN1dGVzIGEgc2VtYW50aWMgYWN0aW9uLlxuICAgICBUaGlzIHNlbWFudGljIGFjdGlvbiBjb3VsZCBoYXZlIHNpZGUgZWZmZWN0czogbm9udGVybWluYXRpb24sIHN0YXRlLFxuICAgICBleGNlcHRpb25zLCBpbnB1dC9vdXRwdXQsIGV0Yy4gKilcblxuICBsZXQgZm9yY2VfcmVkdWN0aW9uIHByb2QgKGVudiA6ICdhIGVudikgOiAnYSBlbnYgPVxuICAgICgqIENoZWNrIGlmIHRoaXMgcmVkdWN0aW9uIGlzIHBlcm1pdHRlZC4gVGhpcyBjaGVjayBpcyBSRUFMTFkgaW1wb3J0YW50LlxuICAgICAgIFRoZSBzdGFjayBtdXN0IGhhdmUgdGhlIGNvcnJlY3Qgc2hhcGU6IHRoYXQgaXMsIGl0IG11c3QgYmUgc3VmZmljaWVudGx5XG4gICAgICAgaGlnaCwgYW5kIG11c3QgY29udGFpbiBzZW1hbnRpYyB2YWx1ZXMgb2YgYXBwcm9wcmlhdGUgdHlwZXMsIG90aGVyd2lzZVxuICAgICAgIHRoZSBzZW1hbnRpYyBhY3Rpb24gd2lsbCBjcmFzaCBhbmQgYnVybi4gKilcbiAgICAoKiBXZSBjdXJyZW50bHkgY2hlY2sgd2hldGhlciB0aGUgY3VycmVudCBzdGF0ZSBpcyBXSUxMSU5HIHRvIHJlZHVjZSB0aGlzXG4gICAgICAgcHJvZHVjdGlvbiAoaS5lLiwgdGhlcmUgaXMgYSByZWR1Y3Rpb24gYWN0aW9uIGluIHRoZSBhY3Rpb24gdGFibGUgcm93XG4gICAgICAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc3RhdGUpLCB3aGVyZWFzIGl0IHdvdWxkIGJlIG1vcmUgbGliZXJhbCB0byBjaGVja1xuICAgICAgIHdoZXRoZXIgdGhpcyBzdGF0ZSBpcyBDQVBBQkxFIG9mIHJlZHVjaW5nIHRoaXMgcHJvZHVjdGlvbiAoaS5lLiwgdGhlXG4gICAgICAgc3RhY2sgaGFzIGFuIGFwcHJvcHJpYXRlIHNoYXBlKS4gV2UgY3VycmVudGx5IGhhdmUgbm8gbWVhbnMgb2ZcbiAgICAgICBwZXJmb3JtaW5nIHN1Y2ggYSBjaGVjay4gKilcbiAgICBpZiBub3QgKFQubWF5X3JlZHVjZSBlbnYuY3VycmVudCBwcm9kKSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcImZvcmNlX3JlZHVjdGlvbjogdGhpcyByZWR1Y3Rpb24gaXMgbm90IHBlcm1pdHRlZCBpbiB0aGlzIHN0YXRlXCJcbiAgICBlbHNlIGJlZ2luXG4gICAgICAoKiBXZSBkbyBub3QgZXhwb3NlIHRoZSBzdGFydCBwcm9kdWN0aW9ucyB0byB0aGUgdXNlciwgc28gdGhpcyBjYW5ub3QgYmVcbiAgICAgICAgIGEgc3RhcnQgcHJvZHVjdGlvbi4gSGVuY2UsIGl0IGhhcyBhIHNlbWFudGljIGFjdGlvbi4gKilcbiAgICAgIGFzc2VydCAobm90IChULmlzX3N0YXJ0IHByb2QpKTtcbiAgICAgICgqIEludm9rZSB0aGUgc2VtYW50aWMgYWN0aW9uLiAqKVxuICAgICAgbGV0IHN0YWNrID0gVC5zZW1hbnRpY19hY3Rpb24gcHJvZCBlbnYgaW5cbiAgICAgICgqIFBlcmZvcm0gYSBnb3RvIHRyYW5zaXRpb24uICopXG4gICAgICBsZXQgY3VycmVudCA9IFQuZ290b19wcm9kIHN0YWNrLnN0YXRlIHByb2QgaW5cbiAgICAgIHsgZW52IHdpdGggc3RhY2s7IGN1cnJlbnQgfVxuICAgIGVuZFxuXG4gICgqIFRoZSBlbnZpcm9ubWVudCBtYW5pcHVsYXRpb24gZnVuY3Rpb25zIC0tIFtwb3BdIGFuZCBbZm9yY2VfcmVkdWN0aW9uXVxuICAgICBhYm92ZSwgcGx1cyBbZmVlZF0gLS0gbWFuaXB1bGF0ZSB0aGUgYXV0b21hdG9uJ3Mgc3RhY2sgYW5kIGN1cnJlbnQgc3RhdGUsXG4gICAgIGJ1dCBkbyBub3QgYWZmZWN0IHRoZSBhdXRvbWF0b24ncyBsb29rYWhlYWQgc3ltYm9sLiBXaGVuIHRoZSBmdW5jdGlvblxuICAgICBbaW5wdXRfbmVlZGVkXSBpcyB1c2VkIHRvIGdvIGJhY2sgZnJvbSBhbiBlbnZpcm9ubWVudCB0byBhIGNoZWNrcG9pbnRcbiAgICAgKGFuZCB0aGVyZWZvcmUsIHJlc3VtZSBub3JtYWwgcGFyc2luZyksIHRoZSBsb29rYWhlYWQgc3ltYm9sIGlzIGNsb2JiZXJlZFxuICAgICBhbnl3YXksIHNpbmNlIHRoZSBvbmx5IGFjdGlvbiB0aGF0IHRoZSB1c2VyIGNhbiB0YWtlIGlzIHRvIGNhbGwgW29mZmVyXS5cbiAgICAgU28gZmFyLCBzbyBnb29kLiBPbmUgcHJvYmxlbSwgdGhvdWdoLCBpcyB0aGF0IHRoaXMgY2FsbCB0byBbb2ZmZXJdIG1heVxuICAgICB3ZWxsIHBsYWNlIHRoZSBhdXRvbWF0b24gaW4gYSBjb25maWd1cmF0aW9uIG9mIGEgc3RhdGUgW3NdIGFuZCBhXG4gICAgIGxvb2thaGVhZCBzeW1ib2wgW3RdIHRoYXQgaXMgbm9ybWFsbHkgdW5yZWFjaGFibGUuIEFsc28sIHBlcmhhcHMgdGhlXG4gICAgIHN0YXRlIFtzXSBpcyBhIHN0YXRlIHdoZXJlIGFuIGlucHV0IHN5bWJvbCBub3JtYWxseSBpcyBuZXZlciBkZW1hbmRlZCwgc29cbiAgICAgdGhpcyBbSW5wdXROZWVkZWRdIGNoZWNrcG9pbnQgaXMgZmlzaHkuIFRoZXJlIGRvZXMgbm90IHNlZW0gdG8gYmUgYSBkZWVwXG4gICAgIHByb2JsZW0gaGVyZSwgYnV0LCB3aGVuIHByb2dyYW1taW5nIGFuIGVycm9yIHJlY292ZXJ5IHN0cmF0ZWd5LCBvbmVcbiAgICAgc2hvdWxkIHBheSBzb21lIGF0dGVudGlvbiB0byB0aGlzIGlzc3VlLiBJZGVhbGx5LCBwZXJoYXBzLCBvbmUgc2hvdWxkIHVzZVxuICAgICBbaW5wdXRfbmVlZGVkXSBvbmx5IGluIGEgc3RhdGUgW3NdIHdoZXJlIGFuIGlucHV0IHN5bWJvbCBpcyBub3JtYWxseVxuICAgICBkZW1hbmRlZCwgdGhhdCBpcywgYSBzdGF0ZSBbc10gd2hvc2UgaW5jb21pbmcgc3ltYm9sIGlzIGEgdGVybWluYWwgc3ltYm9sXG4gICAgIGFuZCB3aGljaCBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCByZWR1Y3Rpb24gb24gWyNdLiAqKVxuXG4gIGxldCBpbnB1dF9uZWVkZWQgKGVudiA6ICdhIGVudikgOiAnYSBjaGVja3BvaW50ID1cbiAgICBJbnB1dE5lZWRlZCBlbnZcblxuICAoKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBhcmUgY29tcG9zaXRpb25zIG9mIFt0b3BdIGFuZCBbcG9wXS4gKilcblxuICBsZXQgcmVjIHBvcF9tYW55IGkgZW52ID1cbiAgICBpZiBpID0gMCB0aGVuXG4gICAgICBTb21lIGVudlxuICAgIGVsc2UgbWF0Y2ggcG9wIGVudiB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICAgIE5vbmVcbiAgICB8IFNvbWUgZW52IC0+XG4gICAgICAgIHBvcF9tYW55IChpIC0gMSkgZW52XG5cbiAgbGV0IGdldCBpIGVudiA9XG4gICAgbWF0Y2ggcG9wX21hbnkgaSBlbnYgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgICBOb25lXG4gICAgfCBTb21lIGVudiAtPlxuICAgICAgICB0b3AgZW52XG5cbmVuZFxuZW5kXG5tb2R1bGUgRXJyb3JSZXBvcnRzID0gc3RydWN0XG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgSW5yaWEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciAgICAgKilcbigqICAgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGlicmFyeSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMiwgd2l0aCBhICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcsIGFzIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbigqIEEgdHdvLXBsYWNlIGJ1ZmZlciBzdG9yZXMgemVybywgb25lLCBvciB0d28gZWxlbWVudHMuICopXG5cbnR5cGUgJ2EgY29udGVudCA9XG58IFplcm9cbnwgT25lIG9mICdhXG58IFR3byBvZiAnYSAqICgqIG1vc3QgcmVjZW50OiAqKSAnYVxuXG50eXBlICdhIGJ1ZmZlciA9XG4gICdhIGNvbnRlbnQgcmVmXG5cbigqIFt1cGRhdGUgYnVmZmVyIHhdIHB1c2hlcyBbeF0gaW50byBbYnVmZmVyXSwgY2F1c2luZyB0aGUgYnVmZmVyIHRvIHNsaWRlLiAqKVxuXG5sZXQgdXBkYXRlIGJ1ZmZlciB4ID1cbiAgYnVmZmVyIDo9XG4gICAgbWF0Y2ggIWJ1ZmZlciwgeCB3aXRoXG4gICAgfCBaZXJvLCBfIC0+XG4gICAgICAgIE9uZSB4XG4gICAgfCBPbmUgeDEsIHgyXG4gICAgfCBUd28gKF8sIHgxKSwgeDIgLT5cbiAgICAgICAgVHdvICh4MSwgeDIpXG5cbmxldCBzaG93IGYgYnVmZmVyIDogc3RyaW5nID1cbiAgbWF0Y2ggIWJ1ZmZlciB3aXRoXG4gIHwgWmVybyAtPlxuICAgICAgKCogVGhlIGJ1ZmZlciBjYW5ub3QgYmUgZW1wdHkuIElmIHdlIGhhdmUgcmVhZCBubyB0b2tlbnMsXG4gICAgICAgICB3ZSBjYW5ub3QgaGF2ZSBkZXRlY3RlZCBhIHN5bnRheCBlcnJvci4gKilcbiAgICAgIGFzc2VydCBmYWxzZVxuICB8IE9uZSBpbnZhbGlkIC0+XG4gICAgICAoKiBJdCBpcyB1bmxpa2VseSwgYnV0IHBvc3NpYmxlLCB0aGF0IHdlIGhhdmUgcmVhZCBqdXN0IG9uZSB0b2tlbi4gKilcbiAgICAgIFByaW50Zi5zcHJpbnRmIFwiYmVmb3JlICclcydcIiAoZiBpbnZhbGlkKVxuICB8IFR3byAodmFsaWQsIGludmFsaWQpIC0+XG4gICAgICAoKiBJbiB0aGUgbW9zdCBsaWtlbHkgY2FzZSwgd2UgaGF2ZSByZWFkIHR3byB0b2tlbnMuICopXG4gICAgICBQcmludGYuc3ByaW50ZiBcImFmdGVyICclcycgYW5kIGJlZm9yZSAnJXMnXCIgKGYgdmFsaWQpIChmIGludmFsaWQpXG5cbmxldCBsYXN0IGJ1ZmZlciA9XG4gIG1hdGNoICFidWZmZXIgd2l0aFxuICB8IFplcm8gLT5cbiAgICAgICgqIFRoZSBidWZmZXIgY2Fubm90IGJlIGVtcHR5LiBJZiB3ZSBoYXZlIHJlYWQgbm8gdG9rZW5zLFxuICAgICAgICAgd2UgY2Fubm90IGhhdmUgZGV0ZWN0ZWQgYSBzeW50YXggZXJyb3IuICopXG4gICAgICBhc3NlcnQgZmFsc2VcbiAgfCBPbmUgaW52YWxpZFxuICB8IFR3byAoXywgaW52YWxpZCkgLT5cbiAgICAgIGludmFsaWRcblxub3BlbiBMZXhpbmdcblxubGV0IHdyYXAgbGV4ZXIgPVxuICBsZXQgYnVmZmVyID0gcmVmIFplcm8gaW5cbiAgYnVmZmVyLFxuICBmdW4gbGV4YnVmIC0+XG4gICAgbGV0IHRva2VuID0gbGV4ZXIgbGV4YnVmIGluXG4gICAgdXBkYXRlIGJ1ZmZlciAobGV4YnVmLmxleF9zdGFydF9wLCBsZXhidWYubGV4X2N1cnJfcCk7XG4gICAgdG9rZW5cblxubGV0IHdyYXBfc3VwcGxpZXIgc3VwcGxpZXIgPVxuICBsZXQgYnVmZmVyID0gcmVmIFplcm8gaW5cbiAgYnVmZmVyLFxuICBmdW4gKCkgLT5cbiAgICBsZXQgKF90b2tlbiwgcG9zMSwgcG9zMikgYXMgdHJpcGxlID0gc3VwcGxpZXIoKSBpblxuICAgIHVwZGF0ZSBidWZmZXIgKHBvczEsIHBvczIpO1xuICAgIHRyaXBsZVxuXG4oKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG5sZXQgZXh0cmFjdCB0ZXh0IChwb3MxLCBwb3MyKSA6IHN0cmluZyA9XG4gIGxldCBvZnMxID0gcG9zMS5wb3NfY251bVxuICBhbmQgb2ZzMiA9IHBvczIucG9zX2NudW0gaW5cbiAgbGV0IGxlbiA9IG9mczIgLSBvZnMxIGluXG4gIHRyeVxuICAgIFN0cmluZy5zdWIgdGV4dCBvZnMxIGxlblxuICB3aXRoIEludmFsaWRfYXJndW1lbnQgXyAtPlxuICAgICgqIEluIHByaW5jaXBsZSwgdGhpcyBzaG91bGQgbm90IGhhcHBlbiwgYnV0IGlmIGl0IGRvZXMsIGxldCdzIG1ha2UgdGhpc1xuICAgICAgIGEgbm9uLWZhdGFsIGVycm9yLiAqKVxuICAgIFwiPz8/XCJcblxubGV0IHNhbml0aXplIHRleHQgPVxuICBTdHJpbmcubWFwIChmdW4gYyAtPlxuICAgIGlmIENoYXIuY29kZSBjIDwgMzIgdGhlbiAnICcgZWxzZSBjXG4gICkgdGV4dFxuXG4oKiBJZiB3ZSB3ZXJlIHdpbGxpbmcgdG8gZGVwZW5kIG9uIFtTdHJdLCB3ZSBjb3VsZCBpbXBsZW1lbnQgW2NvbXByZXNzXSBhc1xuICAgZm9sbG93czpcblxuICAgbGV0IGNvbXByZXNzIHRleHQgPVxuICAgICBTdHIuZ2xvYmFsX3JlcGxhY2UgKFN0ci5yZWdleHAgXCJbIFxcdFxcblxccl0rXCIpIFwiIFwiIHRleHRcblxuICopXG5cbmxldCByZWMgY29tcHJlc3MgbiBiIGkgaiBza2lwcGluZyA9XG4gIGlmIGogPCBuIHRoZW5cbiAgICBsZXQgYywgaiA9IEJ5dGVzLmdldCBiIGosIGogKyAxIGluXG4gICAgbWF0Y2ggYyB3aXRoXG4gICAgfCAnICcgfCAnXFx0JyB8ICdcXG4nIHwgJ1xccicgLT5cbiAgICAgICAgbGV0IGkgPSBpZiBub3Qgc2tpcHBpbmcgdGhlbiAoQnl0ZXMuc2V0IGIgaSAnICc7IGkgKyAxKSBlbHNlIGkgaW5cbiAgICAgICAgbGV0IHNraXBwaW5nID0gdHJ1ZSBpblxuICAgICAgICBjb21wcmVzcyBuIGIgaSBqIHNraXBwaW5nXG4gICAgfCBfIC0+XG4gICAgICAgIGxldCBpID0gQnl0ZXMuc2V0IGIgaSBjOyBpICsgMSBpblxuICAgICAgICBsZXQgc2tpcHBpbmcgPSBmYWxzZSBpblxuICAgICAgICBjb21wcmVzcyBuIGIgaSBqIHNraXBwaW5nXG4gIGVsc2VcbiAgICBCeXRlcy5zdWJfc3RyaW5nIGIgMCBpXG5cbmxldCBjb21wcmVzcyB0ZXh0ID1cbiAgbGV0IGIgPSBCeXRlcy5vZl9zdHJpbmcgdGV4dCBpblxuICBsZXQgbiA9IEJ5dGVzLmxlbmd0aCBiIGluXG4gIGNvbXByZXNzIG4gYiAwIDAgZmFsc2VcblxubGV0IHNob3J0ZW4gayB0ZXh0ID1cbiAgbGV0IG4gPSBTdHJpbmcubGVuZ3RoIHRleHQgaW5cbiAgaWYgbiA8PSAyICogayArIDMgdGhlblxuICAgIHRleHRcbiAgZWxzZVxuICAgIFN0cmluZy5zdWIgdGV4dCAwIGsgXlxuICAgIFwiLi4uXCIgXlxuICAgIFN0cmluZy5zdWIgdGV4dCAobiAtIGspIGtcblxubGV0IGlzX2RpZ2l0IGMgPVxuICBsZXQgYyA9IENoYXIuY29kZSBjIGluXG4gIENoYXIuY29kZSAnMCcgPD0gYyAmJiBjIDw9IENoYXIuY29kZSAnOSdcblxuZXhjZXB0aW9uIENvcHlcblxubGV0IGV4cGFuZCBmIHRleHQgPVxuICBsZXQgbiA9IFN0cmluZy5sZW5ndGggdGV4dCBpblxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgbiBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA8IG4gdGhlbiBiZWdpblxuICAgICAgbGV0IGMsIGkgPSB0ZXh0LltpXSwgaSArIDEgaW5cbiAgICAgIGxvb3AgKFxuICAgICAgICB0cnlcbiAgICAgICAgICBpZiBjIDw+ICckJyB0aGVuIHJhaXNlIENvcHk7XG4gICAgICAgICAgbGV0IGogPSByZWYgaSBpblxuICAgICAgICAgIHdoaWxlICFqIDwgbiAmJiBpc19kaWdpdCB0ZXh0Llshal0gZG8gaW5jciBqIGRvbmU7XG4gICAgICAgICAgaWYgaSA9ICFqIHRoZW4gcmFpc2UgQ29weTtcbiAgICAgICAgICBsZXQgayA9IGludF9vZl9zdHJpbmcgKFN0cmluZy5zdWIgdGV4dCBpICghaiAtIGkpKSBpblxuICAgICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGIgKGYgayk7XG4gICAgICAgICAgIWpcbiAgICAgICAgd2l0aCBDb3B5IC0+XG4gICAgICAgICAgKCogV2UgcmVhY2ggdGhpcyBwb2ludCBpZiBlaXRoZXIgW2NdIGlzIG5vdCAnJCcgb3IgW2NdIGlzICckJ1xuICAgICAgICAgICAgIGJ1dCBpcyBub3QgZm9sbG93ZWQgYnkgYW4gaW50ZWdlciBsaXRlcmFsLiAqKVxuICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiIGM7XG4gICAgICAgICAgaVxuICAgICAgKVxuICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBiXG4gIGluXG4gIGxvb3AgMFxuZW5kXG5tb2R1bGUgTGV4ZXJVdGlsID0gc3RydWN0XG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgSW5yaWEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciAgICAgKilcbigqICAgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGlicmFyeSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMiwgd2l0aCBhICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcsIGFzIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gTGV4aW5nXG5vcGVuIFByaW50ZlxuXG5sZXQgaW5pdCBmaWxlbmFtZSBsZXhidWYgPVxuICBsZXhidWYubGV4X2N1cnJfcCA8LSB7XG4gICAgcG9zX2ZuYW1lID0gZmlsZW5hbWU7XG4gICAgcG9zX2xudW0gID0gMTtcbiAgICBwb3NfYm9sICAgPSAwO1xuICAgIHBvc19jbnVtICA9IDBcbiAgfTtcbiAgbGV4YnVmXG5cbmxldCByZWFkIGZpbGVuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2luIGZpbGVuYW1lIGluXG4gIGxldCB0ZXh0ID0gcmVhbGx5X2lucHV0X3N0cmluZyBjIChpbl9jaGFubmVsX2xlbmd0aCBjKSBpblxuICBjbG9zZV9pbiBjO1xuICBsZXQgbGV4YnVmID0gTGV4aW5nLmZyb21fc3RyaW5nIHRleHQgaW5cbiAgdGV4dCwgaW5pdCBmaWxlbmFtZSBsZXhidWZcblxubGV0IG5ld2xpbmUgbGV4YnVmID1cbiAgbGV0IHBvcyA9IGxleGJ1Zi5sZXhfY3Vycl9wIGluXG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtIHsgcG9zIHdpdGhcbiAgICBwb3NfbG51bSA9IHBvcy5wb3NfbG51bSArIDE7XG4gICAgcG9zX2JvbCA9IHBvcy5wb3NfY251bTtcbiAgfVxuXG5sZXQgaXNfZHVtbXkgKHBvczEsIHBvczIpID1cbiAgcG9zMSA9PSBkdW1teV9wb3MgfHwgcG9zMiA9PSBkdW1teV9wb3NcblxubGV0IHJhbmdlICgocG9zMSwgcG9zMikgYXMgcmFuZ2UpID1cbiAgaWYgaXNfZHVtbXkgcmFuZ2UgdGhlblxuICAgIHNwcmludGYgXCJBdCBhbiB1bmtub3duIGxvY2F0aW9uOlxcblwiXG4gIGVsc2VcbiAgICBsZXQgZmlsZSA9IHBvczEucG9zX2ZuYW1lIGluXG4gICAgbGV0IGxpbmUgPSBwb3MxLnBvc19sbnVtIGluXG4gICAgbGV0IGNoYXIxID0gcG9zMS5wb3NfY251bSAtIHBvczEucG9zX2JvbCBpblxuICAgIGxldCBjaGFyMiA9IHBvczIucG9zX2NudW0gLSBwb3MxLnBvc19ib2wgaW4gKCogeWVzLCBbcG9zMS5wb3NfYm9sXSAqKVxuICAgIHNwcmludGYgXCJGaWxlIFxcXCIlc1xcXCIsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWQ6XFxuXCJcbiAgICAgIGZpbGUgbGluZSBjaGFyMSBjaGFyMlxuICAgICAgKCogdXNlIFtjaGFyMSArIDFdIGFuZCBbY2hhcjIgKyAxXSBpZiAqbm90KiB1c2luZyBDYW1sIG1vZGUgKilcblxubGV0IHRhYnVsYXRlICh0eXBlIGEpIChpc19lb2YgOiBhIC0+IGJvb2wpIChsZXhlciA6IHVuaXQgLT4gYSkgOiB1bml0IC0+IGEgPVxuICAoKiBSZWFkIHRva2VucyBmcm9tIHRoZSBsZXhlciB1bnRpbCB3ZSBoaXQgYW4gRU9GIHRva2VuLiAqKVxuICBsZXQgcmVjIHJlYWQgdG9rZW5zID1cbiAgICBsZXQgdG9rZW4gPSBsZXhlcigpIGluXG4gICAgbGV0IHRva2VucyA9IHRva2VuIDo6IHRva2VucyBpblxuICAgIGlmIGlzX2VvZiB0b2tlbiB0aGVuXG4gICAgICAoKiBPbmNlIGRvbmUsIHJldmVyc2UgdGhlIGxpc3QgYW5kIGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkuICopXG4gICAgICB0b2tlbnMgfD4gTGlzdC5yZXYgfD4gQXJyYXkub2ZfbGlzdFxuICAgIGVsc2VcbiAgICAgIHJlYWQgdG9rZW5zXG4gIGluXG4gICgqIFdlIG5vdyBoYXZlIGFuIGFycmF5IG9mIHRva2Vucy4gKilcbiAgbGV0IHRva2VucyA9IHJlYWQgW10gaW5cbiAgKCogRGVmaW5lIGEgcHNldWRvLWxleGVyIHRoYXQgcmVhZHMgZnJvbSB0aGlzIGFycmF5LiAqKVxuICBsZXQgaSA9IHJlZiAwIGluXG4gIGxldCBsZXhlciAoKSA9XG4gICAgKCogSWYgdGhpcyBhc3NlcnRpb24gaXMgdmlvbGF0ZWQsIHRoZW4gdGhlIHBhcnNlciBpcyB0cnlpbmcgdG8gcmVhZFxuICAgICAgIHBhc3QgYW4gRU9GIHRva2VuLiBUaGlzIHNob3VsZCBub3QgaGFwcGVuLiAqKVxuICAgIGFzc2VydCAoIWkgPCBBcnJheS5sZW5ndGggdG9rZW5zKTtcbiAgICBsZXQgdG9rZW4gPSBBcnJheS51bnNhZmVfZ2V0IHRva2VucyAhaSBpblxuICAgIGkgOj0gIWkgKyAxO1xuICAgIHRva2VuXG4gIGluXG4gIGxleGVyXG5lbmRcbm1vZHVsZSBQcmludGVycyA9IHN0cnVjdFxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IElucmlhLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgICAgICopXG4oKiAgIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIsIHdpdGggYSAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nLCBhcyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgTWFrZVxuICAoSSA6IEluY3JlbWVudGFsRW5naW5lLkVWRVJZVEhJTkcpXG4gIChVc2VyIDogc2lnXG4gICAgdmFsIHByaW50OiBzdHJpbmcgLT4gdW5pdFxuICAgIHZhbCBwcmludF9zeW1ib2w6IEkueHN5bWJvbCAtPiB1bml0XG4gICAgdmFsIHByaW50X2VsZW1lbnQ6IChJLmVsZW1lbnQgLT4gdW5pdCkgb3B0aW9uXG4gIGVuZClcbj0gc3RydWN0XG5cbiAgbGV0IGFycm93ID0gXCIgLT4gXCJcbiAgbGV0IGRvdCA9IFwiLlwiXG4gIGxldCBzcGFjZSA9IFwiIFwiXG4gIGxldCBuZXdsaW5lID0gXCJcXG5cIlxuXG4gIG9wZW4gVXNlclxuICBvcGVuIElcblxuICAoKiBQcmludGluZyBhIGxpc3Qgb2Ygc3ltYm9scy4gQW4gb3B0aW9uYWwgZG90IGlzIHByaW50ZWQgYXQgb2Zmc2V0XG4gICAgIFtpXSBpbnRvIHRoZSBsaXN0IFtzeW1ib2xzXSwgaWYgdGhpcyBvZmZzZXQgbGllcyBiZXR3ZWVuIFswXSBhbmRcbiAgICAgdGhlIGxlbmd0aCBvZiB0aGUgbGlzdCAoaW5jbHVkZWQpLiAqKVxuXG4gIGxldCByZWMgcHJpbnRfc3ltYm9scyBpIHN5bWJvbHMgPVxuICAgIGlmIGkgPSAwIHRoZW4gYmVnaW5cbiAgICAgIHByaW50IGRvdDtcbiAgICAgIHByaW50IHNwYWNlO1xuICAgICAgcHJpbnRfc3ltYm9scyAoLTEpIHN5bWJvbHNcbiAgICBlbmRcbiAgICBlbHNlIGJlZ2luXG4gICAgICBtYXRjaCBzeW1ib2xzIHdpdGhcbiAgICAgIHwgW10gLT5cbiAgICAgICAgICAoKVxuICAgICAgfCBzeW1ib2wgOjogc3ltYm9scyAtPlxuICAgICAgICAgIHByaW50X3N5bWJvbCBzeW1ib2w7XG4gICAgICAgICAgcHJpbnQgc3BhY2U7XG4gICAgICAgICAgcHJpbnRfc3ltYm9scyAoaSAtIDEpIHN5bWJvbHNcbiAgICBlbmRcblxuICAoKiBQcmludGluZyBhbiBlbGVtZW50IGFzIGEgc3ltYm9sLiAqKVxuXG4gIGxldCBwcmludF9lbGVtZW50X2FzX3N5bWJvbCBlbGVtZW50ID1cbiAgICBtYXRjaCBlbGVtZW50IHdpdGhcbiAgICB8IEVsZW1lbnQgKHMsIF8sIF8sIF8pIC0+XG4gICAgICAgIHByaW50X3N5bWJvbCAoWCAoaW5jb21pbmdfc3ltYm9sIHMpKVxuXG4gICgqIFNvbWUgb2YgdGhlIGZ1bmN0aW9ucyB0aGF0IGZvbGxvdyBuZWVkIGFuIGVsZW1lbnQgcHJpbnRlci4gVGhleSB1c2VcbiAgICAgW3ByaW50X2VsZW1lbnRdIGlmIHByb3ZpZGVkIGJ5IHRoZSB1c2VyOyBvdGhlcndpc2UgdGhleSB1c2VcbiAgICAgW3ByaW50X2VsZW1lbnRfYXNfc3ltYm9sXS4gKilcblxuICBsZXQgcHJpbnRfZWxlbWVudCA9XG4gICAgbWF0Y2ggcHJpbnRfZWxlbWVudCB3aXRoXG4gICAgfCBTb21lIHByaW50X2VsZW1lbnQgLT5cbiAgICAgICAgcHJpbnRfZWxlbWVudFxuICAgIHwgTm9uZSAtPlxuICAgICAgICBwcmludF9lbGVtZW50X2FzX3N5bWJvbFxuXG4gICgqIFByaW50aW5nIGEgc3RhY2sgYXMgYSBsaXN0IG9mIHN5bWJvbHMuIFN0YWNrIGJvdHRvbSBvbiB0aGUgbGVmdCxcbiAgICAgc3RhY2sgdG9wIG9uIHRoZSByaWdodC4gKilcblxuICBsZXQgcmVjIHByaW50X3N0YWNrIGVudiA9XG4gICAgbWF0Y2ggdG9wIGVudiwgcG9wIGVudiB3aXRoXG4gICAgfCBTb21lIGVsZW1lbnQsIFNvbWUgZW52IC0+XG4gICAgICAgIHByaW50X3N0YWNrIGVudjtcbiAgICAgICAgcHJpbnQgc3BhY2U7XG4gICAgICAgIHByaW50X2VsZW1lbnQgZWxlbWVudFxuICAgIHwgXywgXyAtPlxuICAgICAgICAoKVxuXG4gIGxldCBwcmludF9zdGFjayBlbnYgPVxuICAgIHByaW50X3N0YWNrIGVudjtcbiAgICBwcmludCBuZXdsaW5lXG5cbiAgKCogUHJpbnRpbmcgYW4gaXRlbS4gKilcblxuICBsZXQgcHJpbnRfaXRlbSAocHJvZCwgaSkgPVxuICAgIHByaW50X3N5bWJvbCAobGhzIHByb2QpO1xuICAgIHByaW50IGFycm93O1xuICAgIHByaW50X3N5bWJvbHMgaSAocmhzIHByb2QpO1xuICAgIHByaW50IG5ld2xpbmVcblxuICAoKiBQcmludGluZyBhIGxpc3Qgb2Ygc3ltYm9scyAocHVibGljIHZlcnNpb24pLiAqKVxuXG4gIGxldCBwcmludF9zeW1ib2xzIHN5bWJvbHMgPVxuICAgIHByaW50X3N5bWJvbHMgKC0xKSBzeW1ib2xzXG5cbiAgKCogUHJpbnRpbmcgYSBwcm9kdWN0aW9uICh3aXRob3V0IGEgZG90KS4gKilcblxuICBsZXQgcHJpbnRfcHJvZHVjdGlvbiBwcm9kID1cbiAgICBwcmludF9pdGVtIChwcm9kLCAtMSlcblxuICAoKiBQcmludGluZyB0aGUgY3VycmVudCBMUigxKSBzdGF0ZS4gKilcblxuICBsZXQgcHJpbnRfY3VycmVudF9zdGF0ZSBlbnYgPVxuICAgIHByaW50IFwiQ3VycmVudCBMUigxKSBzdGF0ZTogXCI7XG4gICAgbWF0Y2ggdG9wIGVudiB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICAgIHByaW50IFwiPHNvbWUgaW5pdGlhbCBzdGF0ZT5cIjsgKCogVEVNUE9SQVJZIHVuc2F0aXNmYWN0b3J5ICopXG4gICAgICAgIHByaW50IG5ld2xpbmVcbiAgICB8IFNvbWUgKEVsZW1lbnQgKGN1cnJlbnQsIF8sIF8sIF8pKSAtPlxuICAgICAgICBwcmludCAoc3RyaW5nX29mX2ludCAobnVtYmVyIGN1cnJlbnQpKTtcbiAgICAgICAgcHJpbnQgbmV3bGluZTtcbiAgICAgICAgTGlzdC5pdGVyIHByaW50X2l0ZW0gKGl0ZW1zIGN1cnJlbnQpXG5cbiAgbGV0IHByaW50X2VudiBlbnYgPVxuICAgIHByaW50X3N0YWNrIGVudjtcbiAgICBwcmludF9jdXJyZW50X3N0YXRlIGVudjtcbiAgICBwcmludCBuZXdsaW5lXG5cbmVuZFxuZW5kXG5tb2R1bGUgSW5maW5pdGVBcnJheSA9IHN0cnVjdFxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IElucmlhLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgICAgICopXG4oKiAgIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIsIHdpdGggYSAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nLCBhcyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiogVGhpcyBtb2R1bGUgaW1wbGVtZW50cyBpbmZpbml0ZSBhcnJheXMsIHRoYXQgaXMsIGFycmF5cyB0aGF0IGdyb3dcbiAgICB0cmFuc3BhcmVudGx5IHVwb24gZGVtYW5kLiAqKVxuXG50eXBlICdhIHQgPSB7XG4gICAgZGVmYXVsdDogJ2E7XG4gICAgbXV0YWJsZSB0YWJsZTogJ2EgYXJyYXk7XG4gICAgbXV0YWJsZSBleHRlbnQ6IGludDsgKCogdGhlIGluZGV4IG9mIHRoZSBncmVhdGVzdCBbc2V0XSBldmVyLCBwbHVzIG9uZSAqKVxuICB9XG5cbmxldCBkZWZhdWx0X3NpemUgPVxuICAxNjM4NCAoKiBtdXN0IGJlIG5vbi16ZXJvICopXG5cbmxldCBtYWtlIHggPSB7XG4gIGRlZmF1bHQgPSB4O1xuICB0YWJsZSA9IEFycmF5Lm1ha2UgZGVmYXVsdF9zaXplIHg7XG4gIGV4dGVudCA9IDA7XG59XG5cbmxldCByZWMgbmV3X2xlbmd0aCBsZW5ndGggaSA9XG4gIGlmIGkgPCBsZW5ndGggdGhlblxuICAgIGxlbmd0aFxuICBlbHNlXG4gICAgbmV3X2xlbmd0aCAoMiAqIGxlbmd0aCkgaVxuXG5sZXQgZW5zdXJlIGEgaSA9XG4gIGFzc2VydCAoMCA8PSBpKTtcbiAgbGV0IHRhYmxlID0gYS50YWJsZSBpblxuICBsZXQgbGVuZ3RoID0gQXJyYXkubGVuZ3RoIHRhYmxlIGluXG4gIGlmIGkgPj0gbGVuZ3RoIHRoZW4gYmVnaW5cbiAgICBsZXQgdGFibGUnID0gQXJyYXkubWFrZSAobmV3X2xlbmd0aCAoMiAqIGxlbmd0aCkgaSkgYS5kZWZhdWx0IGluXG4gICAgQXJyYXkuYmxpdCB0YWJsZSAwIHRhYmxlJyAwIGxlbmd0aDtcbiAgICBhLnRhYmxlIDwtIHRhYmxlJ1xuICBlbmRcblxubGV0IGdldCBhIGkgPVxuICBlbnN1cmUgYSBpO1xuICBBcnJheS51bnNhZmVfZ2V0IGEudGFibGUgKGkpXG5cbmxldCBzZXQgYSBpIHggPVxuICBlbnN1cmUgYSBpO1xuICBBcnJheS51bnNhZmVfc2V0IGEudGFibGUgKGkpIHg7XG4gIGlmIGEuZXh0ZW50IDw9IGkgdGhlblxuICAgIGEuZXh0ZW50IDwtIGkgKyAxXG5cbmxldCBleHRlbnQgYSA9XG4gIGEuZXh0ZW50XG5cbmxldCBkb21haW4gYSA9XG4gIEFycmF5LnN1YiBhLnRhYmxlIDAgYS5leHRlbnRcblxuZW5kXG5tb2R1bGUgUGFja2VkSW50QXJyYXkgPSBzdHJ1Y3RcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCBJbnJpYS4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyICAgICAqKVxuKCogICB0aGUgdGVybXMgb2YgdGhlIEdOVSBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLCB3aXRoIGEgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZywgYXMgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQSBwYWNrZWQgaW50ZWdlciBhcnJheSBpcyByZXByZXNlbnRlZCBhcyBhIHBhaXIgb2YgYW4gaW50ZWdlciBba10gYW5kXG4gICBhIHN0cmluZyBbc10uIFRoZSBpbnRlZ2VyIFtrXSBpcyB0aGUgbnVtYmVyIG9mIGJpdHMgcGVyIGludGVnZXIgdGhhdCB3ZVxuICAgdXNlLiBUaGUgc3RyaW5nIFtzXSBpcyBqdXN0IGFuIGFycmF5IG9mIGJpdHMsIHdoaWNoIGlzIHJlYWQgaW4gOC1iaXRcbiAgIGNodW5rcy4gKilcblxuKCogVGhlIG9jYW1sIHByb2dyYW1taW5nIGxhbmd1YWdlIHRyZWF0cyBzdHJpbmcgbGl0ZXJhbHMgYW5kIGFycmF5IGxpdGVyYWxzXG4gICBpbiBzbGlnaHRseSBkaWZmZXJlbnQgd2F5czogdGhlIGZvcm1lciBhcmUgc3RhdGljYWxseSBhbGxvY2F0ZWQsIHdoaWxlXG4gICB0aGUgbGF0dGVyIGFyZSBkeW5hbWljYWxseSBhbGxvY2F0ZWQuIChUaGlzIGlzIHJhdGhlciBhcmJpdHJhcnkuKSBJbiB0aGVcbiAgIGNvbnRleHQgb2YgTWVuaGlyJ3MgdGFibGUtYmFzZWQgYmFjay1lbmQsIHdoZXJlIGNvbXBhY3QsIGltbXV0YWJsZVxuICAgaW50ZWdlciBhcnJheXMgYXJlIG5lZWRlZCwgb2NhbWwgc3RyaW5ncyBhcmUgcHJlZmVyYWJsZSB0byBvY2FtbCBhcnJheXMuICopXG5cbnR5cGUgdCA9XG4gIGludCAqIHN0cmluZ1xuXG4oKiBUaGUgbWFnbml0dWRlIFtrXSBvZiBhbiBpbnRlZ2VyIFt2XSBpcyB0aGUgbnVtYmVyIG9mIGJpdHMgcmVxdWlyZWRcbiAgIHRvIHJlcHJlc2VudCBbdl0uIEl0IGlzIHJvdW5kZWQgdXAgdG8gdGhlIG5lYXJlc3QgcG93ZXIgb2YgdHdvLCBzb1xuICAgdGhhdCBba10gZGl2aWRlcyBbU3lzLndvcmRfc2l6ZV0uICopXG5cbmxldCBtYWduaXR1ZGUgKHYgOiBpbnQpID1cbiAgaWYgdiA8IDAgdGhlblxuICAgIFN5cy53b3JkX3NpemVcbiAgZWxzZVxuICAgIGxldCByZWMgY2hlY2sgayBtYXggPSAoKiBbbWF4XSBlcXVhbHMgWzJea10gKilcbiAgICAgIGlmIChtYXggPD0gMCkgfHwgKHYgPCBtYXgpIHRoZW5cbiAgICAgICAga1xuICAgICAgICAgICgqIGlmIFttYXhdIGp1c3Qgb3ZlcmZsZXcsIHRoZW4gW3ZdIHJlcXVpcmVzIGEgZnVsbCBvY2FtbFxuICAgICAgICAgICAgIGludGVnZXIsIGFuZCBba10gaXMgdGhlIG51bWJlciBvZiBiaXRzIGluIGFuIG9jYW1sIGludGVnZXJcbiAgICAgICAgICAgICBwbHVzIG9uZSwgdGhhdCBpcywgW1N5cy53b3JkX3NpemVdLiAqKVxuICAgICAgZWxzZVxuICAgICAgICBjaGVjayAoMiAqIGspIChtYXggKiBtYXgpXG4gICAgaW5cbiAgICBjaGVjayAxIDJcblxuKCogW3BhY2sgYV0gdHVybnMgYW4gYXJyYXkgb2YgaW50ZWdlcnMgaW50byBhIHBhY2tlZCBpbnRlZ2VyIGFycmF5LiAqKVxuXG4oKiBCZWNhdXNlIHRoZSBzaWduIGJpdCBpcyB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQsIHRoZSBtYWduaXR1ZGUgb2ZcbiAgIGFueSBuZWdhdGl2ZSBudW1iZXIgaXMgdGhlIHdvcmQgc2l6ZS4gSW4gb3RoZXIgd29yZHMsIFtwYWNrXSBkb2VzXG4gICBub3QgYWNoaWV2ZSBhbnkgc3BhY2Ugc2F2aW5ncyBhcyBzb29uIGFzIFthXSBjb250YWlucyBhbnkgbmVnYXRpdmVcbiAgIG51bWJlcnMsIGV2ZW4gaWYgdGhleSBhcmUgYGBzbWFsbCcnLiAqKVxuXG5sZXQgcGFjayAoYSA6IGludCBhcnJheSkgOiB0ID1cblxuICBsZXQgbSA9IEFycmF5Lmxlbmd0aCBhIGluXG5cbiAgKCogQ29tcHV0ZSB0aGUgbWF4aW11bSBtYWduaXR1ZGUgb2YgdGhlIGFycmF5IGVsZW1lbnRzLiBUaGlzIHRlbGxzXG4gICAgIHVzIGhvdyBtYW55IGJpdHMgcGVyIGVsZW1lbnQgd2UgYXJlIGdvaW5nIHRvIHVzZS4gKilcblxuICBsZXQgayA9XG4gICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gayB2IC0+XG4gICAgICBtYXggayAobWFnbml0dWRlIHYpXG4gICAgKSAxIGFcbiAgaW5cblxuICAoKiBCZWNhdXNlIGFjY2VzcyB0byBvY2FtbCBzdHJpbmdzIGlzIHBlcmZvcm1lZCBvbiBhbiA4LWJpdCBiYXNpcyxcbiAgICAgdHdvIGNhc2VzIGFyaXNlLiBJZiBba10gaXMgbGVzcyB0aGFuIDgsIHRoZW4gd2UgY2FuIHBhY2sgbXVsdGlwbGVcbiAgICAgYXJyYXkgZW50cmllcyBpbnRvIGEgc2luZ2xlIGNoYXJhY3Rlci4gSWYgW2tdIGlzIGdyZWF0ZXIgdGhhbiA4LFxuICAgICB0aGVuIHdlIG11c3QgdXNlIG11bHRpcGxlIGNoYXJhY3RlcnMgdG8gcmVwcmVzZW50IGEgc2luZ2xlIGFycmF5XG4gICAgIGVudHJ5LiAqKVxuXG4gIGlmIGsgPD0gOCB0aGVuIGJlZ2luXG5cbiAgICAoKiBbd10gaXMgdGhlIG51bWJlciBvZiBhcnJheSBlbnRyaWVzIHRoYXQgd2UgcGFjayBpbiBhIGNoYXJhY3Rlci4gKilcblxuICAgIGFzc2VydCAoOCBtb2QgayA9IDApO1xuICAgIGxldCB3ID0gOCAvIGsgaW5cblxuICAgICgqIFtuXSBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgdGhhdCB3ZSBhbGxvY2F0ZS4gKilcblxuICAgIGxldCBuID1cbiAgICAgIGlmIG0gbW9kIHcgPSAwIHRoZW5cbiAgICAgICAgbSAvIHdcbiAgICAgIGVsc2VcbiAgICAgICAgbSAvIHcgKyAxXG4gICAgaW5cblxuICAgIGxldCBzID1cbiAgICAgIEJ5dGVzLmNyZWF0ZSBuXG4gICAgaW5cblxuICAgICgqIERlZmluZSBhIHJlYWRlciBmb3IgdGhlIHNvdXJjZSBhcnJheS4gVGhlIHJlYWRlciBtaWdodCBydW4gb2ZmXG4gICAgICAgdGhlIGVuZCBpZiBbd10gZG9lcyBub3QgZGl2aWRlIFttXS4gKilcblxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBsZXQgaWkgPSAhaSBpblxuICAgICAgaWYgaWkgPSBtIHRoZW5cbiAgICAgICAgMCAoKiByYW4gb2ZmIHRoZSBlbmQsIHBhZCB3aXRoIHplcm9lcyAqKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgdiA9IGEuKGlpKSBpblxuICAgICAgICBpIDo9IGlpICsgMTtcbiAgICAgICAgdlxuICAgIGluXG5cbiAgICAoKiBGaWxsIHVwIHRoZSBzdHJpbmcuICopXG5cbiAgICBmb3IgaiA9IDAgdG8gbiAtIDEgZG9cbiAgICAgIGxldCBjID0gcmVmIDAgaW5cbiAgICAgIGZvciBfeCA9IDEgdG8gdyBkb1xuICAgICAgICBjIDo9ICghYyBsc2wgaykgbG9yIG5leHQoKVxuICAgICAgZG9uZTtcbiAgICAgIEJ5dGVzLnNldCBzIGogKENoYXIuY2hyICFjKVxuICAgIGRvbmU7XG5cbiAgICAoKiBEb25lLiAqKVxuXG4gICAgaywgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzXG5cbiAgZW5kXG4gIGVsc2UgYmVnaW4gKCogayA+IDggKilcblxuICAgICgqIFt3XSBpcyB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCB3ZSB1c2UgdG8gZW5jb2RlIGFuIGFycmF5IGVudHJ5LiAqKVxuXG4gICAgYXNzZXJ0IChrIG1vZCA4ID0gMCk7XG4gICAgbGV0IHcgPSBrIC8gOCBpblxuXG4gICAgKCogW25dIGlzIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyB0aGF0IHdlIGFsbG9jYXRlLiAqKVxuXG4gICAgbGV0IG4gPVxuICAgICAgbSAqIHdcbiAgICBpblxuXG4gICAgbGV0IHMgPVxuICAgICAgQnl0ZXMuY3JlYXRlIG5cbiAgICBpblxuXG4gICAgKCogRmlsbCB1cCB0aGUgc3RyaW5nLiAqKVxuXG4gICAgZm9yIGkgPSAwIHRvIG0gLSAxIGRvXG4gICAgICBsZXQgdiA9IHJlZiBhLihpKSBpblxuICAgICAgZm9yIHggPSAxIHRvIHcgZG9cbiAgICAgICAgQnl0ZXMuc2V0IHMgKChpICsgMSkgKiB3IC0geCkgKENoYXIuY2hyICghdiBsYW5kIDI1NSkpO1xuICAgICAgICB2IDo9ICF2IGxzciA4XG4gICAgICBkb25lXG4gICAgZG9uZTtcblxuICAgICgqIERvbmUuICopXG5cbiAgICBrLCBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHNcblxuICBlbmRcblxuKCogQWNjZXNzIHRvIGEgc3RyaW5nLiAqKVxuXG5sZXQgcmVhZCAocyA6IHN0cmluZykgKGkgOiBpbnQpIDogaW50ID1cbiAgQ2hhci5jb2RlIChTdHJpbmcudW5zYWZlX2dldCBzIGkpXG5cbigqIFtnZXQxIHQgaV0gcmV0dXJucyB0aGUgaW50ZWdlciBzdG9yZWQgaW4gdGhlIHBhY2tlZCBhcnJheSBbdF0gYXQgaW5kZXggW2ldLlxuICAgSXQgYXNzdW1lcyAoYW5kIGRvZXMgbm90IGNoZWNrKSB0aGF0IHRoZSBhcnJheSdzIGJpdCB3aWR0aCBpcyBbMV0uIFRoZVxuICAgcGFyYW1ldGVyIFt0XSBpcyBqdXN0IGEgc3RyaW5nLiAqKVxuXG5sZXQgZ2V0MSAocyA6IHN0cmluZykgKGkgOiBpbnQpIDogaW50ID1cbiAgbGV0IGMgPSByZWFkIHMgKGkgbHNyIDMpIGluXG4gIGxldCBjID0gYyBsc3IgKChsbm90IGkpIGxhbmQgMGIxMTEpIGluXG4gIGxldCBjID0gYyBsYW5kIDBiMSBpblxuICBjXG5cbigqIFtnZXQgdCBpXSByZXR1cm5zIHRoZSBpbnRlZ2VyIHN0b3JlZCBpbiB0aGUgcGFja2VkIGFycmF5IFt0XSBhdCBpbmRleCBbaV0uICopXG5cbigqIFRvZ2V0aGVyLCBbcGFja10gYW5kIFtnZXRdIHNhdGlzZnkgdGhlIGZvbGxvd2luZyBwcm9wZXJ0eTogaWYgdGhlIGluZGV4IFtpXVxuICAgaXMgd2l0aGluIGJvdW5kcywgdGhlbiBbZ2V0IChwYWNrIGEpIGldIGVxdWFscyBbYS4oaSldLiAqKVxuXG5sZXQgZ2V0ICgoaywgcykgOiB0KSAoaSA6IGludCkgOiBpbnQgPVxuICBtYXRjaCBrIHdpdGhcbiAgfCAxIC0+XG4gICAgICBnZXQxIHMgaVxuICB8IDIgLT5cbiAgICAgIGxldCBjID0gcmVhZCBzIChpIGxzciAyKSBpblxuICAgICAgbGV0IGMgPSBjIGxzciAoMiAqICgobG5vdCBpKSBsYW5kIDBiMTEpKSBpblxuICAgICAgbGV0IGMgPSBjIGxhbmQgMGIxMSBpblxuICAgICAgY1xuICB8IDQgLT5cbiAgICAgIGxldCBjID0gcmVhZCBzIChpIGxzciAxKSBpblxuICAgICAgbGV0IGMgPSBjIGxzciAoNCAqICgobG5vdCBpKSBsYW5kIDBiMSkpIGluXG4gICAgICBsZXQgYyA9IGMgbGFuZCAwYjExMTEgaW5cbiAgICAgIGNcbiAgfCA4IC0+XG4gICAgICByZWFkIHMgaVxuICB8IDE2IC0+XG4gICAgICBsZXQgaiA9IDIgKiBpIGluXG4gICAgICAocmVhZCBzIGopIGxzbCA4ICsgcmVhZCBzIChqICsgMSlcbiAgfCBfIC0+XG4gICAgICBhc3NlcnQgKGsgPSAzMik7ICgqIDY0IGJpdHMgdW5saWtlbHksIG5vdCBzdXBwb3J0ZWQgKilcbiAgICAgIGxldCBqID0gNCAqIGkgaW5cbiAgICAgICgoKHJlYWQgcyBqIGxzbCA4KSArIHJlYWQgcyAoaiArIDEpKSBsc2wgOCArIHJlYWQgcyAoaiArIDIpKSBsc2wgOCArIHJlYWQgcyAoaiArIDMpXG5cbigqIFt1bmZsYXR0ZW4xIChuLCBkYXRhKSBpIGpdIGFjY2Vzc2VzIHRoZSB0d28tZGltZW5zaW9uYWwgYml0bWFwXG4gICByZXByZXNlbnRlZCBieSBbKG4sIGRhdGEpXSBhdCBpbmRpY2VzIFtpXSBhbmQgW2pdLiBUaGUgaW50ZWdlclxuICAgW25dIGlzIHRoZSB3aWR0aCBvZiB0aGUgYml0bWFwOyB0aGUgc3RyaW5nIFtkYXRhXSBpcyB0aGUgc2Vjb25kXG4gICBjb21wb25lbnQgb2YgdGhlIHBhY2tlZCBhcnJheSBvYnRhaW5lZCBieSBlbmNvZGluZyB0aGUgdGFibGUgYXNcbiAgIGEgb25lLWRpbWVuc2lvbmFsIGFycmF5LiAqKVxuXG5sZXQgdW5mbGF0dGVuMSAobiwgZGF0YSkgaSBqID1cbiAgIGdldDEgZGF0YSAobiAqIGkgKyBqKVxuXG5lbmRcbm1vZHVsZSBSb3dEaXNwbGFjZW1lbnQgPSBzdHJ1Y3RcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCBJbnJpYS4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyICAgICAqKVxuKCogICB0aGUgdGVybXMgb2YgdGhlIEdOVSBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLCB3aXRoIGEgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZywgYXMgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVGhpcyBtb2R1bGUgY29tcHJlc3NlcyBhIHR3by1kaW1lbnNpb25hbCB0YWJsZSwgd2hlcmUgc29tZSB2YWx1ZXNcbiAgIGFyZSBjb25zaWRlcmVkIGluc2lnbmlmaWNhbnQsIHZpYSByb3cgZGlzcGxhY2VtZW50LiAqKVxuXG4oKiBUaGlzIGlkZWEgcmVwb3J0ZWRseSBhcHBlYXJzIGluIEFobyBhbmQgVWxsbWFuJ3MgYGBQcmluY2lwbGVzXG4gICBvZiBDb21waWxlciBEZXNpZ24nJyAoMTk3NykuIEl0IGlzIGV2YWx1YXRlZCBpbiBUYXJqYW4gYW5kIFlhbydzXG4gICBgYFN0b3JpbmcgYSBTcGFyc2UgVGFibGUnJyAoMTk3OSkgYW5kIGluIERlbmNrZXIsIETDvHJyZSwgYW5kIEhldWZ0J3NcbiAgIGBgT3B0aW1pemF0aW9uIG9mIFBhcnNlciBUYWJsZXMgZm9yIFBvcnRhYmxlIENvbXBpbGVycycnICgxOTg0KS4gKilcblxuKCogQSBjb21wcmVzc2VkIHRhYmxlIGlzIHJlcHJlc2VudGVkIGFzIGEgcGFpciBvZiBhcnJheXMuIFRoZVxuICAgZGlzcGxhY2VtZW50IGFycmF5IGlzIGFuIGFycmF5IG9mIG9mZnNldHMgaW50byB0aGUgZGF0YSBhcnJheS4gKilcblxudHlwZSAnYSB0YWJsZSA9XG4gICAgaW50IGFycmF5ICogKCogZGlzcGxhY2VtZW50ICopXG4gICAgICdhIGFycmF5ICAgKCogZGF0YSAqKVxuXG4oKiBJbiBhIG5hdHVyYWwgdmVyc2lvbiBvZiB0aGlzIGFsZ29yaXRobSwgZGlzcGxhY2VtZW50cyB3b3VsZCBiZSBncmVhdGVyXG4gICB0aGFuIChvciBlcXVhbCB0bykgWy1uXS4gSG93ZXZlciwgaW4gdGhlIHBhcnRpY3VsYXIgc2V0dGluZyBvZiBNZW5oaXIsXG4gICBib3RoIGFycmF5cyBhcmUgaW50ZW5kZWQgdG8gYmUgY29tcHJlc3NlZCB3aXRoIFtQYWNrZWRJbnRBcnJheV0sIHdoaWNoXG4gICBkb2VzIG5vdCBlZmZpY2llbnRseSBzdXBwb3J0IG5lZ2F0aXZlIG51bWJlcnMuIEZvciB0aGlzIHJlYXNvbiwgd2UgYXJlXG4gICBjYXJlZnVsIG5vdCB0byBwcm9kdWNlIG5lZ2F0aXZlIGRpc3BsYWNlbWVudHMuICopXG5cbigqIEluIG9yZGVyIHRvIGF2b2lkIHByb2R1Y2luZyBuZWdhdGl2ZSBkaXNwbGFjZW1lbnRzLCB3ZSBzaW1wbHkgdXNlIHRoZVxuICAgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IGFzIHRoZSBzaWduIGJpdC4gVGhpcyBpcyBpbXBsZW1lbnRlZCBieSBbZW5jb2RlXVxuICAgYW5kIFtkZWNvZGVdIGJlbG93LiAqKVxuXG4oKiBPbmUgY291bGQgYWxzbyB0aGluaywgc2F5LCBvZiBhZGRpbmcgW25dIHRvIGV2ZXJ5IGRpc3BsYWNlbWVudCwgc28gYXNcbiAgIHRvIGVuc3VyZSB0aGF0IGFsbCBkaXNwbGFjZW1lbnRzIGFyZSBub25uZWdhdGl2ZS4gVGhpcyB3b3VsZCB3b3JrLCBidXRcbiAgIHdvdWxkIHJlcXVpcmUgW25dIHRvIGJlIHB1Ymxpc2hlZCwgZm9yIHVzZSBieSB0aGUgZGVjb2Rlci4gKilcblxubGV0IGVuY29kZSAoZGlzcGxhY2VtZW50IDogaW50KSA6IGludCA9XG4gIGlmIGRpc3BsYWNlbWVudCA+PSAwIHRoZW5cbiAgICBkaXNwbGFjZW1lbnQgbHNsIDFcbiAgZWxzZVxuICAgICgtZGlzcGxhY2VtZW50KSBsc2wgMSArIDFcblxubGV0IGRlY29kZSAoZGlzcGxhY2VtZW50IDogaW50KSA6IGludCA9XG4gIGlmIGRpc3BsYWNlbWVudCBsYW5kIDEgPSAwIHRoZW5cbiAgICBkaXNwbGFjZW1lbnQgbHNyIDFcbiAgZWxzZVxuICAgIC0oZGlzcGxhY2VtZW50IGxzciAxKVxuXG4oKiBJdCBpcyByZWFzb25hYmxlIHRvIGFzc3VtZSB0aGF0LCBhcyBtYXRyaWNlcyBncm93IGxhcmdlLCB0aGVpclxuICAgZGVuc2l0eSBiZWNvbWVzIGxvdywgaS5lLiwgdGhleSBoYXZlIG1hbnkgaW5zaWduaWZpY2FudCBlbnRyaWVzLlxuICAgQXMgYSByZXN1bHQsIGl0IGlzIGltcG9ydGFudCB0byB3b3JrIHdpdGggYSBzcGFyc2UgZGF0YSBzdHJ1Y3R1cmVcbiAgIGZvciByb3dzLiBXZSBpbnRlcm5hbGx5IHJlcHJlc2VudCBhIHJvdyBhcyBhIGxpc3Qgb2YgaXRzXG4gICBzaWduaWZpY2FudCBlbnRyaWVzLCB3aGVyZSBlYWNoIGVudHJ5IGlzIGEgcGFpciBvZiBhIFtqXSBpbmRleCBhbmRcbiAgIGFuIGVsZW1lbnQuICopXG5cbnR5cGUgJ2Egcm93ID1cbiAgICAoaW50ICogJ2EpIGxpc3RcblxuKCogW2NvbXByZXNzIGVxdWFsIGluc2lnbmlmaWNhbnQgZHVtbXkgbSBuIHRdIHR1cm5zIHRoZSB0d28tZGltZW5zaW9uYWwgdGFibGVcbiAgIFt0XSBpbnRvIGEgY29tcHJlc3NlZCB0YWJsZS4gVGhlIHBhcmFtZXRlciBbZXF1YWxdIGlzIGVxdWFsaXR5IG9mIGRhdGFcbiAgIHZhbHVlcy4gVGhlIHBhcmFtZXRlciBbd2lsZGNhcmRdIHRlbGxzIHdoaWNoIGRhdGEgdmFsdWVzIGFyZSBpbnNpZ25pZmljYW50LFxuICAgYW5kIGNhbiB0aHVzIGJlIG92ZXJ3cml0dGVuIHdpdGggb3RoZXIgdmFsdWVzLiBUaGUgcGFyYW1ldGVyIFtkdW1teV0gaXNcbiAgIHVzZWQgdG8gZmlsbCBob2xlcyBpbiB0aGUgZGF0YSBhcnJheS4gW21dIGFuZCBbbl0gYXJlIHRoZSBpbnRlZ2VyXG4gICBkaW1lbnNpb25zIG9mIHRoZSB0YWJsZSBbdF0uICopXG5cbmxldCBjb21wcmVzc1xuICAgIChlcXVhbCA6ICdhIC0+ICdhIC0+IGJvb2wpXG4gICAgKGluc2lnbmlmaWNhbnQgOiAnYSAtPiBib29sKVxuICAgIChkdW1teSA6ICdhKVxuICAgIChtIDogaW50KSAobiA6IGludClcbiAgICAodCA6ICdhIGFycmF5IGFycmF5KVxuICAgIDogJ2EgdGFibGUgPVxuXG4gICgqIEJlIGRlZmVuc2l2ZS4gKilcblxuICBhc3NlcnQgKEFycmF5Lmxlbmd0aCB0ID0gbSk7XG4gIGFzc2VydCBiZWdpblxuICAgIGZvciBpID0gMCB0byBtIC0gMSBkb1xuICAgICAgYXNzZXJ0IChBcnJheS5sZW5ndGggdC4oaSkgPSBuKVxuICAgIGRvbmU7XG4gICAgdHJ1ZVxuICBlbmQ7XG5cbiAgKCogVGhpcyB0dXJucyBhIHJvdy1hcy1hcnJheSBpbnRvIGEgcm93LWFzLXNwYXJzZS1saXN0LiBUaGUgcm93IGlzXG4gICAgIGFjY29tcGFuaWVkIGJ5IGl0cyBpbmRleCBbaV0gYW5kIGJ5IGl0cyByYW5rICh0aGUgbnVtYmVyIG9mIGl0c1xuICAgICBzaWduaWZpY2FudCBlbnRyaWVzLCB0aGF0IGlzLCB0aGUgbGVuZ3RoIG9mIHRoZSByb3ctYXMtYS1saXN0LiAqKVxuXG4gIGxldCBzcGFyc2UgKGkgOiBpbnQpIChsaW5lIDogJ2EgYXJyYXkpIDogaW50ICogaW50ICogJ2Egcm93ICgqIGluZGV4LCByYW5rLCByb3cgKikgPVxuXG4gICAgbGV0IHJlYyBsb29wIChqIDogaW50KSAocmFuayA6IGludCkgKHJvdyA6ICdhIHJvdykgPVxuICAgICAgaWYgaiA8IDAgdGhlblxuICAgICAgICBpLCByYW5rLCByb3dcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IHggPSBsaW5lLihqKSBpblxuICAgICAgICBpZiBpbnNpZ25pZmljYW50IHggdGhlblxuICAgICAgICAgIGxvb3AgKGogLSAxKSByYW5rIHJvd1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbG9vcCAoaiAtIDEpICgxICsgcmFuaykgKChqLCB4KSA6OiByb3cpXG4gICAgaW5cblxuICAgIGxvb3AgKG4gLSAxKSAwIFtdXG5cbiAgaW5cblxuICAoKiBDb25zdHJ1Y3QgYW4gYXJyYXkgb2YgYWxsIHJvd3MsIHRvZ2V0aGVyIHdpdGggdGhlaXIgaW5kZXggYW5kIHJhbmsuICopXG5cbiAgbGV0IHJvd3MgOiAoaW50ICogaW50ICogJ2Egcm93KSBhcnJheSA9ICgqIGluZGV4LCByYW5rLCByb3cgKilcbiAgICBBcnJheS5tYXBpIHNwYXJzZSB0XG4gIGluXG5cbiAgKCogU29ydCB0aGlzIGFycmF5IGJ5IGRlY3JlYXNpbmcgcmFuay4gVGhpcyBkb2VzIG5vdCBoYXZlIGFueSBpbXBhY3RcbiAgICAgb24gY29ycmVjdG5lc3MsIGJ1dCByZXBvcnRlZGx5IGltcHJvdmVzIGNvbXByZXNzaW9uLiBUaGVcbiAgICAgaW50dWl0aXZlIGlkZWEgaXMgdGhhdCByb3dzIHdpdGggZmV3IHNpZ25pZmljYW50IGVsZW1lbnRzIGFyZVxuICAgICBlYXN5IHRvIGZpdCwgc28gdGhleSBzaG91bGQgYmUgaW5zZXJ0ZWQgbGFzdCwgYWZ0ZXIgdGhlIHByb2JsZW1cbiAgICAgaGFzIGJlY29tZSBxdWl0ZSBjb25zdHJhaW5lZCBieSBmaXR0aW5nIHRoZSBoZWF2aWVyIHJvd3MuIFRoaXNcbiAgICAgaGV1cmlzdGljIGlzIGF0dHJpYnV0ZWQgdG8gWmllZ2xlci4gKilcblxuICBBcnJheS5mYXN0X3NvcnQgKGZ1biAoXywgcmFuazEsIF8pIChfLCByYW5rMiwgXykgLT5cbiAgICBjb21wYXJlIHJhbmsyIHJhbmsxXG4gICkgcm93cztcblxuICAoKiBBbGxvY2F0ZSBhIG9uZS1kaW1lbnNpb25hbCBhcnJheSBvZiBkaXNwbGFjZW1lbnRzLiAqKVxuXG4gIGxldCBkaXNwbGFjZW1lbnQgOiBpbnQgYXJyYXkgPVxuICAgIEFycmF5Lm1ha2UgbSAwXG4gIGluXG5cbiAgKCogQWxsb2NhdGUgYSBvbmUtZGltZW5zaW9uYWwsIGluZmluaXRlIGFycmF5IG9mIHZhbHVlcy4gSW5kaWNlc1xuICAgICBpbnRvIHRoaXMgYXJyYXkgYXJlIHdyaXR0ZW4gW2tdLiAqKVxuXG4gIGxldCBkYXRhIDogJ2EgSW5maW5pdGVBcnJheS50ID1cbiAgICBJbmZpbml0ZUFycmF5Lm1ha2UgZHVtbXlcbiAgaW5cblxuICAoKiBEZXRlcm1pbmUgd2hldGhlciBbcm93XSBmaXRzIGF0IG9mZnNldCBba10gd2l0aGluIHRoZSBjdXJyZW50IFtkYXRhXVxuICAgICBhcnJheSwgdXAgdG8gZXh0ZW5zaW9uIG9mIHRoaXMgYXJyYXkuICopXG5cbiAgKCogTm90ZSB0aGF0IHRoaXMgY2hlY2sgYWx3YXlzIHN1Y2NlZWRzIHdoZW4gW2tdIGVxdWFscyB0aGUgbGVuZ3RoIG9mXG4gICAgIHRoZSBbZGF0YV0gYXJyYXkuIEluZGVlZCwgdGhlIGxvb3AgaXMgdGhlbiBza2lwcGVkLiBUaGlzIHByb3BlcnR5XG4gICAgIGd1YXJhbnRlZXMgdGhlIHRlcm1pbmF0aW9uIG9mIHRoZSByZWN1cnNpdmUgZnVuY3Rpb24gW2ZpdF0gYmVsb3cuICopXG5cbiAgbGV0IGZpdHMgayAocm93IDogJ2Egcm93KSA6IGJvb2wgPVxuXG4gICAgbGV0IGQgPSBJbmZpbml0ZUFycmF5LmV4dGVudCBkYXRhIGluXG5cbiAgICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPlxuICAgICAgICAgIHRydWVcbiAgICAgIHwgKGosIHgpIDo6IHJvdyAtPlxuXG4gICAgICAgICAgKCogW3hdIGlzIGEgc2lnbmlmaWNhbnQgZWxlbWVudC4gKilcblxuICAgICAgICAgICgqIEJ5IGh5cG90aGVzaXMsIFtrICsgal0gaXMgbm9ubmVnYXRpdmUuIElmIGl0IGlzIGdyZWF0ZXIgdGhhbiBvclxuICAgICAgICAgICAgIGVxdWFsIHRvIHRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGUgZGF0YSBhcnJheSwgc3RvcCAtLSB0aGUgcm93XG4gICAgICAgICAgICAgZml0cy4gKilcblxuICAgICAgICAgIGFzc2VydCAoayArIGogPj0gMCk7XG5cbiAgICAgICAgICBpZiBrICsgaiA+PSBkIHRoZW5cbiAgICAgICAgICAgIHRydWVcblxuICAgICAgICAgICgqIFdlIG5vdyBrbm93IHRoYXQgW2sgKyBqXSBpcyB3aXRoaW4gYm91bmRzIG9mIHRoZSBkYXRhXG4gICAgICAgICAgICAgYXJyYXkuIENoZWNrIHdoZXRoZXIgaXQgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBlbGVtZW50IFt5XSBmb3VuZFxuICAgICAgICAgICAgIHRoZXJlLiBJZiBpdCBpcywgY29udGludWUuIElmIGl0IGlzbid0LCBzdG9wIC0tIHRoZSByb3cgZG9lcyBub3RcbiAgICAgICAgICAgICBmaXQuICopXG5cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgeSA9IEluZmluaXRlQXJyYXkuZ2V0IGRhdGEgKGsgKyBqKSBpblxuICAgICAgICAgICAgaWYgaW5zaWduaWZpY2FudCB5IHx8IGVxdWFsIHggeSB0aGVuXG4gICAgICAgICAgICAgIGxvb3Agcm93XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGZhbHNlXG5cbiAgICBpblxuICAgIGxvb3Agcm93XG5cbiAgaW5cblxuICAoKiBGaW5kIHRoZSBsZWZ0bW9zdCBwb3NpdGlvbiB3aGVyZSBhIHJvdyBmaXRzLiAqKVxuXG4gICgqIElmIHRoZSBsZWZ0bW9zdCBzaWduaWZpY2FudCBlbGVtZW50IGluIHRoaXMgcm93IGlzIGF0IG9mZnNldCBbal0sXG4gICAgIHRoZW4gd2UgY2FuIGhvcGUgdG8gZml0IGFzIGZhciBsZWZ0IGFzIFstal0gLS0gc28gdGhpcyBlbGVtZW50XG4gICAgIGxhbmRzIGF0IG9mZnNldCBbMF0gaW4gdGhlIGRhdGEgYXJyYXkuICopXG5cbiAgKCogTm90ZSB0aGF0IGRpc3BsYWNlbWVudHMgbWF5IGJlIG5lZ2F0aXZlLiBUaGlzIG1lYW5zIHRoYXQsIGZvclxuICAgICBpbnNpZ25pZmljYW50IGVsZW1lbnRzLCBhY2Nlc3NlcyB0byB0aGUgZGF0YSBhcnJheSBjb3VsZCBmYWlsOiB0aGV5IGNvdWxkXG4gICAgIGJlIG91dCBvZiBib3VuZHMsIGVpdGhlciB0b3dhcmRzIHRoZSBsZWZ0IG9yIHRvd2FyZHMgdGhlIHJpZ2h0LiBUaGlzIGlzXG4gICAgIG5vdCBhIHByb2JsZW0sIGFzIGxvbmcgYXMgW2dldF0gaXMgaW52b2tlZCBvbmx5IGF0IHNpZ25pZmljYW50XG4gICAgIGVsZW1lbnRzLiAqKVxuXG4gIGxldCByZWMgZml0IGsgcm93IDogaW50ID1cbiAgICBpZiBmaXRzIGsgcm93IHRoZW5cbiAgICAgIGtcbiAgICBlbHNlXG4gICAgICBmaXQgKGsgKyAxKSByb3dcbiAgaW5cblxuICBsZXQgZml0IHJvdyA9XG4gICAgbWF0Y2ggcm93IHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICAgIDAgKCogaXJyZWxldmFudCAqKVxuICAgIHwgKGosIF8pIDo6IF8gLT5cbiAgICAgICAgZml0ICgtaikgcm93XG4gIGluXG5cbiAgKCogV3JpdGUgW3Jvd10gYXQgKGNvbXBhdGlibGUpIG9mZnNldCBba10uICopXG5cbiAgbGV0IHJlYyB3cml0ZSBrID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+XG4gICAgICAgICgpXG4gICAgfCAoaiwgeCkgOjogcm93IC0+XG4gICAgICAgIEluZmluaXRlQXJyYXkuc2V0IGRhdGEgKGsgKyBqKSB4O1xuICAgICAgICB3cml0ZSBrIHJvd1xuICBpblxuXG4gICgqIEl0ZXJhdGUgb3ZlciB0aGUgc29ydGVkIGFycmF5IG9mIHJvd3MuIEZpdCBhbmQgd3JpdGUgZWFjaCByb3cgYXRcbiAgICAgdGhlIGxlZnRtb3N0IGNvbXBhdGlibGUgb2Zmc2V0LiBVcGRhdGUgdGhlIGRpc3BsYWNlbWVudCB0YWJsZS4gKilcblxuICBBcnJheS5pdGVyIChmdW4gKGksIF8sIHJvdykgLT5cbiAgICBsZXQgayA9IGZpdCByb3cgaW4gKCogaWYgW3Jvd10gaGFzIGxlYWRpbmcgaW5zaWduaWZpY2FudCBlbGVtZW50cywgdGhlbiBba10gY2FuIGJlIG5lZ2F0aXZlICopXG4gICAgd3JpdGUgayByb3c7XG4gICAgZGlzcGxhY2VtZW50LihpKSA8LSBlbmNvZGUga1xuICApIHJvd3M7XG5cbiAgKCogUmV0dXJuIHRoZSBjb21wcmVzc2VkIHRhYmxlcy4gKilcblxuICBkaXNwbGFjZW1lbnQsIEluZmluaXRlQXJyYXkuZG9tYWluIGRhdGFcblxuKCogW2dldCBjdCBpIGpdIHJldHVybnMgdGhlIHZhbHVlIGZvdW5kIGF0IGluZGljZXMgW2ldIGFuZCBbal0gaW4gdGhlXG4gICBjb21wcmVzc2VkIHRhYmxlIFtjdF0uIFRoaXMgZnVuY3Rpb24gY2FsbCBpcyBwZXJtaXR0ZWQgb25seSBpZiB0aGVcbiAgIHZhbHVlIGZvdW5kIGF0IGluZGljZXMgW2ldIGFuZCBbal0gaW4gdGhlIG9yaWdpbmFsIHRhYmxlIGlzXG4gICBzaWduaWZpY2FudCAtLSBvdGhlcndpc2UsIGl0IGNvdWxkIGZhaWwgYWJydXB0bHkuICopXG5cbigqIFRvZ2V0aGVyLCBbY29tcHJlc3NdIGFuZCBbZ2V0XSBoYXZlIHRoZSBwcm9wZXJ0eSB0aGF0LCBpZiB0aGUgdmFsdWVcbiAgIGZvdW5kIGF0IGluZGljZXMgW2ldIGFuZCBbal0gaW4gYW4gdW5jb21wcmVzc2VkIHRhYmxlIFt0XSBpc1xuICAgc2lnbmlmaWNhbnQsIHRoZW4gW2dldCAoY29tcHJlc3MgdCkgaSBqXSBpcyBlcXVhbCB0byB0aGF0IHZhbHVlLiAqKVxuXG5sZXQgZ2V0IChkaXNwbGFjZW1lbnQsIGRhdGEpIGkgaiA9XG4gIGFzc2VydCAoMCA8PSBpICYmIGkgPCBBcnJheS5sZW5ndGggZGlzcGxhY2VtZW50KTtcbiAgbGV0IGsgPSBkZWNvZGUgZGlzcGxhY2VtZW50LihpKSBpblxuICBhc3NlcnQgKDAgPD0gayArIGogJiYgayArIGogPCBBcnJheS5sZW5ndGggZGF0YSk7XG4gICAgKCogZmFpbHVyZSBvZiB0aGlzIGFzc2VydGlvbiBpbmRpY2F0ZXMgYW4gYXR0ZW1wdCB0byBhY2Nlc3MgYW5cbiAgICAgICBpbnNpZ25pZmljYW50IGVsZW1lbnQgdGhhdCBoYXBwZW5zIHRvIGJlIG1hcHBlZCBvdXQgb2YgdGhlIGJvdW5kc1xuICAgICAgIG9mIHRoZSBbZGF0YV0gYXJyYXkuICopXG4gIGRhdGEuKGsgKyBqKVxuXG4oKiBbZ2V0Z2V0XSBpcyBhIHZhcmlhbnQgb2YgW2dldF0gd2hpY2ggb25seSByZXF1aXJlcyByZWFkIGFjY2VzcyxcbiAgIHZpYSBhY2Nlc3NvcnMsIHRvIHRoZSB0d28gY29tcG9uZW50cyBvZiB0aGUgdGFibGUuICopXG5cbmxldCBnZXRnZXQgZ2V0X2Rpc3BsYWNlbWVudCBnZXRfZGF0YSAoZGlzcGxhY2VtZW50LCBkYXRhKSBpIGogPVxuICBsZXQgayA9IGRlY29kZSAoZ2V0X2Rpc3BsYWNlbWVudCBkaXNwbGFjZW1lbnQgaSkgaW5cbiAgZ2V0X2RhdGEgZGF0YSAoayArIGopXG5lbmRcbm1vZHVsZSBMaW5lYXJpemVkQXJyYXkgPSBzdHJ1Y3RcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCBJbnJpYS4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyICAgICAqKVxuKCogICB0aGUgdGVybXMgb2YgdGhlIEdOVSBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLCB3aXRoIGEgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZywgYXMgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVGhlIFtlbnRyeV0gYXJyYXkgY29udGFpbnMgb2Zmc2V0cyBpbnRvIHRoZSBbZGF0YV0gYXJyYXkuIEl0IGhhcyBbbisxXVxuICAgZWxlbWVudHMgaWYgdGhlIG9yaWdpbmFsICh1bmVuY29kZWQpIGFycmF5IGhhcyBbbl0gZWxlbWVudHMuIFRoZSB2YWx1ZVxuICAgb2YgW2VudHJ5LihuKV0gaXMgdGhlIGxlbmd0aCBvZiB0aGUgW2RhdGFdIGFycmF5LiBUaGlzIGNvbnZlbnRpb24gaXNcbiAgIG5hdHVyYWwgYW5kIGFsbG93cyBhdm9pZGluZyBhIHNwZWNpYWwgY2FzZS4gKilcblxudHlwZSAnYSB0ID1cbiAgKCogZGF0YTogKikgICAnYSBhcnJheSAqXG4gICgqIGVudHJ5OiAqKSBpbnQgYXJyYXlcblxubGV0IG1ha2UgKGEgOiAnYSBhcnJheSBhcnJheSkgOiAnYSB0ID1cbiAgbGV0IG4gPSBBcnJheS5sZW5ndGggYSBpblxuICAoKiBCdWlsZCB0aGUgZW50cnkgYXJyYXkuICopXG4gIGxldCBzaXplID0gcmVmIDAgaW5cbiAgbGV0IGVudHJ5ID0gQXJyYXkuaW5pdCAobiArIDEpIChmdW4gaSAtPlxuICAgIGxldCBzID0gIXNpemUgaW5cbiAgICBpZiBpIDwgbiB0aGVuXG4gICAgICBzaXplIDo9IHMgKyBBcnJheS5sZW5ndGggYS4oaSk7XG4gICAgc1xuICApIGluXG4gIGFzc2VydCAoZW50cnkuKG4pID0gIXNpemUpO1xuICAoKiBCdWlsZCB0aGUgZGF0YSBhcnJheS4gKilcbiAgbGV0IGkgPSByZWYgMFxuICBhbmQgaiA9IHJlZiAwIGluXG4gIGxldCBkYXRhID0gQXJyYXkuaW5pdCAhc2l6ZSAoZnVuIF8gLT5cbiAgICB3aGlsZSAhaiA9IEFycmF5Lmxlbmd0aCBhLighaSkgZG9cbiAgICAgIGkgOj0gIWkgKyAxO1xuICAgICAgaiA6PSAwO1xuICAgIGRvbmU7XG4gICAgbGV0IHggPSBhLighaSkuKCFqKSBpblxuICAgIGogOj0gIWogKyAxO1xuICAgIHhcbiAgKSBpblxuICBkYXRhLCBlbnRyeVxuXG5sZXQgbGVuZ3RoICgoXywgZW50cnkpIDogJ2EgdCkgOiBpbnQgPVxuICBBcnJheS5sZW5ndGggZW50cnlcblxubGV0IHJvd19sZW5ndGggKChfLCBlbnRyeSkgOiAnYSB0KSBpIDogaW50ID1cbiAgZW50cnkuKGkgKyAxKSAtIGVudHJ5LihpKVxuXG5sZXQgcm93X2xlbmd0aF92aWEgZ2V0X2VudHJ5IGkgPVxuICBnZXRfZW50cnkgKGkgKyAxKSAtIGdldF9lbnRyeSBpXG5cbmxldCByZWFkICgoZGF0YSwgZW50cnkpIGFzIGxhIDogJ2EgdCkgaSBqIDogJ2EgPVxuICBhc3NlcnQgKDAgPD0gaiAmJiBqIDwgcm93X2xlbmd0aCBsYSBpKTtcbiAgZGF0YS4oZW50cnkuKGkpICsgailcblxubGV0IHJlYWRfdmlhIGdldF9kYXRhIGdldF9lbnRyeSBpIGogPVxuICBhc3NlcnQgKDAgPD0gaiAmJiBqIDwgcm93X2xlbmd0aF92aWEgZ2V0X2VudHJ5IGkpO1xuICBnZXRfZGF0YSAoZ2V0X2VudHJ5IGkgKyBqKVxuXG5sZXQgd3JpdGUgKChkYXRhLCBlbnRyeSkgYXMgbGEgOiAnYSB0KSBpIGogKHYgOiAnYSkgOiB1bml0ID1cbiAgYXNzZXJ0ICgwIDw9IGogJiYgaiA8IHJvd19sZW5ndGggbGEgaSk7XG4gIGRhdGEuKGVudHJ5LihpKSArIGopIDwtIHZcblxubGV0IHJlYyByZWFkX2ludGVydmFsX3ZpYSBnZXRfZGF0YSBpIGogPVxuICBpZiBpID0gaiB0aGVuXG4gICAgW11cbiAgZWxzZVxuICAgIGdldF9kYXRhIGkgOjogcmVhZF9pbnRlcnZhbF92aWEgZ2V0X2RhdGEgKGkgKyAxKSBqXG5cbmxldCByZWFkX3Jvd192aWEgZ2V0X2RhdGEgZ2V0X2VudHJ5IGkgPVxuICByZWFkX2ludGVydmFsX3ZpYSBnZXRfZGF0YSAoZ2V0X2VudHJ5IGkpIChnZXRfZW50cnkgKGkgKyAxKSlcblxubGV0IHJlYWRfcm93ICgoZGF0YSwgZW50cnkpIDogJ2EgdCkgaSA6ICdhIGxpc3QgPVxuICByZWFkX3Jvd192aWEgKEFycmF5LmdldCBkYXRhKSAoQXJyYXkuZ2V0IGVudHJ5KSBpXG5cbmVuZFxubW9kdWxlIFRhYmxlRm9ybWF0ID0gc3RydWN0XG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgSW5yaWEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciAgICAgKilcbigqICAgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGlicmFyeSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMiwgd2l0aCBhICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcsIGFzIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoaXMgc2lnbmF0dXJlIGRlZmluZXMgdGhlIGZvcm1hdCBvZiB0aGUgcGFyc2UgdGFibGVzLiBJdCBpcyB1c2VkIGFzXG4gICBhbiBhcmd1bWVudCB0byBbVGFibGVJbnRlcnByZXRlci5NYWtlXS4gKilcblxubW9kdWxlIHR5cGUgVEFCTEVTID0gc2lnXG5cbiAgKCogVGhpcyBpcyB0aGUgcGFyc2VyJ3MgdHlwZSBvZiB0b2tlbnMuICopXG5cbiAgdHlwZSB0b2tlblxuXG4gICgqIFRoaXMgbWFwcyBhIHRva2VuIHRvIGl0cyBpbnRlcm5hbCAoZ2VuZXJhdGlvbi10aW1lKSBpbnRlZ2VyIGNvZGUuICopXG5cbiAgdmFsIHRva2VuMnRlcm1pbmFsOiB0b2tlbiAtPiBpbnRcblxuICAoKiBUaGlzIGlzIHRoZSBpbnRlZ2VyIGNvZGUgZm9yIHRoZSBlcnJvciBwc2V1ZG8tdG9rZW4uICopXG5cbiAgdmFsIGVycm9yX3Rlcm1pbmFsOiBpbnRcblxuICAoKiBUaGlzIG1hcHMgYSB0b2tlbiB0byBpdHMgc2VtYW50aWMgdmFsdWUuICopXG5cbiAgdmFsIHRva2VuMnZhbHVlOiB0b2tlbiAtPiBPYmoudFxuXG4gICgqIFRyYWRpdGlvbmFsbHksIGFuIExSIGF1dG9tYXRvbiBpcyBkZXNjcmliZWQgYnkgdHdvIHRhYmxlcywgbmFtZWx5LCBhblxuICAgICBhY3Rpb24gdGFibGUgYW5kIGEgZ290byB0YWJsZS4gU2VlLCBmb3IgaW5zdGFuY2UsIHRoZSBEcmFnb24gYm9vay5cblxuICAgICBUaGUgYWN0aW9uIHRhYmxlIGlzIGEgdHdvLWRpbWVuc2lvbmFsIG1hdHJpeCB0aGF0IG1hcHMgYSBzdGF0ZSBhbmQgYVxuICAgICBsb29rYWhlYWQgdG9rZW4gdG8gYW4gYWN0aW9uLiBBbiBhY3Rpb24gaXMgb25lIG9mOiBzaGlmdCB0byBhIGNlcnRhaW5cbiAgICAgc3RhdGUsIHJlZHVjZSBhIGNlcnRhaW4gcHJvZHVjdGlvbiwgYWNjZXB0LCBvciBmYWlsLlxuXG4gICAgIFRoZSBnb3RvIHRhYmxlIGlzIGEgdHdvLWRpbWVuc2lvbmFsIG1hdHJpeCB0aGF0IG1hcHMgYSBzdGF0ZSBhbmQgYVxuICAgICBub24tdGVybWluYWwgc3ltYm9sIHRvIGVpdGhlciBhIHN0YXRlIG9yIHVuZGVmaW5lZC4gQnkgY29uc3RydWN0aW9uLCB0aGlzXG4gICAgIHRhYmxlIGlzIHNwYXJzZTogaXRzIHVuZGVmaW5lZCBlbnRyaWVzIGFyZSBuZXZlciBsb29rZWQgdXAuIEEgY29tcHJlc3Npb25cbiAgICAgdGVjaG5pcXVlIGlzIGZyZWUgdG8gb3ZlcmxhcCB0aGVtIHdpdGggb3RoZXIgZW50cmllcy5cblxuICAgICBJbiBNZW5oaXIsIHRoaW5ncyBhcmUgc2xpZ2h0bHkgZGlmZmVyZW50LiBJZiBhIHN0YXRlIGhhcyBhIGRlZmF1bHRcbiAgICAgcmVkdWN0aW9uIG9uIHRva2VuIFsjXSwgdGhlbiB0aGF0IHJlZHVjdGlvbiBtdXN0IGJlIHBlcmZvcm1lZCB3aXRob3V0XG4gICAgIGNvbnN1bHRpbmcgdGhlIGxvb2thaGVhZCB0b2tlbi4gQXMgYSByZXN1bHQsIHdlIG11c3QgZmlyc3QgZGV0ZXJtaW5lXG4gICAgIHdoZXRoZXIgdGhhdCBpcyB0aGUgY2FzZSwgYmVmb3JlIHdlIGNhbiBvYnRhaW4gYSBsb29rYWhlYWQgdG9rZW4gYW5kIHVzZSBpdFxuICAgICBhcyBhbiBpbmRleCBpbiB0aGUgYWN0aW9uIHRhYmxlLlxuXG4gICAgIFRodXMsIE1lbmhpcidzIHRhYmxlcyBhcmUgYXMgZm9sbG93cy5cblxuICAgICBBIG9uZS1kaW1lbnNpb25hbCBkZWZhdWx0IHJlZHVjdGlvbiB0YWJsZSBtYXBzIGEgc3RhdGUgdG8gZWl0aGVyIGBgbm9cbiAgICAgZGVmYXVsdCByZWR1Y3Rpb24nJyAoZW5jb2RlZCBhczogMCkgb3IgYGBieSBkZWZhdWx0LCByZWR1Y2UgcHJvZCcnXG4gICAgIChlbmNvZGVkIGFzOiAxICsgcHJvZCkuIFRoZSBhY3Rpb24gdGFibGUgaXMgbG9va2VkIHVwIG9ubHkgd2hlbiB0aGVyZVxuICAgICBpcyBubyBkZWZhdWx0IHJlZHVjdGlvbi4gKilcblxuICB2YWwgZGVmYXVsdF9yZWR1Y3Rpb246IFBhY2tlZEludEFycmF5LnRcblxuICAoKiBNZW5oaXIgZm9sbG93cyBEZW5ja2VyLCBEw7xycmUgYW5kIEhldWZ0LCB3aG8gcG9pbnQgb3V0IHRoYXQsIGFsdGhvdWdoIHRoZVxuICAgICBhY3Rpb24gdGFibGUgaXMgbm90IHNwYXJzZSBieSBuYXR1cmUgKGkuZS4sIHRoZSBlcnJvciBlbnRyaWVzIGFyZVxuICAgICBzaWduaWZpY2FudCksIGl0IGNhbiBiZSBtYWRlIHNwYXJzZSBieSBmaXJzdCBmYWN0b3Jpbmcgb3V0IGEgYmluYXJ5IGVycm9yXG4gICAgIG1hdHJpeCwgdGhlbiByZXBsYWNpbmcgdGhlIGVycm9yIGVudHJpZXMgaW4gdGhlIGFjdGlvbiB0YWJsZSB3aXRoIHVuZGVmaW5lZFxuICAgICBlbnRyaWVzLiBUaHVzOlxuXG4gICAgIEEgdHdvLWRpbWVuc2lvbmFsIGVycm9yIGJpdG1hcCBtYXBzIGEgc3RhdGUgYW5kIGEgdGVybWluYWwgdG8gZWl0aGVyXG4gICAgIGBgZmFpbCcnIChlbmNvZGVkIGFzOiAwKSBvciBgYGRvIG5vdCBmYWlsJycgKGVuY29kZWQgYXM6IDEpLiBUaGUgYWN0aW9uXG4gICAgIHRhYmxlLCB3aGljaCBpcyBub3cgc3BhcnNlLCBpcyBsb29rZWQgdXAgb25seSBpbiB0aGUgbGF0dGVyIGNhc2UuICopXG5cbiAgKCogVGhlIGVycm9yIGJpdG1hcCBpcyBmbGF0dGVuZWQgaW50byBhIG9uZS1kaW1lbnNpb25hbCB0YWJsZTsgaXRzIHdpZHRoIGlzXG4gICAgIHJlY29yZGVkIHNvIGFzIHRvIGFsbG93IGluZGV4aW5nLiBUaGUgdGFibGUgaXMgdGhlbiBjb21wcmVzc2VkIHZpYVxuICAgICBbUGFja2VkSW50QXJyYXldLiBUaGUgYml0IHdpZHRoIG9mIHRoZSByZXN1bHRpbmcgcGFja2VkIGFycmF5IG11c3QgYmVcbiAgICAgWzFdLCBzbyBpdCBpcyBub3QgZXhwbGljaXRseSByZWNvcmRlZC4gKilcblxuICAoKiBUaGUgZXJyb3IgYml0bWFwIGRvZXMgbm90IGNvbnRhaW4gYSBjb2x1bW4gZm9yIHRoZSBbI10gcHNldWRvLXRlcm1pbmFsLlxuICAgICBUaHVzLCBpdHMgd2lkdGggaXMgW1Rlcm1pbmFsLm4gLSAxXS4gV2UgZXhwbG9pdCB0aGUgZmFjdCB0aGF0IHRoZSBpbnRlZ2VyXG4gICAgIGNvZGUgYXNzaWduZWQgdG8gWyNdIGlzIGdyZWF0ZXN0OiB0aGUgZmFjdCB0aGF0IHRoZSByaWdodC1tb3N0IGNvbHVtblxuICAgICBpbiB0aGUgYml0bWFwIGlzIG1pc3NpbmcgZG9lcyBub3QgYWZmZWN0IHRoZSBjb2RlIGZvciBhY2Nlc3NpbmcgaXQuICopXG5cbiAgdmFsIGVycm9yOiBpbnQgKCogd2lkdGggb2YgdGhlIGJpdG1hcCAqKSAqIHN0cmluZyAoKiBzZWNvbmQgY29tcG9uZW50IG9mIFtQYWNrZWRJbnRBcnJheS50XSAqKVxuXG4gICgqIEEgdHdvLWRpbWVuc2lvbmFsIGFjdGlvbiB0YWJsZSBtYXBzIGEgc3RhdGUgYW5kIGEgdGVybWluYWwgdG8gb25lIG9mXG4gICAgIGBgc2hpZnQgdG8gc3RhdGUgcyBhbmQgZGlzY2FyZCB0aGUgY3VycmVudCB0b2tlbicnIChlbmNvZGVkIGFzOiBzIHwgMTApLFxuICAgICBgYHNoaWZ0IHRvIHN0YXRlIHMgd2l0aG91dCBkaXNjYXJkaW5nIHRoZSBjdXJyZW50IHRva2VuJycgKGVuY29kZWQgYXM6IHMgfFxuICAgICAxMSksIG9yIGBgcmVkdWNlIHByb2QnJyAoZW5jb2RlZCBhczogcHJvZCB8IDAxKS4gKilcblxuICAoKiBUaGUgYWN0aW9uIHRhYmxlIGlzIGZpcnN0IGNvbXByZXNzZWQgdmlhIFtSb3dEaXNwbGFjZW1lbnRdLCB0aGVuIHBhY2tlZFxuICAgICB2aWEgW1BhY2tlZEludEFycmF5XS4gKilcblxuICAoKiBMaWtlIHRoZSBlcnJvciBiaXRtYXAsIHRoZSBhY3Rpb24gdGFibGUgZG9lcyBub3QgY29udGFpbiBhIGNvbHVtbiBmb3IgdGhlXG4gICAgIFsjXSBwc2V1ZG8tdGVybWluYWwuICopXG5cbiAgdmFsIGFjdGlvbjogUGFja2VkSW50QXJyYXkudCAqIFBhY2tlZEludEFycmF5LnRcblxuICAoKiBBIG9uZS1kaW1lbnNpb25hbCBsaHMgdGFibGUgbWFwcyBhIHByb2R1Y3Rpb24gdG8gaXRzIGxlZnQtaGFuZCBzaWRlIChhXG4gICAgIG5vbi10ZXJtaW5hbCBzeW1ib2wpLiAqKVxuXG4gIHZhbCBsaHM6IFBhY2tlZEludEFycmF5LnRcblxuICAoKiBBIHR3by1kaW1lbnNpb25hbCBnb3RvIHRhYmxlIG1hcHMgYSBzdGF0ZSBhbmQgYSBub24tdGVybWluYWwgc3ltYm9sIHRvXG4gICAgIGVpdGhlciB1bmRlZmluZWQgKGVuY29kZWQgYXM6IDApIG9yIGEgbmV3IHN0YXRlIHMgKGVuY29kZWQgYXM6IDEgKyBzKS4gKilcblxuICAoKiBUaGUgZ290byB0YWJsZSBpcyBmaXJzdCBjb21wcmVzc2VkIHZpYSBbUm93RGlzcGxhY2VtZW50XSwgdGhlbiBwYWNrZWRcbiAgICAgdmlhIFtQYWNrZWRJbnRBcnJheV0uICopXG5cbiAgdmFsIGdvdG86IFBhY2tlZEludEFycmF5LnQgKiBQYWNrZWRJbnRBcnJheS50XG5cbiAgKCogVGhlIG51bWJlciBvZiBzdGFydCBwcm9kdWN0aW9ucy4gQSBwcm9kdWN0aW9uIFtwcm9kXSBpcyBhIHN0YXJ0XG4gICAgIHByb2R1Y3Rpb24gaWYgYW5kIG9ubHkgaWYgW3Byb2QgPCBzdGFydF0gaG9sZHMuIFRoaXMgaXMgYWxzbyB0aGVcbiAgICAgbnVtYmVyIG9mIHN0YXJ0IHN5bWJvbHMuIEEgbm9udGVybWluYWwgc3ltYm9sIFtudF0gaXMgYSBzdGFydFxuICAgICBzeW1ib2wgaWYgYW5kIG9ubHkgaWYgW250IDwgc3RhcnRdIGhvbGRzLiAqKVxuXG4gIHZhbCBzdGFydDogaW50XG5cbiAgKCogQSBvbmUtZGltZW5zaW9uYWwgc2VtYW50aWMgYWN0aW9uIHRhYmxlIG1hcHMgcHJvZHVjdGlvbnMgdG8gc2VtYW50aWNcbiAgICAgYWN0aW9ucy4gVGhlIGNhbGxpbmcgY29udmVudGlvbiBmb3Igc2VtYW50aWMgYWN0aW9ucyBpcyBkZXNjcmliZWQgaW5cbiAgICAgW0VuZ2luZVR5cGVzXS4gVGhpcyB0YWJsZSBjb250YWlucyBPTkxZIE5PTi1TVEFSVCBQUk9EVUNUSU9OUywgc28gdGhlXG4gICAgIGluZGV4aW5nIGlzIG9mZiBieSBbc3RhcnRdLiBCZSBjYXJlZnVsLiAqKVxuXG4gIHZhbCBzZW1hbnRpY19hY3Rpb246ICgoaW50LCBPYmoudCwgdG9rZW4pIEVuZ2luZVR5cGVzLmVudiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgKGludCwgT2JqLnQpICAgICAgICBFbmdpbmVUeXBlcy5zdGFjaykgYXJyYXlcblxuICAoKiBUaGUgcGFyc2VyIGRlZmluZXMgaXRzIG93biBbRXJyb3JdIGV4Y2VwdGlvbi4gVGhpcyBleGNlcHRpb24gY2FuIGJlXG4gICAgIHJhaXNlZCBieSBzZW1hbnRpYyBhY3Rpb25zIGFuZCBjYXVnaHQgYnkgdGhlIGVuZ2luZSwgYW5kIHJhaXNlZCBieSB0aGVcbiAgICAgZW5naW5lIHRvd2FyZHMgdGhlIGZpbmFsIHVzZXIuICopXG5cbiAgZXhjZXB0aW9uIEVycm9yXG5cbiAgKCogVGhlIHBhcnNlciBpbmRpY2F0ZXMgd2hldGhlciB0byBnZW5lcmF0ZSBhIHRyYWNlLiBHZW5lcmF0aW5nIGFcbiAgICAgdHJhY2UgcmVxdWlyZXMgdHdvIGV4dHJhIHRhYmxlcywgd2hpY2ggcmVzcGVjdGl2ZWx5IG1hcCBhXG4gICAgIHRlcm1pbmFsIHN5bWJvbCBhbmQgYSBwcm9kdWN0aW9uIHRvIGEgc3RyaW5nLiAqKVxuXG4gIHZhbCB0cmFjZTogKHN0cmluZyBhcnJheSAqIHN0cmluZyBhcnJheSkgb3B0aW9uXG5cbmVuZFxuZW5kXG5tb2R1bGUgSW5zcGVjdGlvblRhYmxlRm9ybWF0ID0gc3RydWN0XG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVuaGlyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgSW5yaWEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciAgICAgKilcbigqICAgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGlicmFyeSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMiwgd2l0aCBhICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcsIGFzIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoaXMgc2lnbmF0dXJlIGRlZmluZXMgdGhlIGZvcm1hdCBvZiB0aGUgdGFibGVzIHRoYXQgYXJlIHByb2R1Y2VkIChpblxuICAgYWRkaXRpb24gdG8gdGhlIHRhYmxlcyBkZXNjcmliZWQgaW4gW1RhYmxlRm9ybWF0XSkgd2hlbiB0aGUgY29tbWFuZCBsaW5lXG4gICBzd2l0Y2ggWy0taW5zcGVjdGlvbl0gaXMgZW5hYmxlZC4gSXQgaXMgdXNlZCBhcyBhbiBhcmd1bWVudCB0b1xuICAgW0luc3BlY3Rpb25UYWJsZUludGVycHJldGVyLk1ha2VdLiAqKVxuXG5tb2R1bGUgdHlwZSBUQUJMRVMgPSBzaWdcblxuICAoKiBUaGUgdHlwZXMgb2Ygc3ltYm9scy4gKilcblxuICBpbmNsdWRlIEluY3JlbWVudGFsRW5naW5lLlNZTUJPTFNcblxuICAoKiBUaGUgdHlwZSBbJ2EgbHIxc3RhdGVdIGRlc2NyaWJlcyBhbiBMUigxKSBzdGF0ZS4gVGhlIGdlbmVyYXRlZCBwYXJzZXIgZGVmaW5lc1xuICAgICBpdCBpbnRlcm5hbGx5IGFzIFtpbnRdLiAqKVxuXG4gIHR5cGUgJ2EgbHIxc3RhdGVcblxuICAoKiBTb21lIG9mIHRoZSB0YWJsZXMgdGhhdCBmb2xsb3cgdXNlIGVuY29kaW5ncyBvZiAodGVybWluYWwgYW5kXG4gICAgIG5vbnRlcm1pbmFsKSBzeW1ib2xzIGFzIGludGVnZXJzLiBTbywgd2UgbmVlZCBmdW5jdGlvbnMgdGhhdFxuICAgICBtYXAgdGhlIGludGVnZXIgZW5jb2Rpbmcgb2YgYSBzeW1ib2wgdG8gaXRzIGFsZ2VicmFpYyBlbmNvZGluZy4gKilcblxuICB2YWwgICAgdGVybWluYWw6IGludCAtPiB4c3ltYm9sXG4gIHZhbCBub250ZXJtaW5hbDogaW50IC0+IHhzeW1ib2xcblxuICAoKiBUaGUgbGVmdC1oYW5kIHNpZGUgb2YgZXZlcnkgcHJvZHVjdGlvbiBhbHJlYWR5IGFwcGVhcnMgaW4gdGhlXG4gICAgIHNpZ25hdHVyZSBbVGFibGVGb3JtYXQuVEFCTEVTXSwgc28gd2UgbmVlZCBub3QgcmVwZWF0IGl0IGhlcmUuICopXG5cbiAgKCogVGhlIHJpZ2h0LWhhbmQgc2lkZSBvZiBldmVyeSBwcm9kdWN0aW9uLiBUaGlzIGEgbGluZWFyaXplZCBhcnJheVxuICAgICBvZiBhcnJheXMgb2YgaW50ZWdlcnMsIHdob3NlIFtkYXRhXSBhbmQgW2VudHJ5XSBjb21wb25lbnRzIGhhdmVcbiAgICAgYmVlbiBwYWNrZWQuIFRoZSBlbmNvZGluZyBvZiBzeW1ib2xzIGFzIGludGVnZXJzIGluIGRlc2NyaWJlZCBpblxuICAgICBbVGFibGVCYWNrZW5kXS4gKilcblxuICB2YWwgcmhzOiBQYWNrZWRJbnRBcnJheS50ICogUGFja2VkSW50QXJyYXkudFxuXG4gICgqIEEgbWFwcGluZyBvZiBldmVyeSAobm9uLWluaXRpYWwpIHN0YXRlIHRvIGl0cyBMUigwKSBjb3JlLiAqKVxuXG4gIHZhbCBscjBfY29yZTogUGFja2VkSW50QXJyYXkudFxuXG4gICgqIEEgbWFwcGluZyBvZiBldmVyeSBMUigwKSBzdGF0ZSB0byBpdHMgc2V0IG9mIExSKDApIGl0ZW1zLiBFYWNoIGl0ZW0gaXNcbiAgICAgcmVwcmVzZW50ZWQgaW4gaXRzIHBhY2tlZCBmb3JtIChzZWUgW0l0ZW1dKSBhcyBhbiBpbnRlZ2VyLiBUaHVzIHRoZVxuICAgICBtYXBwaW5nIGlzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBpbnRlZ2Vycywgd2hpY2ggaXMgbGluZWFyaXplZCBhbmRcbiAgICAgcGFja2VkLCBsaWtlIFtyaHNdLiAqKVxuXG4gIHZhbCBscjBfaXRlbXM6IFBhY2tlZEludEFycmF5LnQgKiBQYWNrZWRJbnRBcnJheS50XG5cbiAgKCogQSBtYXBwaW5nIG9mIGV2ZXJ5IExSKDApIHN0YXRlIHRvIGl0cyBpbmNvbWluZyBzeW1ib2wsIGlmIGl0IGhhcyBvbmUuICopXG5cbiAgdmFsIGxyMF9pbmNvbWluZzogUGFja2VkSW50QXJyYXkudFxuXG4gICgqIEEgdGFibGUgdGhhdCB0ZWxscyB3aGljaCBub24tdGVybWluYWwgc3ltYm9scyBhcmUgbnVsbGFibGUuICopXG5cbiAgdmFsIG51bGxhYmxlOiBzdHJpbmdcbiAgICAoKiBUaGlzIGlzIGEgcGFja2VkIGludCBhcnJheSBvZiBiaXQgd2lkdGggMS4gSXQgY2FuIGJlIHJlYWRcbiAgICAgICB1c2luZyBbUGFja2VkSW50QXJyYXkuZ2V0MV0uICopXG5cbiAgKCogQSB0d28tdGFibGUgZGltZW5zaW9uYWwgdGFibGUsIGluZGV4ZWQgYnkgYSBub250ZXJtaW5hbCBzeW1ib2wgYW5kXG4gICAgIGJ5IGEgdGVybWluYWwgc3ltYm9sIChvdGhlciB0aGFuIFsjXSksIGVuY29kZXMgdGhlIEZJUlNUIHNldHMuICopXG5cbiAgdmFsIGZpcnN0OiBpbnQgKCogd2lkdGggb2YgdGhlIGJpdG1hcCAqKSAqIHN0cmluZyAoKiBzZWNvbmQgY29tcG9uZW50IG9mIFtQYWNrZWRJbnRBcnJheS50XSAqKVxuXG5lbmRcblxuZW5kXG5tb2R1bGUgSW5zcGVjdGlvblRhYmxlSW50ZXJwcmV0ZXIgPSBzdHJ1Y3RcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZW5oaXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCBJbnJpYS4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyICAgICAqKVxuKCogICB0aGUgdGVybXMgb2YgdGhlIEdOVSBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLCB3aXRoIGEgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZywgYXMgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKilcblxuKCogVGhlIHR5cGUgZnVuY3Rvci4gKilcblxubW9kdWxlIFN5bWJvbHMgKFQgOiBzaWdcblxuICB0eXBlICdhIHRlcm1pbmFsXG4gIHR5cGUgJ2Egbm9udGVybWluYWxcblxuZW5kKSA9IHN0cnVjdFxuXG4gIG9wZW4gVFxuXG4gICgqIFRoaXMgc2hvdWxkIGJlIHRoZSBvbmx5IHBsYWNlIGluIHRoZSB3aG9sZSBsaWJyYXJ5IChhbmQgZ2VuZXJhdG9yISlcbiAgICAgd2hlcmUgdGhlc2UgdHlwZXMgYXJlIGRlZmluZWQuICopXG5cbiAgdHlwZSAnYSBzeW1ib2wgPVxuICAgIHwgVCA6ICdhIHRlcm1pbmFsIC0+ICdhIHN5bWJvbFxuICAgIHwgTiA6ICdhIG5vbnRlcm1pbmFsIC0+ICdhIHN5bWJvbFxuXG4gIHR5cGUgeHN5bWJvbCA9XG4gICAgfCBYIDogJ2Egc3ltYm9sIC0+IHhzeW1ib2xcblxuZW5kXG5cbigqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICopXG5cbigqIFRoZSBjb2RlIGZ1bmN0b3IuICopXG5cbm1vZHVsZSBNYWtlXG4gIChUVCA6IFRhYmxlRm9ybWF0LlRBQkxFUylcbiAgKElUIDogSW5zcGVjdGlvblRhYmxlRm9ybWF0LlRBQkxFU1xuICAgICAgICB3aXRoIHR5cGUgJ2EgbHIxc3RhdGUgPSBpbnQpXG4gIChFVCA6IEVuZ2luZVR5cGVzLlRBQkxFXG4gICAgICAgIHdpdGggdHlwZSB0ZXJtaW5hbCA9IGludFxuICAgICAgICAgYW5kIHR5cGUgbm9udGVybWluYWwgPSBpbnRcbiAgICAgICAgIGFuZCB0eXBlIHNlbWFudGljX3ZhbHVlID0gT2JqLnQpXG4gIChFIDogc2lnXG4gICAgIHR5cGUgJ2EgZW52ID0gKEVULnN0YXRlLCBFVC5zZW1hbnRpY192YWx1ZSwgRVQudG9rZW4pIEVuZ2luZVR5cGVzLmVudlxuICAgZW5kKVxuPSBzdHJ1Y3RcblxuICAoKiBJbmNsdWRpbmcgW0lUXSBpcyBhbiBlYXN5IHdheSBvZiBpbmhlcml0aW5nIHRoZSBkZWZpbml0aW9ucyBvZiB0aGUgdHlwZXNcbiAgICAgW3N5bWJvbF0gYW5kIFt4c3ltYm9sXS4gKilcblxuICBpbmNsdWRlIElUXG5cbiAgKCogVGhpcyBhdXhpbGlhcnkgZnVuY3Rpb24gZGVjb2RlcyBhIHBhY2tlZCBsaW5lYXJpemVkIGFycmF5LCBhcyBjcmVhdGVkIGJ5XG4gICAgIFtUYWJsZUJhY2tlbmQubGluZWFyaXplX2FuZF9tYXJzaGFsMV0uIEhlcmUsIHdlIHJlYWQgYSByb3cgYWxsIGF0IG9uY2UuICopXG5cbiAgbGV0IHJlYWRfcGFja2VkX2xpbmVhcml6ZWRcbiAgICAoZGF0YSwgZW50cnkgOiBQYWNrZWRJbnRBcnJheS50ICogUGFja2VkSW50QXJyYXkudCkgKGkgOiBpbnQpIDogaW50IGxpc3RcbiAgPVxuICAgIExpbmVhcml6ZWRBcnJheS5yZWFkX3Jvd192aWFcbiAgICAgIChQYWNrZWRJbnRBcnJheS5nZXQgZGF0YSlcbiAgICAgIChQYWNrZWRJbnRBcnJheS5nZXQgZW50cnkpXG4gICAgICBpXG5cbiAgKCogVGhpcyBhdXhpbGlhcnkgZnVuY3Rpb24gZGVjb2RlcyBhIHN5bWJvbC4gVGhlIGVuY29kaW5nIHdhcyBkb25lIGJ5XG4gICAgIFtlbmNvZGVfc3ltYm9sXSBvciBbZW5jb2RlX3N5bWJvbF9vcHRpb25dIGluIHRoZSB0YWJsZSBiYWNrLWVuZC4gKilcblxuICBsZXQgZGVjb2RlX3N5bWJvbCAoc3ltYm9sIDogaW50KSA6IElULnhzeW1ib2wgPVxuICAgICgqIElmIFtzeW1ib2xdIGlzIDAsIHRoZW4gd2UgaGF2ZSBubyBzeW1ib2wuIFRoaXMgY291bGQgbWVhbiBlLmcuXG4gICAgICAgdGhhdCB0aGUgZnVuY3Rpb24gW2luY29taW5nX3N5bWJvbF0gaGFzIGJlZW4gYXBwbGllZCB0byBhblxuICAgICAgIGluaXRpYWwgc3RhdGUuIEluIHByaW5jaXBsZSwgdGhpcyBjYW5ub3QgaGFwcGVuLiAqKVxuICAgIGFzc2VydCAoc3ltYm9sID4gMCk7XG4gICAgKCogVGhlIGxvdy1vcmRlciBiaXQgZGlzdGluZ3Vpc2hlcyB0ZXJtaW5hbCBhbmQgbm9udGVybWluYWwgc3ltYm9scy4gKilcbiAgICBsZXQga2luZCA9IHN5bWJvbCBsYW5kIDEgaW5cbiAgICBsZXQgc3ltYm9sID0gc3ltYm9sIGxzciAxIGluXG4gICAgaWYga2luZCA9IDAgdGhlblxuICAgICAgSVQudGVybWluYWwgKHN5bWJvbCAtIDEpXG4gICAgZWxzZVxuICAgICAgSVQubm9udGVybWluYWwgc3ltYm9sXG5cbiAgKCogVGhlc2UgYXV4aWxpYXJ5IGZ1bmN0aW9ucyBjb252ZXJ0IGEgc3ltYm9sIHRvIGl0cyBpbnRlZ2VyIGNvZGUuIEZvciBzcGVlZFxuICAgICBhbmQgZm9yIGNvbnZlbmllbmNlLCB3ZSB1c2UgYW4gdW5zYWZlIHR5cGUgY2FzdC4gVGhpcyByZWxpZXMgb24gdGhlIGZhY3RcbiAgICAgdGhhdCB0aGUgZGF0YSBjb25zdHJ1Y3RvcnMgb2YgdGhlIFt0ZXJtaW5hbF0gYW5kIFtub250ZXJtaW5hbF0gR0FEVHMgYXJlXG4gICAgIGRlY2xhcmVkIGluIGFuIG9yZGVyIHRoYXQgcmVmbGVjdHMgdGhlaXIgaW50ZXJuYWwgY29kZS4gSW4gdGhlIGNhc2Ugb2ZcbiAgICAgbm9udGVybWluYWwgc3ltYm9scywgd2UgYWRkIFtzdGFydF0gdG8gYWNjb3VudCBmb3IgdGhlIHByZXNlbmNlIG9mIHRoZVxuICAgICBzdGFydCBzeW1ib2xzLiAqKVxuXG4gIGxldCBuMmkgKG50IDogJ2EgSVQubm9udGVybWluYWwpIDogaW50ID1cbiAgICBsZXQgYW5zd2VyID0gVFQuc3RhcnQgKyBPYmoubWFnaWMgbnQgaW5cbiAgICAoKiBGb3Igc2FmZXR5LCBjaGVjayB0aGF0IHRoZSBhYm92ZSBjYXN0IHByb2R1Y2VkIGEgY29ycmVjdCByZXN1bHQuICopXG4gICAgYXNzZXJ0IChJVC5ub250ZXJtaW5hbCBhbnN3ZXIgPSBYIChOIG50KSk7XG4gICAgYW5zd2VyXG5cbiAgbGV0IHQyaSAodCA6ICdhIElULnRlcm1pbmFsKSA6IGludCA9XG4gICAgbGV0IGFuc3dlciA9IE9iai5tYWdpYyB0IGluXG4gICAgKCogRm9yIHNhZmV0eSwgY2hlY2sgdGhhdCB0aGUgYWJvdmUgY2FzdCBwcm9kdWNlZCBhIGNvcnJlY3QgcmVzdWx0LiAqKVxuICAgIGFzc2VydCAoSVQudGVybWluYWwgYW5zd2VyID0gWCAoVCB0KSk7XG4gICAgYW5zd2VyXG5cbiAgKCogT3JkZXJpbmcgZnVuY3Rpb25zLiAqKVxuXG4gIGxldCBjb21wYXJlX3Rlcm1pbmFscyB0MSB0MiA9XG4gICAgKCogU3VidHJhY3Rpb24gaXMgc2FmZSBiZWNhdXNlIG92ZXJmbG93IGlzIGltcG9zc2libGUuICopXG4gICAgdDJpIHQxIC0gdDJpIHQyXG5cbiAgbGV0IGNvbXBhcmVfbm9udGVybWluYWxzIG50MSBudDIgPVxuICAgICgqIFN1YnRyYWN0aW9uIGlzIHNhZmUgYmVjYXVzZSBvdmVyZmxvdyBpcyBpbXBvc3NpYmxlLiAqKVxuICAgIG4yaSBudDEgLSBuMmkgbnQyXG5cbiAgbGV0IGNvbXBhcmVfc3ltYm9scyBzeW1ib2wxIHN5bWJvbDIgPVxuICAgIG1hdGNoIHN5bWJvbDEsIHN5bWJvbDIgd2l0aFxuICAgIHwgWCAoVCBfKSwgWCAoTiBfKSAtPlxuICAgICAgICAtMVxuICAgIHwgWCAoTiBfKSwgWCAoVCBfKSAtPlxuICAgICAgICAxXG4gICAgfCBYIChUIHQxKSwgWCAoVCB0MikgLT5cbiAgICAgICAgY29tcGFyZV90ZXJtaW5hbHMgdDEgdDJcbiAgICB8IFggKE4gbnQxKSwgWCAoTiBudDIpIC0+XG4gICAgICAgIGNvbXBhcmVfbm9udGVybWluYWxzIG50MSBudDJcblxuICBsZXQgY29tcGFyZV9wcm9kdWN0aW9ucyBwcm9kMSBwcm9kMiA9XG4gICAgKCogU3VidHJhY3Rpb24gaXMgc2FmZSBiZWNhdXNlIG92ZXJmbG93IGlzIGltcG9zc2libGUuICopXG4gICAgcHJvZDEgLSBwcm9kMlxuXG4gIGxldCBjb21wYXJlX2l0ZW1zIChwcm9kMSwgaW5kZXgxKSAocHJvZDIsIGluZGV4MikgPVxuICAgIGxldCBjID0gY29tcGFyZV9wcm9kdWN0aW9ucyBwcm9kMSBwcm9kMiBpblxuICAgICgqIFN1YnRyYWN0aW9uIGlzIHNhZmUgYmVjYXVzZSBvdmVyZmxvdyBpcyBpbXBvc3NpYmxlLiAqKVxuICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZSBpbmRleDEgLSBpbmRleDJcblxuICAoKiBUaGUgZnVuY3Rpb24gW2luY29taW5nX3N5bWJvbF0gZ29lcyB0aHJvdWdoIHRoZSB0YWJsZXMgW0lULmxyMF9jb3JlXSBhbmRcbiAgICAgW0lULmxyMF9pbmNvbWluZ10uIFRoaXMgeWllbGRzIGEgcmVwcmVzZW50YXRpb24gb2YgdHlwZSBbeHN5bWJvbF0sIG91dCBvZlxuICAgICB3aGljaCB3ZSBzdHJpcCB0aGUgW1hdIHF1YW50aWZpZXIsIHNvIGFzIHRvIGdldCBhIG5ha2VkIHN5bWJvbC4gVGhpcyBsYXN0XG4gICAgIHN0ZXAgaXMgaWxsLXR5cGVkIGFuZCBwb3RlbnRpYWxseSBkYW5nZXJvdXMuIEl0IGlzIHNhZmUgb25seSBiZWNhdXNlIHRoaXNcbiAgICAgZnVuY3Rpb24gaXMgdXNlZCBhdCB0eXBlIFsnYSBscjFzdGF0ZSAtPiAnYSBzeW1ib2xdLCB3aGljaCBmb3JjZXMgYW5cbiAgICAgYXBwcm9wcmlhdGUgY2hvaWNlIG9mIFsnYV0uICopXG5cbiAgbGV0IGluY29taW5nX3N5bWJvbCAocyA6ICdhIElULmxyMXN0YXRlKSA6ICdhIElULnN5bWJvbCA9XG4gICAgbGV0IGNvcmUgPSBQYWNrZWRJbnRBcnJheS5nZXQgSVQubHIwX2NvcmUgcyBpblxuICAgIGxldCBzeW1ib2wgPSBkZWNvZGVfc3ltYm9sIChQYWNrZWRJbnRBcnJheS5nZXQgSVQubHIwX2luY29taW5nIGNvcmUpIGluXG4gICAgbWF0Y2ggc3ltYm9sIHdpdGhcbiAgICB8IElULlggc3ltYm9sIC0+XG4gICAgICAgIE9iai5tYWdpYyBzeW1ib2xcblxuICAoKiBUaGUgZnVuY3Rpb24gW2xoc10gcmVhZHMgdGhlIHRhYmxlIFtUVC5saHNdIGFuZCB1c2VzIFtJVC5ub250ZXJtaW5hbF1cbiAgICAgdG8gZGVjb2RlIHRoZSBzeW1ib2wuICopXG5cbiAgbGV0IGxocyBwcm9kID1cbiAgICBJVC5ub250ZXJtaW5hbCAoUGFja2VkSW50QXJyYXkuZ2V0IFRULmxocyBwcm9kKVxuXG4gICgqIFRoZSBmdW5jdGlvbiBbcmhzXSByZWFkcyB0aGUgdGFibGUgW0lULnJoc10gYW5kIHVzZXMgW2RlY29kZV9zeW1ib2xdXG4gICAgIHRvIGRlY29kZSB0aGUgc3ltYm9sLiAqKVxuXG4gIGxldCByaHMgcHJvZCA9XG4gICAgTGlzdC5tYXAgZGVjb2RlX3N5bWJvbCAocmVhZF9wYWNrZWRfbGluZWFyaXplZCBJVC5yaHMgcHJvZClcblxuICAoKiBUaGUgZnVuY3Rpb24gW2l0ZW1zXSBtYXBzIHRoZSBMUigxKSBzdGF0ZSBbc10gdG8gaXRzIExSKDApIGNvcmUsXG4gICAgIHRoZW4gdXNlcyBbY29yZV0gYXMgYW4gaW5kZXggaW50byB0aGUgdGFibGUgW0lULmxyMF9pdGVtc10uIFRoZVxuICAgICBpdGVtcyBhcmUgdGhlbiBkZWNvZGVkIGJ5IHRoZSBmdW5jdGlvbiBbZXhwb3J0XSBiZWxvdywgd2hpY2ggaXNcbiAgICAgZXNzZW50aWFsbHkgYSBjb3B5IG9mIFtJdGVtLmV4cG9ydF0uICopXG5cbiAgdHlwZSBpdGVtID1cbiAgICAgIGludCAqIGludFxuXG4gIGxldCBsb3dfYml0cyA9XG4gICAgMTBcblxuICBsZXQgbG93X2xpbWl0ID1cbiAgICAxIGxzbCBsb3dfYml0c1xuXG4gIGxldCBleHBvcnQgdCA6IGl0ZW0gPVxuICAgICh0IGxzciBsb3dfYml0cywgdCBtb2QgbG93X2xpbWl0KVxuXG4gIGxldCBpdGVtcyBzID1cbiAgICAoKiBNYXAgW3NdIHRvIGl0cyBMUigwKSBjb3JlLiAqKVxuICAgIGxldCBjb3JlID0gUGFja2VkSW50QXJyYXkuZ2V0IElULmxyMF9jb3JlIHMgaW5cbiAgICAoKiBOb3cgdXNlIFtjb3JlXSB0byBsb29rIHVwIHRoZSB0YWJsZSBbSVQubHIwX2l0ZW1zXS4gKilcbiAgICBMaXN0Lm1hcCBleHBvcnQgKHJlYWRfcGFja2VkX2xpbmVhcml6ZWQgSVQubHIwX2l0ZW1zIGNvcmUpXG5cbiAgKCogVGhlIGZ1bmN0aW9uIFtudWxsYWJsZV0gbWFwcyB0aGUgbm9udGVybWluYWwgc3ltYm9sIFtudF0gdG8gaXRzXG4gICAgIGludGVnZXIgY29kZSwgd2hpY2ggaXQgdXNlcyB0byBsb29rIHVwIHRoZSBhcnJheSBbSVQubnVsbGFibGVdLlxuICAgICBUaGlzIHlpZWxkcyAwIG9yIDEsIHdoaWNoIHdlIG1hcCBiYWNrIHRvIGEgQm9vbGVhbiByZXN1bHQuICopXG5cbiAgbGV0IGRlY29kZV9ib29sIGkgPVxuICAgIGFzc2VydCAoaSA9IDAgfHwgaSA9IDEpO1xuICAgIGkgPSAxXG5cbiAgbGV0IG51bGxhYmxlIG50ID1cbiAgICBkZWNvZGVfYm9vbCAoUGFja2VkSW50QXJyYXkuZ2V0MSBJVC5udWxsYWJsZSAobjJpIG50KSlcblxuICAoKiBUaGUgZnVuY3Rpb24gW2ZpcnN0XSBtYXBzIHRoZSBzeW1ib2xzIFtudF0gYW5kIFt0XSB0byB0aGVpciBpbnRlZ2VyXG4gICAgIGNvZGVzLCB3aGljaCBpdCB1c2VzIHRvIGxvb2sgdXAgdGhlIG1hdHJpeCBbSVQuZmlyc3RdLiAqKVxuXG4gIGxldCBmaXJzdCBudCB0ID1cbiAgICBkZWNvZGVfYm9vbCAoUGFja2VkSW50QXJyYXkudW5mbGF0dGVuMSBJVC5maXJzdCAobjJpIG50KSAodDJpIHQpKVxuXG4gIGxldCB4Zmlyc3Qgc3ltYm9sIHQgPVxuICAgIG1hdGNoIHN5bWJvbCB3aXRoXG4gICAgfCBYIChUIHQnKSAtPlxuICAgICAgICBjb21wYXJlX3Rlcm1pbmFscyB0IHQnID0gMFxuICAgIHwgWCAoTiBudCkgLT5cbiAgICAgICAgZmlyc3QgbnQgdFxuXG4gICgqIFRoZSBmdW5jdGlvbiBbZm9yZWFjaF90ZXJtaW5hbF0gZXhwbG9pdHMgdGhlIGZhY3QgdGhhdCB0aGVcbiAgICAgZmlyc3QgY29tcG9uZW50IG9mIFtUVC5lcnJvcl0gaXMgW1Rlcm1pbmFsLm4gLSAxXSwgaS5lLiwgdGhlXG4gICAgIG51bWJlciBvZiB0ZXJtaW5hbCBzeW1ib2xzLCBpbmNsdWRpbmcgW2Vycm9yXSBidXQgbm90IFsjXS4gKilcblxuICBsZXQgcmVjIGZvbGRpaiBpIGogZiBhY2N1ID1cbiAgICBpZiBpID0gaiB0aGVuXG4gICAgICBhY2N1XG4gICAgZWxzZVxuICAgICAgZm9sZGlqIChpICsgMSkgaiBmIChmIGkgYWNjdSlcblxuICBsZXQgZm9yZWFjaF90ZXJtaW5hbCBmIGFjY3UgPVxuICAgIGxldCBuLCBfID0gVFQuZXJyb3IgaW5cbiAgICBmb2xkaWogMCBuIChmdW4gaSBhY2N1IC0+XG4gICAgICBmIChJVC50ZXJtaW5hbCBpKSBhY2N1XG4gICAgKSBhY2N1XG5cbiAgbGV0IGZvcmVhY2hfdGVybWluYWxfYnV0X2Vycm9yIGYgYWNjdSA9XG4gICAgbGV0IG4sIF8gPSBUVC5lcnJvciBpblxuICAgIGZvbGRpaiAwIG4gKGZ1biBpIGFjY3UgLT5cbiAgICAgIGlmIGkgPSBUVC5lcnJvcl90ZXJtaW5hbCB0aGVuXG4gICAgICAgIGFjY3VcbiAgICAgIGVsc2VcbiAgICAgICAgZiAoSVQudGVybWluYWwgaSkgYWNjdVxuICAgICkgYWNjdVxuXG4gICgqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqKVxuXG4gICgqIFRoZSBmb2xsb3dpbmcgaXMgdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBmdW5jdGlvbiBbZmVlZF0uIFRoaXMgZnVuY3Rpb25cbiAgICAgaXMgbG9naWNhbGx5IHBhcnQgb2YgdGhlIExSIGVuZ2luZSwgc28gaXQgd291bGQgYmUgbmljZSBpZiBpdCB3ZXJlIHBsYWNlZFxuICAgICBpbiB0aGUgbW9kdWxlIFtFbmdpbmVdLCBidXQgaXQgbXVzdCBiZSBwbGFjZWQgaGVyZSBiZWNhdXNlLCB0byBlbnN1cmVcbiAgICAgdHlwZSBzYWZldHksIGl0cyBhcmd1bWVudHMgbXVzdCBiZSBhIHN5bWJvbCBvZiB0eXBlIFsnYSBzeW1ib2xdIGFuZCBhXG4gICAgIHNlbWFudGljIHZhbHVlIG9mIHR5cGUgWydhXS4gVGhlIHR5cGUgWydhIHN5bWJvbF0gaXMgbm90IGF2YWlsYWJsZSBpblxuICAgICBbRW5naW5lXS4gSXQgaXMgYXZhaWxhYmxlIGhlcmUuICopXG5cbiAgb3BlbiBFbmdpbmVUeXBlc1xuICBvcGVuIEVUXG4gIG9wZW4gRVxuXG4gICgqIFtmZWVkXSBmYWlscyBpZiB0aGUgY3VycmVudCBzdGF0ZSBkb2VzIG5vdCBoYXZlIGFuIG91dGdvaW5nIHRyYW5zaXRpb25cbiAgICAgbGFiZWxlZCB3aXRoIHRoZSBkZXNpcmVkIHN5bWJvbC4gVGhpcyBjaGVjayBpcyBjYXJyaWVkIG91dCBhdCBydW50aW1lLiAqKVxuXG4gIGxldCBmZWVkX2ZhaWx1cmUgKCkgPVxuICAgIGludmFsaWRfYXJnIFwiZmVlZDogb3V0Z29pbmcgdHJhbnNpdGlvbiBkb2VzIG5vdCBleGlzdFwiXG5cbiAgKCogRmVlZGluZyBhIG5vbnRlcm1pbmFsIHN5bWJvbCBbbnRdLiBIZXJlLCBbbnRdIGhhcyB0eXBlIFtub250ZXJtaW5hbF0sXG4gICAgIHdoaWNoIGlzIGEgc3lub255bSBmb3IgW2ludF0sIGFuZCBbc2Vtdl0gaGFzIHR5cGUgW3NlbWFudGljX3ZhbHVlXSxcbiAgICAgd2hpY2ggaXMgYSBzeW5vbnltIGZvciBbT2JqLnRdLiBUaGlzIHR5cGUgaXMgdW5zYWZlLCBiZWNhdXNlIHB1c2hpbmdcbiAgICAgYSBzZW1hbnRpYyB2YWx1ZSBvZiBhcmJpdHJhcnkgdHlwZSBpbnRvIHRoZSBzdGFjayBjYW4gbGF0ZXIgY2F1c2UgYVxuICAgICBzZW1hbnRpYyBhY3Rpb24gdG8gY3Jhc2ggYW5kIGJ1cm4uIFRoZSBmdW5jdGlvbiBbZmVlZF0gaXMgZ2l2ZW4gYSBzYWZlXG4gICAgIHR5cGUgYmVsb3cuICopXG5cbiAgbGV0IGZlZWRfbm9udGVybWluYWxcbiAgICAgICAgKG50IDogbm9udGVybWluYWwpIHN0YXJ0cCAoc2VtdiA6IHNlbWFudGljX3ZhbHVlKSBlbmRwIChlbnYgOiAnYiBlbnYpXG4gICAgICA6ICdiIGVudlxuICA9XG4gICAgKCogQ2hlY2sgaWYgdGhlIHNvdXJjZSBzdGF0ZSBoYXMgYW4gb3V0Z29pbmcgdHJhbnNpdGlvbiBsYWJlbGVkIFtudF0uXG4gICAgICAgVGhpcyBpcyBkb25lIGJ5IGNvbnN1bHRpbmcgdGhlIFtnb3RvXSB0YWJsZS4gKilcbiAgICBsZXQgc291cmNlID0gZW52LmN1cnJlbnQgaW5cbiAgICBtYXRjaCBFVC5tYXliZV9nb3RvX250IHNvdXJjZSBudCB3aXRoXG4gICAgfCBOb25lIC0+XG4gICAgICAgIGZlZWRfZmFpbHVyZSgpXG4gICAgfCBTb21lIHRhcmdldCAtPlxuICAgICAgICAoKiBQdXNoIGEgbmV3IGNlbGwgb250byB0aGUgc3RhY2ssIGNvbnRhaW5pbmcgdGhlIGlkZW50aXR5IG9mIHRoZSBzdGF0ZVxuICAgICAgICAgICB0aGF0IHdlIGFyZSBsZWF2aW5nLiBUaGUgc2VtYW50aWMgdmFsdWUgW3NlbXZdIGFuZCBwb3NpdGlvbnMgW3N0YXJ0cF1cbiAgICAgICAgICAgYW5kIFtlbmRwXSBjb250YWluZWQgaW4gdGhlIG5ldyBjZWxsIGFyZSBwcm92aWRlZCBieSB0aGUgY2FsbGVyLiAqKVxuICAgICAgICBsZXQgc3RhY2sgPSB7IHN0YXRlID0gc291cmNlOyBzZW12OyBzdGFydHA7IGVuZHA7IG5leHQgPSBlbnYuc3RhY2sgfSBpblxuICAgICAgICAoKiBNb3ZlIHRvIHRoZSB0YXJnZXQgc3RhdGUuICopXG4gICAgICAgIHsgZW52IHdpdGggc3RhY2s7IGN1cnJlbnQgPSB0YXJnZXQgfVxuXG4gIGxldCByZWR1Y2UgICBfZW52IF9wcm9kID0gZmVlZF9mYWlsdXJlKClcbiAgbGV0IGluaXRpYXRlIF9lbnYgICAgICAgPSBmZWVkX2ZhaWx1cmUoKVxuXG4gIGxldCBmZWVkX3Rlcm1pbmFsXG4gICAgICAgICh0ZXJtaW5hbCA6IHRlcm1pbmFsKSBzdGFydHAgKHNlbXYgOiBzZW1hbnRpY192YWx1ZSkgZW5kcCAoZW52IDogJ2IgZW52KVxuICAgICAgOiAnYiBlbnZcbiAgPVxuICAgICgqIENoZWNrIGlmIHRoZSBzb3VyY2Ugc3RhdGUgaGFzIGFuIG91dGdvaW5nIHRyYW5zaXRpb24gbGFiZWxlZCBbdGVybWluYWxdLlxuICAgICAgIFRoaXMgaXMgZG9uZSBieSBjb25zdWx0aW5nIHRoZSBbYWN0aW9uXSB0YWJsZS4gKilcbiAgICBsZXQgc291cmNlID0gZW52LmN1cnJlbnQgaW5cbiAgICBFVC5hY3Rpb24gc291cmNlIHRlcm1pbmFsIHNlbXZcbiAgICAgIChmdW4gZW52IF9wbGVhc2VfZGlzY2FyZCBfdGVybWluYWwgc2VtdiB0YXJnZXQgLT5cbiAgICAgICAgKCogVGhlcmUgaXMgaW5kZWVkIGEgdHJhbnNpdGlvbiB0b3dhcmQgdGhlIHN0YXRlIFt0YXJnZXRdLlxuICAgICAgICAgICBQdXNoIGEgbmV3IGNlbGwgb250byB0aGUgc3RhY2sgYW5kIG1vdmUgdG8gdGhlIHRhcmdldCBzdGF0ZS4gKilcbiAgICAgICAgbGV0IHN0YWNrID0geyBzdGF0ZSA9IHNvdXJjZTsgc2Vtdjsgc3RhcnRwOyBlbmRwOyBuZXh0ID0gZW52LnN0YWNrIH0gaW5cbiAgICAgICAgeyBlbnYgd2l0aCBzdGFjazsgY3VycmVudCA9IHRhcmdldCB9XG4gICAgICApIHJlZHVjZSBpbml0aWF0ZSBlbnZcblxuICAoKiBUaGUgdHlwZSBhc3NpZ25lZCB0byBbZmVlZF0gZW5zdXJlcyB0aGF0IHRoZSB0eXBlIG9mIHRoZSBzZW1hbnRpYyB2YWx1ZVxuICAgICBbc2Vtdl0gaXMgYXBwcm9wcmlhdGU6IGl0IG11c3QgYmUgdGhlIHNlbWFudGljLXZhbHVlIHR5cGUgb2YgdGhlIHN5bWJvbFxuICAgICBbc3ltYm9sXS4gKilcblxuICBsZXQgZmVlZCAoc3ltYm9sIDogJ2Egc3ltYm9sKSBzdGFydHAgKHNlbXYgOiAnYSkgZW5kcCBlbnYgPVxuICAgIGxldCBzZW12IDogc2VtYW50aWNfdmFsdWUgPSBPYmoucmVwciBzZW12IGluXG4gICAgbWF0Y2ggc3ltYm9sIHdpdGhcbiAgICB8IE4gbnQgLT5cbiAgICAgICAgZmVlZF9ub250ZXJtaW5hbCAobjJpIG50KSBzdGFydHAgc2VtdiBlbmRwIGVudlxuICAgIHwgVCB0ZXJtaW5hbCAtPlxuICAgICAgICBmZWVkX3Rlcm1pbmFsICh0MmkgdGVybWluYWwpIHN0YXJ0cCBzZW12IGVuZHAgZW52XG5cbmVuZFxuZW5kXG5tb2R1bGUgVGFibGVJbnRlcnByZXRlciA9IHN0cnVjdFxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lbmhpciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IElucmlhLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgICAgICopXG4oKiAgIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExpYnJhcnkgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIsIHdpdGggYSAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nLCBhcyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgTWFrZUVuZ2luZVRhYmxlIChUIDogVGFibGVGb3JtYXQuVEFCTEVTKSA9IHN0cnVjdFxuXG4gIHR5cGUgc3RhdGUgPVxuICAgICAgaW50XG5cbiAgbGV0IG51bWJlciBzID0gc1xuXG4gIHR5cGUgdG9rZW4gPVxuICAgICAgVC50b2tlblxuXG4gIHR5cGUgdGVybWluYWwgPVxuICAgICAgaW50XG5cbiAgdHlwZSBub250ZXJtaW5hbCA9XG4gICAgICBpbnRcblxuICB0eXBlIHNlbWFudGljX3ZhbHVlID1cbiAgICAgIE9iai50XG5cbiAgbGV0IHRva2VuMnRlcm1pbmFsID1cbiAgICBULnRva2VuMnRlcm1pbmFsXG5cbiAgbGV0IHRva2VuMnZhbHVlID1cbiAgICBULnRva2VuMnZhbHVlXG5cbiAgbGV0IGVycm9yX3Rlcm1pbmFsID1cbiAgICBULmVycm9yX3Rlcm1pbmFsXG5cbiAgbGV0IGVycm9yX3ZhbHVlID1cbiAgICBPYmoucmVwciAoKVxuXG4gICgqIFRoZSBmdW5jdGlvbiBbZm9yZWFjaF90ZXJtaW5hbF0gZXhwbG9pdHMgdGhlIGZhY3QgdGhhdCB0aGVcbiAgICAgZmlyc3QgY29tcG9uZW50IG9mIFtULmVycm9yXSBpcyBbVGVybWluYWwubiAtIDFdLCBpLmUuLCB0aGVcbiAgICAgbnVtYmVyIG9mIHRlcm1pbmFsIHN5bWJvbHMsIGluY2x1ZGluZyBbZXJyb3JdIGJ1dCBub3QgWyNdLiAqKVxuXG4gICgqIFRoZXJlIGlzIHNpbWlsYXIgY29kZSBpbiBbSW5zcGVjdGlvblRhYmxlSW50ZXJwcmV0ZXJdLiBUaGVcbiAgICAgY29kZSB0aGVyZSBjb250YWlucyBhbiBhZGRpdGlvbmFsIGNvbnZlcnNpb24gb2YgdGhlIHR5cGVcbiAgICAgW3Rlcm1pbmFsXSB0byB0aGUgdHlwZSBbeHN5bWJvbF0uICopXG5cbiAgbGV0IHJlYyBmb2xkaWogaSBqIGYgYWNjdSA9XG4gICAgaWYgaSA9IGogdGhlblxuICAgICAgYWNjdVxuICAgIGVsc2VcbiAgICAgIGZvbGRpaiAoaSArIDEpIGogZiAoZiBpIGFjY3UpXG5cbiAgbGV0IGZvcmVhY2hfdGVybWluYWwgZiBhY2N1ID1cbiAgICBsZXQgbiwgXyA9IFQuZXJyb3IgaW5cbiAgICBmb2xkaWogMCBuIChmdW4gaSBhY2N1IC0+XG4gICAgICBmIGkgYWNjdVxuICAgICkgYWNjdVxuXG4gIHR5cGUgcHJvZHVjdGlvbiA9XG4gICAgICBpbnRcblxuICAoKiBJbiBwcmluY2lwbGUsIG9ubHkgbm9uLXN0YXJ0IHByb2R1Y3Rpb25zIGFyZSBleHBvc2VkIHRvIHRoZSB1c2VyLFxuICAgICBhdCB0eXBlIFtwcm9kdWN0aW9uXSBvciBhdCB0eXBlIFtpbnRdLiBUaGlzIGlzIGNoZWNrZWQgZHluYW1pY2FsbHkuICopXG4gIGxldCBub25fc3RhcnRfcHJvZHVjdGlvbiBpID1cbiAgICBhc3NlcnQgKFQuc3RhcnQgPD0gaSAmJiBpIC0gVC5zdGFydCA8IEFycmF5Lmxlbmd0aCBULnNlbWFudGljX2FjdGlvbilcblxuICBsZXQgcHJvZHVjdGlvbl9pbmRleCBpID1cbiAgICBub25fc3RhcnRfcHJvZHVjdGlvbiBpO1xuICAgIGlcblxuICBsZXQgZmluZF9wcm9kdWN0aW9uIGkgPVxuICAgIG5vbl9zdGFydF9wcm9kdWN0aW9uIGk7XG4gICAgaVxuXG4gIGxldCBkZWZhdWx0X3JlZHVjdGlvbiBzdGF0ZSBkZWZyZWQgbm9kZWZyZWQgZW52ID1cbiAgICBsZXQgY29kZSA9IFBhY2tlZEludEFycmF5LmdldCBULmRlZmF1bHRfcmVkdWN0aW9uIHN0YXRlIGluXG4gICAgaWYgY29kZSA9IDAgdGhlblxuICAgICAgKCogbm8gZGVmYXVsdCByZWR1Y3Rpb24gKilcbiAgICAgIG5vZGVmcmVkIGVudlxuICAgIGVsc2VcbiAgICAgICgqIGRlZmF1bHQgcmVkdWN0aW9uICopXG4gICAgICBsZXQgcHJvZCA9IGNvZGUgLSAxIGluXG4gICAgICBkZWZyZWQgZW52IHByb2RcblxuICBsZXQgaXNfc3RhcnQgcHJvZCA9XG4gICAgcHJvZCA8IFQuc3RhcnRcblxuICAoKiBUaGlzIGF1eGlsaWFyeSBmdW5jdGlvbiBoZWxwcyBhY2Nlc3MgYSBjb21wcmVzc2VkLCB0d28tZGltZW5zaW9uYWxcbiAgICAgbWF0cml4LCBsaWtlIHRoZSBhY3Rpb24gYW5kIGdvdG8gdGFibGVzLiAqKVxuXG4gIGxldCB1bm1hcnNoYWwyIHRhYmxlIGkgaiA9XG4gICAgUm93RGlzcGxhY2VtZW50LmdldGdldFxuICAgICAgUGFja2VkSW50QXJyYXkuZ2V0XG4gICAgICBQYWNrZWRJbnRBcnJheS5nZXRcbiAgICAgIHRhYmxlXG4gICAgICBpIGpcblxuICBsZXQgYWN0aW9uIHN0YXRlIHRlcm1pbmFsIHZhbHVlIHNoaWZ0IHJlZHVjZSBmYWlsIGVudiA9XG4gICAgbWF0Y2ggUGFja2VkSW50QXJyYXkudW5mbGF0dGVuMSBULmVycm9yIHN0YXRlIHRlcm1pbmFsIHdpdGhcbiAgICB8IDEgLT5cbiAgICAgICAgbGV0IGFjdGlvbiA9IHVubWFyc2hhbDIgVC5hY3Rpb24gc3RhdGUgdGVybWluYWwgaW5cbiAgICAgICAgbGV0IG9wY29kZSA9IGFjdGlvbiBsYW5kIDBiMTFcbiAgICAgICAgYW5kIHBhcmFtID0gYWN0aW9uIGxzciAyIGluXG4gICAgICAgIGlmIG9wY29kZSA+PSAwYjEwIHRoZW5cbiAgICAgICAgICAoKiAwYjEwIDogc2hpZnQvZGlzY2FyZCAqKVxuICAgICAgICAgICgqIDBiMTEgOiBzaGlmdC9ub2Rpc2NhcmQgKilcbiAgICAgICAgICBsZXQgcGxlYXNlX2Rpc2NhcmQgPSAob3Bjb2RlID0gMGIxMCkgaW5cbiAgICAgICAgICBzaGlmdCBlbnYgcGxlYXNlX2Rpc2NhcmQgdGVybWluYWwgdmFsdWUgcGFyYW1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICgqIDBiMDEgOiByZWR1Y2UgKilcbiAgICAgICAgICAoKiAwYjAwIDogY2Fubm90IGhhcHBlbiAqKVxuICAgICAgICAgIHJlZHVjZSBlbnYgcGFyYW1cbiAgICB8IGMgLT5cbiAgICAgICAgYXNzZXJ0IChjID0gMCk7XG4gICAgICAgIGZhaWwgZW52XG5cbiAgbGV0IG1heWJlX3NoaWZ0X3Qgc3RhdGUgdGVybWluYWwgPVxuICAgIG1hdGNoIFBhY2tlZEludEFycmF5LnVuZmxhdHRlbjEgVC5lcnJvciBzdGF0ZSB0ZXJtaW5hbCB3aXRoXG4gICAgfCAxIC0+XG4gICAgICAgIGxldCBhY3Rpb24gPSB1bm1hcnNoYWwyIFQuYWN0aW9uIHN0YXRlIHRlcm1pbmFsIGluXG4gICAgICAgIGxldCBvcGNvZGUgPSBhY3Rpb24gbGFuZCAwYjExIGluXG4gICAgICAgIGlmIG9wY29kZSA+PSAwYjEwIHRoZW5cbiAgICAgICAgICAoKiAwYjEwIDogc2hpZnQvZGlzY2FyZCAqKVxuICAgICAgICAgICgqIDBiMTEgOiBzaGlmdC9ub2Rpc2NhcmQgKilcbiAgICAgICAgICBsZXQgc3RhdGUnID0gYWN0aW9uIGxzciAyIGluXG4gICAgICAgICAgU29tZSBzdGF0ZSdcbiAgICAgICAgZWxzZVxuICAgICAgICAgICgqIDBiMDEgOiByZWR1Y2UgKilcbiAgICAgICAgICAoKiAwYjAwIDogY2Fubm90IGhhcHBlbiAqKVxuICAgICAgICAgIE5vbmVcbiAgICB8IGMgLT5cbiAgICAgICAgYXNzZXJ0IChjID0gMCk7XG4gICAgICAgIE5vbmVcblxuICBsZXQgbWF5X3JlZHVjZV9wcm9kIHN0YXRlIHRlcm1pbmFsIHByb2QgPVxuICAgIGxldCBjb2RlID0gUGFja2VkSW50QXJyYXkuZ2V0IFQuZGVmYXVsdF9yZWR1Y3Rpb24gc3RhdGUgaW5cbiAgICBpZiBjb2RlID0gMCB0aGVuXG4gICAgICAoKiBubyBkZWZhdWx0IHJlZHVjdGlvbiAqKVxuICAgICAgbWF0Y2ggUGFja2VkSW50QXJyYXkudW5mbGF0dGVuMSBULmVycm9yIHN0YXRlIHRlcm1pbmFsIHdpdGhcbiAgICAgIHwgMSAtPlxuICAgICAgICAgIGxldCBhY3Rpb24gPSB1bm1hcnNoYWwyIFQuYWN0aW9uIHN0YXRlIHRlcm1pbmFsIGluXG4gICAgICAgICAgbGV0IG9wY29kZSA9IGFjdGlvbiBsYW5kIDBiMTEgaW5cbiAgICAgICAgICBpZiBvcGNvZGUgPj0gMGIxMCB0aGVuXG4gICAgICAgICAgICAoKiAwYjEwIDogc2hpZnQvZGlzY2FyZCAqKVxuICAgICAgICAgICAgKCogMGIxMSA6IHNoaWZ0L25vZGlzY2FyZCAqKVxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAoKiAwYjAxIDogcmVkdWNlICopXG4gICAgICAgICAgICAoKiAwYjAwIDogY2Fubm90IGhhcHBlbiAqKVxuICAgICAgICAgICAgbGV0IHByb2QnID0gYWN0aW9uIGxzciAyIGluXG4gICAgICAgICAgICBwcm9kID0gcHJvZCdcbiAgICAgIHwgYyAtPlxuICAgICAgICAgIGFzc2VydCAoYyA9IDApO1xuICAgICAgICAgIGZhbHNlXG4gICAgZWxzZVxuICAgICAgKCogZGVmYXVsdCByZWR1Y3Rpb24gKilcbiAgICAgIGxldCBwcm9kJyA9IGNvZGUgLSAxIGluXG4gICAgICBwcm9kID0gcHJvZCdcblxuICBsZXQgZ290b19udCBzdGF0ZSBudCA9XG4gICAgbGV0IGNvZGUgPSB1bm1hcnNoYWwyIFQuZ290byBzdGF0ZSBudCBpblxuICAgICgqIGNvZGUgPSAxICsgc3RhdGUgKilcbiAgICBjb2RlIC0gMVxuXG4gIGxldFtAaW5saW5lXSBsaHMgcHJvZCA9XG4gICAgUGFja2VkSW50QXJyYXkuZ2V0IFQubGhzIHByb2RcblxuICBsZXQgZ290b19wcm9kIHN0YXRlIHByb2QgPVxuICAgIGdvdG9fbnQgc3RhdGUgKGxocyBwcm9kKVxuXG4gIGxldCBtYXliZV9nb3RvX250IHN0YXRlIG50ID1cbiAgICBsZXQgY29kZSA9IHVubWFyc2hhbDIgVC5nb3RvIHN0YXRlIG50IGluXG4gICAgKCogSWYgW2NvZGVdIGlzIDAsIHRoZXJlIGlzIG5vIG91dGdvaW5nIHRyYW5zaXRpb24uXG4gICAgICAgSWYgW2NvZGVdIGlzIFsxICsgc3RhdGVdLCB0aGVyZSBpcyBhIHRyYW5zaXRpb24gdG93YXJkcyBbc3RhdGVdLiAqKVxuICAgIGFzc2VydCAoMCA8PSBjb2RlKTtcbiAgICBpZiBjb2RlID0gMCB0aGVuIE5vbmUgZWxzZSBTb21lIChjb2RlIC0gMSlcblxuICBleGNlcHRpb24gRXJyb3IgPVxuICAgICAgICBULkVycm9yXG5cbiAgdHlwZSBzZW1hbnRpY19hY3Rpb24gPVxuICAgICAgKHN0YXRlLCBzZW1hbnRpY192YWx1ZSwgdG9rZW4pIEVuZ2luZVR5cGVzLmVudiAtPlxuICAgICAgKHN0YXRlLCBzZW1hbnRpY192YWx1ZSkgICAgICAgIEVuZ2luZVR5cGVzLnN0YWNrXG5cbiAgbGV0IHNlbWFudGljX2FjdGlvbiBwcm9kID1cbiAgICAoKiBJbmRleGluZyBpbnRvIHRoZSBhcnJheSBbVC5zZW1hbnRpY19hY3Rpb25dIGlzIG9mZiBieSBbVC5zdGFydF0sXG4gICAgICAgYmVjYXVzZSB0aGUgc3RhcnQgcHJvZHVjdGlvbnMgZG8gbm90IGhhdmUgZW50cmllcyBpbiB0aGlzIGFycmF5LiAqKVxuICAgIFQuc2VtYW50aWNfYWN0aW9uLihwcm9kIC0gVC5zdGFydClcblxuICAoKiBbbWF5X3JlZHVjZSBzdGF0ZSBwcm9kXSB0ZXN0cyB3aGV0aGVyIHRoZSBzdGF0ZSBbc3RhdGVdIGlzIGNhcGFibGUgb2ZcbiAgICAgcmVkdWNpbmcgdGhlIHByb2R1Y3Rpb24gW3Byb2RdLiBUaGlzIGluZm9ybWF0aW9uIGNvdWxkIGJlIGRldGVybWluZWRcbiAgICAgaW4gY29uc3RhbnQgdGltZSBpZiB3ZSB3ZXJlIHdpbGxpbmcgdG8gY3JlYXRlIGEgYml0bWFwIGZvciBpdCwgYnV0XG4gICAgIHRoYXQgd291bGQgdGFrZSB1cCBhIGxvdCBvZiBzcGFjZS4gSW5zdGVhZCwgd2Ugb2J0YWluIHRoaXMgaW5mb3JtYXRpb25cbiAgICAgYnkgaXRlcmF0aW5nIG92ZXIgYSBsaW5lIGluIHRoZSBhY3Rpb24gdGFibGUuIFRoaXMgaXMgY29zdGx5LCBidXQgdGhpc1xuICAgICBmdW5jdGlvbiBpcyBub3Qgbm9ybWFsbHkgdXNlZCBieSB0aGUgTFIgZW5naW5lIGFueXdheTsgaXQgaXMgc3VwcG9zZWRcbiAgICAgdG8gYmUgdXNlZCBvbmx5IGJ5IHByb2dyYW1tZXJzIHdobyB3aXNoIHRvIGRldmVsb3AgZXJyb3IgcmVjb3ZlcnlcbiAgICAgc3RyYXRlZ2llcy4gKilcblxuICAoKiBJbiB0aGUgZnV0dXJlLCBpZiBkZXNpcmVkLCB3ZSBjb3VsZCBtZW1vaXplIHRoaXMgZnVuY3Rpb24sIHNvIGFzXG4gICAgIHRvIHBheSB0aGUgY29zdCBpbiAobWVtb3J5KSBzcGFjZSBvbmx5IGlmIGFuZCB3aGVyZSB0aGlzIGZ1bmN0aW9uXG4gICAgIGlzIGFjdHVhbGx5IHVzZWQuIFdlIGNvdWxkIGFsc28gcmVwbGFjZSBbZm9yZWFjaF90ZXJtaW5hbF0gd2l0aCBhXG4gICAgIGZ1bmN0aW9uIFtleGlzdHNfdGVybWluYWxdIHdoaWNoIHN0b3BzIGFzIHNvb24gYXMgdGhlIGFjY3VtdWxhdG9yXG4gICAgIGlzIFt0cnVlXS4gKilcblxuICBsZXQgbWF5X3JlZHVjZSBzdGF0ZSBwcm9kID1cbiAgICAoKiBUZXN0IGlmIHRoZXJlIGlzIGEgZGVmYXVsdCByZWR1Y3Rpb24gb2YgW3Byb2RdLiAqKVxuICAgIGRlZmF1bHRfcmVkdWN0aW9uIHN0YXRlXG4gICAgICAoZnVuICgpIHByb2QnIC0+IHByb2QgPSBwcm9kJylcbiAgICAgIChmdW4gKCkgLT5cbiAgICAgICAgKCogSWYgbm90LCB0aGVuIGZvciBlYWNoIHRlcm1pbmFsIFt0XSwgLi4uICopXG4gICAgICAgIGZvcmVhY2hfdGVybWluYWwgKGZ1biB0IGFjY3UgLT5cbiAgICAgICAgICBhY2N1IHx8XG4gICAgICAgICAgKCogLi4uIHRlc3QgaWYgdGhlcmUgaXMgYSByZWR1Y3Rpb24gb2YgW3Byb2RdIG9uIFt0XS4gKilcbiAgICAgICAgICBhY3Rpb24gc3RhdGUgdCAoKVxuICAgICAgICAgICAgKCogc2hpZnQ6ICAqKSAoZnVuICgpIF8gXyAoKSBfIC0+IGZhbHNlKVxuICAgICAgICAgICAgKCogcmVkdWNlOiAqKSAoZnVuICgpIHByb2QnIC0+IHByb2QgPSBwcm9kJylcbiAgICAgICAgICAgICgqIGZhaWw6ICAgKikgKGZ1biAoKSAtPiBmYWxzZSlcbiAgICAgICAgICAgICgpXG4gICAgICAgICkgZmFsc2VcbiAgICAgIClcbiAgICAgICgpXG5cbiAgKCogSWYgW1QudHJhY2VdIGlzIFtOb25lXSwgdGhlbiB0aGUgbG9nZ2luZyBmdW5jdGlvbnMgZG8gbm90aGluZy4gKilcblxuICBsZXQgbG9nID1cbiAgICBtYXRjaCBULnRyYWNlIHdpdGggU29tZSBfIC0+IHRydWUgfCBOb25lIC0+IGZhbHNlXG5cbiAgbW9kdWxlIExvZyA9IHN0cnVjdFxuXG4gICAgb3BlbiBQcmludGZcblxuICAgIGxldCBzdGF0ZSBzdGF0ZSA9XG4gICAgICBtYXRjaCBULnRyYWNlIHdpdGhcbiAgICAgIHwgU29tZSBfIC0+XG4gICAgICAgICAgZnByaW50ZiBzdGRlcnIgXCJTdGF0ZSAlZDpcXG4lIVwiIHN0YXRlXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAoKVxuXG4gICAgbGV0IHNoaWZ0IHRlcm1pbmFsIHN0YXRlID1cbiAgICAgIG1hdGNoIFQudHJhY2Ugd2l0aFxuICAgICAgfCBTb21lICh0ZXJtaW5hbHMsIF8pIC0+XG4gICAgICAgICAgZnByaW50ZiBzdGRlcnIgXCJTaGlmdGluZyAoJXMpIHRvIHN0YXRlICVkXFxuJSFcIiB0ZXJtaW5hbHMuKHRlcm1pbmFsKSBzdGF0ZVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgKClcblxuICAgIGxldCByZWR1Y2Vfb3JfYWNjZXB0IHByb2QgPVxuICAgICAgbWF0Y2ggVC50cmFjZSB3aXRoXG4gICAgICB8IFNvbWUgKF8sIHByb2R1Y3Rpb25zKSAtPlxuICAgICAgICAgIGZwcmludGYgc3RkZXJyIFwiJXNcXG4lIVwiIHByb2R1Y3Rpb25zLihwcm9kKVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgKClcblxuICAgIGxldCBsb29rYWhlYWRfdG9rZW4gdG9rZW4gc3RhcnRwIGVuZHAgPVxuICAgICAgbWF0Y2ggVC50cmFjZSB3aXRoXG4gICAgICB8IFNvbWUgKHRlcm1pbmFscywgXykgLT5cbiAgICAgICAgICBmcHJpbnRmIHN0ZGVyciBcIkxvb2thaGVhZCB0b2tlbiBpcyBub3cgJXMgKCVkLSVkKVxcbiUhXCJcbiAgICAgICAgICAgIHRlcm1pbmFscy4odG9rZW4pXG4gICAgICAgICAgICBzdGFydHAuTGV4aW5nLnBvc19jbnVtXG4gICAgICAgICAgICBlbmRwLkxleGluZy5wb3NfY251bVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgKClcblxuICAgIGxldCBpbml0aWF0aW5nX2Vycm9yX2hhbmRsaW5nICgpID1cbiAgICAgIG1hdGNoIFQudHJhY2Ugd2l0aFxuICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgICBmcHJpbnRmIHN0ZGVyciBcIkluaXRpYXRpbmcgZXJyb3IgaGFuZGxpbmdcXG4lIVwiXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAoKVxuXG4gICAgbGV0IHJlc3VtaW5nX2Vycm9yX2hhbmRsaW5nICgpID1cbiAgICAgIG1hdGNoIFQudHJhY2Ugd2l0aFxuICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgICBmcHJpbnRmIHN0ZGVyciBcIlJlc3VtaW5nIGVycm9yIGhhbmRsaW5nXFxuJSFcIlxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgKClcblxuICAgIGxldCBoYW5kbGluZ19lcnJvciBzdGF0ZSA9XG4gICAgICBtYXRjaCBULnRyYWNlIHdpdGhcbiAgICAgIHwgU29tZSBfIC0+XG4gICAgICAgICAgZnByaW50ZiBzdGRlcnIgXCJIYW5kbGluZyBlcnJvciBpbiBzdGF0ZSAlZFxcbiUhXCIgc3RhdGVcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICgpXG5cbiAgZW5kXG5cbmVuZFxuZW5kXG5tb2R1bGUgU3RhdGljVmVyc2lvbiA9IHN0cnVjdFxubGV0IHJlcXVpcmVfMjAyNDA3MTUgPSAoKVxuZW5kXG4iXSwibmFtZXMiOlsicnVudGltZSIsImNzdCIsImNzdF9BdF9hbl91bmtub3duX2xvY2F0aW9uIiwiY3N0X2xpYl9wYWNrX21lbmhpckxpYl9tbCIsImNhbWxfYXJyYXlfbWFrZSIsImNhbWxfYnl0ZXNfc2V0IiwiY2FtbF9jaGVja19ib3VuZCIsImNhbWxfY3JlYXRlX2J5dGVzIiwiY2FtbF9kaXYiLCJjYW1sX2VxdWFsIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9tb2QiLCJjYW1sX211bCIsImNhbWxfb2JqX3RhZyIsImNhbWxfc3RyaW5nX2dldCIsImNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQiLCJjYW1sX3dyYXBfZXhjZXB0aW9uIiwiY2FtbF9jYWxsMSIsImYiLCJhMCIsImNhbWxfY2FsbDIiLCJhMSIsImNhbWxfY2FsbDMiLCJhMiIsImNhbWxfY2FsbDQiLCJhMyIsImNhbWxfY2FsbDUiLCJhNCIsImNhbWxfY2FsbDciLCJhNSIsImE2IiwiZHVtbXkiLCJnbG9iYWxfZGF0YSIsImFycm93IiwiZG90Iiwic3BhY2UiLCJuZXdsaW5lIiwiU3RkbGliIiwiU3RkbGliX1ByaW50ZiIsIkFzc2VydF9mYWlsdXJlIiwiU3RkbGliX0xpc3QiLCJTdGRsaWJfQXJyYXkiLCJTdGRsaWJfQ2hhciIsIlN0ZGxpYl9CeXRlcyIsIlN0ZGxpYl9TeXMiLCJTdGRsaWJfTGV4aW5nIiwiU3RkbGliX1N0cmluZyIsIlN0ZGxpYl9CdWZmZXIiLCJDYW1saW50ZXJuYWxMYXp5IiwidGFrZSIsIm4iLCJpbnB1dCIsInhzIiwieCIsImRyb3AiLCJ1bmlxMSIsImNtcCIsInlzIiwieSIsInVuaXEiLCJ3ZWVkIiwibGVuZ3RoIiwibWF0Y2giLCJmb2xkciIsImFjY3UiLCJ0cmFkaXRpb25hbDJyZXZpc2VkIiwiZ2V0X3Jhd190b2tlbiIsImdldF9zdGFydHAiLCJnZXRfZW5kcCIsInBhcnNlciIsImxleGVyIiwibGV4YnVmIiwidG9rZW4iLCJyZXZpc2VkMnRyYWRpdGlvbmFsIiwibWFrZV90b2tlbiIsInBhcmFtIiwic3RhcnRwIiwiZW5kcCIsIlNpbXBsaWZpZWQiLCJDb252ZXJ0IiwiSW5jcmVtZW50YWxFbmdpbmUiLCJFbmdpbmVUeXBlcyIsInVwZGF0ZSIsImJ1ZmZlciIsIngyIiwieDEiLCJzaG93IiwiaW52YWxpZCIsInZhbGlkIiwibGFzdCIsIndyYXAiLCJ3cmFwX3N1cHBsaWVyIiwic3VwcGxpZXIiLCJ0cmlwbGUiLCJwb3MyIiwicG9zMSIsImV4dHJhY3QiLCJ0ZXh0Iiwib2ZzMSIsIm9mczIiLCJsZW4iLCJleG4iLCJ0YWciLCJzYW5pdGl6ZSIsImMiLCJjb21wcmVzcyIsImIiLCJpIiwiaiIsInNraXBwaW5nIiwic2hvcnRlbiIsImsiLCJDb3B5IiwiZXhwYW5kIiwiaW5pdCIsImZpbGVuYW1lIiwicmVhZCIsInBvcyIsInJhbmdlIiwiZmlsZSIsImxpbmUiLCJjaGFyMSIsImNoYXIyIiwidGFidWxhdGUiLCJpc19lb2YiLCJ0b2tlbnMiLCJtYWtlIiwiZW5zdXJlIiwiYSIsInRhYmxlIiwiZ2V0Iiwic2V0IiwiZXh0ZW50IiwiZG9tYWluIiwicGFjayIsIm0iLCJ2IiwibWF4IiwidyIsInMiLCJpaSIsImdldDEiLCJzd2l0Y2hlciIsInVuZmxhdHRlbjEiLCJkYXRhIiwiZGVjb2RlIiwiZGlzcGxhY2VtZW50IiwiZXF1YWwiLCJpbnNpZ25pZmljYW50IiwidCIsInNwYXJzZSIsInJhbmsiLCJyb3ciLCJyb3dzIiwicmFuazIiLCJyYW5rMSIsImQiLCJnZXRnZXQiLCJnZXRfZGlzcGxhY2VtZW50IiwiZ2V0X2RhdGEiLCJzaXplIiwiZW50cnkiLCJyb3dfbGVuZ3RoIiwicm93X2xlbmd0aF92aWEiLCJnZXRfZW50cnkiLCJsYSIsInJlYWRfdmlhIiwid3JpdGUiLCJyZWFkX2ludGVydmFsX3ZpYSIsInJlYWRfcm93X3ZpYSIsInJlYWRfcm93IiwiVGFibGVGb3JtYXQiLCJJbnNwZWN0aW9uVGFibGVGb3JtYXQiLCJTeW1ib2xzIiwiVCIsIlN0YXRpY1ZlcnNpb24iLCJjc3RfZmVlZF9vdXRnb2luZ190cmFuc2l0aW9uX2QiLCJjc3RfQ3VycmVudF9MUl8xX3N0YXRlIiwiY3N0X3NvbWVfaW5pdGlhbF9zdGF0ZSIsImNzdF9vZmZlcl9leHBlY3RzX0lucHV0TmVlZGVkIiwiY3N0X3Jlc3VtZV9leHBlY3RzX0hhbmRsaW5nRXJyIiwiY3N0X2ZvcmNlX3JlZHVjdGlvbl90aGlzX3JlZHVjIiwiTWVuaGlyTGliIiwibnVtYmVyIiwicHJvZHVjdGlvbl9pbmRleCIsImZpbmRfcHJvZHVjdGlvbiIsIkVycm9yIiwibG9nIiwiTG9nIiwicnVuIiwiZW52IiwicGxlYXNlX2Rpc2NhcmQiLCJjaGVja19mb3JfZGVmYXVsdF9yZWR1Y3Rpb24iLCJjaGVja19mb3JfZXJyb3JfdG9rZW4iLCJzaGlmdCIsInRlcm1pbmFsIiwidmFsdWUiLCJzdGFjayIsIm5ld19lbnYiLCJhbm5vdW5jZV9yZWR1Y2UiLCJwcm9kIiwicmVkdWNlIiwiY3VycmVudCIsImluaXRpYXRlIiwic3RhcnQiLCJpbml0aWFsIiwiZW1wdHkiLCJvZmZlciIsInJlc3VtZSIsIm9wdCIsImNoZWNrcG9pbnQiLCJzdHJhdGVneSIsImNlbGwiLCJuZXh0IiwibGV4ZXJfbGV4YnVmX3RvX3N1cHBsaWVyIiwibG9vcCIsImxvb3BfaGFuZGxlIiwic3VjY2VlZCIsImZhaWwiLCJsb29wX2hhbmRsZV91bmRvIiwiaW5wdXRuZWVkZWQiLCJzaGlmdHMiLCJhY2NlcHRhYmxlIiwiZWxlbWVudCIsInRvcCIsImVudjEiLCJlbnYyIiwiY3VycmVudF9zdGF0ZV9udW1iZXIiLCJwb3NpdGlvbnMiLCJzdGF0ZV9oYXNfZGVmYXVsdF9yZWR1Y3Rpb24iLCJzdGF0ZSIsImVudl9oYXNfZGVmYXVsdF9yZWR1Y3Rpb24iLCJwb3AiLCJmb3JjZV9yZWR1Y3Rpb24iLCJpbnB1dF9uZWVkZWQiLCJwb3BfbWFueSIsIkkiLCJVc2VyIiwicHJpbnRfc3ltYm9scyIsInN5bWJvbHMiLCJzeW1ib2wiLCJwcmludF9lbGVtZW50X2FzX3N5bWJvbCIsInByaW50X2VsZW1lbnQiLCJwcmludF9zdGFjayIsInByaW50X2l0ZW0iLCJwcmludF9wcm9kdWN0aW9uIiwicHJpbnRfY3VycmVudF9zdGF0ZSIsInByaW50X2VudiIsIlRUIiwiSVQiLCJFVCIsIkUiLCJyZWFkX3BhY2tlZF9saW5lYXJpemVkIiwiZGVjb2RlX3N5bWJvbCIsImtpbmQiLCJuMmkiLCJudCIsImFuc3dlciIsInQyaSIsImNvbXBhcmVfdGVybWluYWxzIiwidDEiLCJ0MiIsImNvbXBhcmVfbm9udGVybWluYWxzIiwibnQxIiwibnQyIiwiY29tcGFyZV9zeW1ib2xzIiwic3ltYm9sMSIsInN5bWJvbDIiLCJjb21wYXJlX3Byb2R1Y3Rpb25zIiwicHJvZDEiLCJwcm9kMiIsImNvbXBhcmVfaXRlbXMiLCJpbmRleDIiLCJpbmRleDEiLCJpbmNvbWluZ19zeW1ib2wiLCJjb3JlIiwibGhzIiwicmhzIiwiZXhwb3J0JCIsIml0ZW1zIiwiZGVjb2RlX2Jvb2wiLCJudWxsYWJsZSIsImZpcnN0IiwieGZpcnN0IiwiZm9yZWFjaF90ZXJtaW5hbCIsImZvcmVhY2hfdGVybWluYWxfYnV0X2Vycm9yIiwiZmVlZF9mYWlsdXJlIiwiZmVlZCIsInNlbXYiLCJzb3VyY2UiLCJ0YXJnZXQiLCJ0b2tlbjJ0ZXJtaW5hbCIsInRva2VuMnZhbHVlIiwiZXJyb3JfdGVybWluYWwiLCJub25fc3RhcnRfcHJvZHVjdGlvbiIsImRlZmF1bHRfcmVkdWN0aW9uIiwiZGVmcmVkIiwibm9kZWZyZWQiLCJjb2RlIiwiaXNfc3RhcnQiLCJhY3Rpb24iLCJvcGNvZGUiLCJtYXliZV9zaGlmdF90IiwibWF5X3JlZHVjZV9wcm9kIiwiZ290b19udCIsImdvdG9fcHJvZCIsIm1heWJlX2dvdG9fbnQiLCJzZW1hbnRpY19hY3Rpb24iLCJtYXlfcmVkdWNlIiwiZXJyb3JfdmFsdWUiLCJ0ZXJtaW5hbHMiLCJyZWR1Y2Vfb3JfYWNjZXB0IiwicHJvZHVjdGlvbnMiLCJsb29rYWhlYWRfdG9rZW4iLCJpbml0aWF0aW5nX2Vycm9yX2hhbmRsaW5nIiwicmVzdW1pbmdfZXJyb3JfaGFuZGxpbmciLCJoYW5kbGluZ19lcnJvciJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQyxRQUFBO0FBQUEsSUFBQUMsNkJBQUE7QUFBQSxJQUFBQyw0QkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsaUJBQUE7QUFBQSxJQUFBQyxtQkFBQTtBQUFBLElBQUFDLG9CQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLGFBQUE7QUFBQSxJQUFBQyw4QkFBQTtBQUFBLElBQUFDLHdCQUFBO0FBQUEsSUFBQUMsV0FBQTtBQUFBLElBQUFDLFdBQUE7QUFBQSxJQUFBQyxlQUFBO0FBQUEsSUFBQUMsa0JBQUE7QUFBQSxJQUFBQyx5QkFBQTtBQUFBLElBQUFDLHNCQUFBO0FBQUEsWUFBQUMsV0FBQUMsR0FBQUM7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFGLEdBQUFDLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBSixHQUFBQyxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQU4sR0FBQUMs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Y0FDQSx5Q0FBMEM7QUFBQSxVQUQxQztBQUFBLFNBQzBDO0FBQUEsYUFBQWhILFFEM29IOUM7QUFBQSxrQkFBQXlILGdCQUFBM0c7QUFBQUEsY0FBQSxJQ3VwSEk7QUFBQSxrREFBa0M7QUFBQTtBQUFBLGtCQUFBNEcsV0FBQTlFLE9BQUE5QjtBQUFBQSxjQUFBa0csT0FoSHZCO0FBQUEsVUFDWDtBQUFBLGVBQUFsRyxTQUtFO0FBQUEsV0E4SGlCO0FBQUE7QUFBQSxjQUFBdEosSUExSm5CLFNBQUFjLFNBQ0EsR0FBQTJDLE1BQUE7QUFBQTtBQUFBLFdBUEEsY0FDRTtBQUFBO0FBQUEsWUFBQTNDO0FBQUFBLGNBbUtJO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNDQUFBVyxPQUdvQyxTQUFLO0FBQUEsMEJBQUFBLE9BQUE2SCxRQUNSLCtCQUFZO0FBQUEsMEJBQUE3SCxPQUNsQixTQUFLO0FBQUE7QUFBQSxZQUFBZ0MsSUF0S1A7QUFBQTtBQUFBO0FBQUE7QUFBQSxTQTBLM0I7QUFBQSxhQUFBME0sY0R4ckhSLEdBQUExSCxNQUFBO0FBQUEsa0JBQUEyQyxNQUFBQTtBQUFBQSxVQ29zSE07QUFBQSxvQkFFSTtBQUFBLHFCQUVFO0FBQUE7QUFBQSxrQkFBQXBDLE1BQUFDLFVBQUFtQztBQUFBQSxjQUFBeEssUUFHTjtBQUFBLHNCQUlJO0FBQUE7QUFBQSxXQUFBd1AsWUFKSjtBQUFBLGVBRW1EO0FBQUEsVUFBb0IsNERBRWpFO0FBQUE7QUFBQSxrQkFBQUMsaUJBQUEvRztBQUFBQSxjQUFBMUksUUFHTjtBQUFBLHNCQUlJO0FBQUE7QUFBQSxXQUFBMFAsY0FKSjtBQUFBLGVBRTRCO0FBQUEsVUFBa0IscURBRXhDO0FBQUE7QUFBQSxrQkFBQUMsZ0JBQUFqUCxPQUFBSSxRQUFBQztBQUFBQSxjQUFBZixRQUdOO0FBQUEsc0JBT0k7QUFBQTtBQUFBLFdBQUF3UCxZQVBKO0FBQUEsZUFHTTtBQUFBO0FBQUE7QUFBQSxVQUFpQiwyREFJakI7QUFBQTtBQUFBLGtCQUFBSSwwQkFBQS9PO0FBQUFBLFVBR04sZUFFSSwrQ0FFRTtBQUFBO0FBQUEsa0JBQUFnUCx3QkFBQWhQO0FBQUFBLFVBR04sZUFFSSwrQ0FFRTtBQUFBO0FBQUEsa0JBQUFpUCxlQUFBdEY7QUFBQUEsVUFHTjtBQUFBLG9CQUVJO0FBQUEscUJBRUU7QUFBQTtBQUFBO0FBQUEsVUFBQTFDO0FBQUFBLFlEcnZIWiIsImlnbm9yZUxpc3QiOlswXX19XX0=
