// Generated by js_of_ocaml
//# buildInfo:effects=disabled, kind=cma, use-js-string=true, version=6.2.0

//# unitInfo: Provides: Sedlexing
//# unitInfo: Requires: Gen, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Option, Stdlib__Uchar
//# shape: Sedlexing:[N,N,F(2)*,F(3),F(2),F(2)*,F(2),F(2),F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1)*,F(1),F(1),F(2),F(3),F(1),F(1),F(1),F(1),F(2),F(1),F(2)*->F(1),N,N,N]
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_lib_sedlexing_ml = "src/lib/sedlexing.ml",
    caml_array_make = runtime.caml_array_make,
    caml_check_bound = runtime.caml_check_bound,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) === 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) === 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) === 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) === 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) === 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    dummy = 0,
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Gen = global_data.Gen,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib = global_data.Stdlib,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    InvalidCodepoint =
      [248, "Sedlexing.InvalidCodepoint", caml_fresh_oo_id(0)],
    MalFormed = [248, "Sedlexing.MalFormed", caml_fresh_oo_id(0)],
    to_int = Stdlib_Uchar[10],
    is_char = Stdlib_Uchar[11],
    of_char = Stdlib_Uchar[12],
    to_char = Stdlib_Uchar[13],
    equal = Stdlib_Uchar[15],
    utf_8_byte_length = Stdlib_Uchar[24],
    utf_16_byte_length = Stdlib_Uchar[25];
   function of_int(x){
    if(caml_call1(Stdlib_Uchar[7], x)) return caml_call1(Stdlib_Uchar[9], x);
    throw caml_maybe_attach_backtrace(MalFormed, 1);
   }
   var a = [0, cst_src_lib_sedlexing_ml, 88, 27];
   function empty_lexbuf(bytes_per_char){
    return [0,
            function(c, b, param){
             throw caml_maybe_attach_backtrace([0, Assert_failure, a], 1);
            },
            bytes_per_char,
            ,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            cst,
            0];
   }
   var dummy_uchar = of_int(0), nl_uchar = of_int(10), chunk_size = 512;
   function create(opt, refill){
    var
     bytes_per_char = opt ? opt[1] : function(param){return 1;},
     init = empty_lexbuf(bytes_per_char);
    return [0,
            refill,
            init[2],
            caml_array_make(512, dummy_uchar),
            init[4],
            init[5],
            init[6],
            init[7],
            init[8],
            init[9],
            init[10],
            init[11],
            init[12],
            init[13],
            init[14],
            init[15],
            init[16],
            init[17],
            init[18],
            init[19],
            init[20],
            init[21],
            init[22],
            init[23],
            init[24]];
   }
   function set_position(bytes_position, lexbuf, position){
    lexbuf[5] = position[4] - lexbuf[7] | 0;
    lexbuf[9] = position[3];
    lexbuf[11] = position[2];
    var
     bytes_position$0 = caml_call2(Stdlib_Option[3], bytes_position, position);
    lexbuf[6] = bytes_position$0[4] - lexbuf[8] | 0;
    lexbuf[10] = bytes_position$0[3];
    return 0;
   }
   function set_filename(lexbuf, fname){lexbuf[23] = fname; return 0;}
   function from_gen(bytes_per_char, gen){
    var malformed = [0, 0];
    function refill(buf, pos, len){
     var i = 0;
     for(;;){
      if(malformed[1]) throw caml_maybe_attach_backtrace(MalFormed, 1);
      if(len <= i) return len;
      try{var val = caml_call1(gen, 0);}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(exn === MalFormed && 0 !== i){malformed[1] = 1; return i;}
       throw caml_maybe_attach_backtrace(exn, 0);
      }
      if(! val) return i;
      var c = val[1], a = pos + i | 0;
      caml_check_bound(buf, a)[a + 1] = c;
      var i$0 = i + 1 | 0;
      i = i$0;
     }
    }
    return create(bytes_per_char, refill);
   }
   function from_int_array(bytes_per_char, a){
    return from_gen
            (bytes_per_char,
             caml_call2
              (Gen[12],
               [0, a.length - 1],
               function(i){return of_int(caml_check_bound(a, i)[i + 1]);}));
   }
   function from_uchar_array(opt, a){
    var
     bytes_per_char = opt ? opt[1] : function(param){return 1;},
     len = a.length - 1,
     init = empty_lexbuf(bytes_per_char),
     b = init[23],
     c = init[22],
     d = init[21],
     e = init[20],
     f = init[19],
     g = init[18],
     h = init[17],
     i = init[16],
     j = init[15],
     k = init[14],
     l = init[13],
     m = init[12],
     n = init[11],
     o = init[10],
     p = init[9],
     q = init[8],
     r = init[7],
     s = init[6],
     t = init[5],
     u =
       caml_call2
        (Stdlib_Array[1],
         len,
         function(i){return caml_check_bound(a, i)[i + 1];});
    return [0,
            init[1],
            init[2],
            u,
            len,
            t,
            s,
            r,
            q,
            p,
            o,
            n,
            m,
            l,
            k,
            j,
            i,
            h,
            g,
            f,
            e,
            d,
            c,
            b,
            1];
   }
   function new_line(lexbuf){
    lexbuf[11] = lexbuf[11] + 1 | 0;
    lexbuf[9] = lexbuf[7] + lexbuf[5] | 0;
    lexbuf[10] = lexbuf[8] + lexbuf[6] | 0;
    return 0;
   }
   function next_aux(some, none, lexbuf){
    var c = 1 - lexbuf[24];
    if(c)
     var b = lexbuf[4], a = lexbuf[7], d = a === b ? 1 : 0;
    else
     var d = c;
    if(d){
     if(lexbuf[3].length - 1 < (lexbuf[4] + 512 | 0)){
      var s = lexbuf[12], s_bytes = lexbuf[13], ls = lexbuf[4] - s | 0;
      if((ls + 512 | 0) <= lexbuf[3].length - 1)
       caml_call5(Stdlib_Array[9], lexbuf[3], s, lexbuf[3], 0, ls);
      else{
       var
        newlen = (lexbuf[3].length + 511 | 0) * 2 | 0,
        newbuf = caml_array_make(newlen, dummy_uchar);
       caml_call5(Stdlib_Array[9], lexbuf[3], s, newbuf, 0, ls);
       lexbuf[3] = newbuf;
      }
      lexbuf[4] = ls;
      lexbuf[5] = lexbuf[5] + s | 0;
      lexbuf[6] = lexbuf[6] + s_bytes | 0;
      lexbuf[7] = lexbuf[7] - s | 0;
      lexbuf[8] = lexbuf[8] - s_bytes | 0;
      lexbuf[17] = lexbuf[17] - s | 0;
      lexbuf[18] = lexbuf[18] - s_bytes | 0;
      lexbuf[12] = 0;
      lexbuf[13] = 0;
     }
     var n = caml_call3(lexbuf[1], lexbuf[3], lexbuf[7], chunk_size);
     if(n === 0) lexbuf[24] = 1; else lexbuf[4] = lexbuf[4] + n | 0;
    }
    if(lexbuf[24]){
     var b$0 = lexbuf[4], a$0 = lexbuf[7];
     if(a$0 === b$0) return none;
    }
    var e = lexbuf[7], ret = caml_check_bound(lexbuf[3], e)[e + 1];
    lexbuf[7] = lexbuf[7] + 1 | 0;
    var f = caml_call1(lexbuf[2], ret);
    lexbuf[8] = lexbuf[8] + f | 0;
    if(caml_call2(equal, ret, nl_uchar)) new_line(lexbuf);
    return caml_call1(some, ret);
   }
   function next(lexbuf){
    return next_aux(function(x){return [0, x];}, 0, lexbuf);
   }
   function private_next_int(lexbuf){return next_aux(to_int, -1, lexbuf);}
   function mark(lexbuf, i){
    lexbuf[17] = lexbuf[7];
    lexbuf[18] = lexbuf[8];
    lexbuf[19] = lexbuf[9];
    lexbuf[20] = lexbuf[10];
    lexbuf[21] = lexbuf[11];
    lexbuf[22] = i;
    return 0;
   }
   function start(lexbuf){
    lexbuf[12] = lexbuf[7];
    lexbuf[13] = lexbuf[8];
    lexbuf[14] = lexbuf[9];
    lexbuf[15] = lexbuf[10];
    lexbuf[16] = lexbuf[11];
    return mark(lexbuf, -1);
   }
   function backtrack(lexbuf){
    lexbuf[7] = lexbuf[17];
    lexbuf[8] = lexbuf[18];
    lexbuf[9] = lexbuf[19];
    lexbuf[10] = lexbuf[20];
    lexbuf[11] = lexbuf[21];
    return lexbuf[22];
   }
   function rollback(lexbuf){
    lexbuf[7] = lexbuf[12];
    lexbuf[8] = lexbuf[13];
    lexbuf[9] = lexbuf[14];
    lexbuf[10] = lexbuf[15];
    lexbuf[11] = lexbuf[16];
    return 0;
   }
   function lexeme_start(lexbuf){return lexbuf[12] + lexbuf[5] | 0;}
   function lexeme_bytes_start(lexbuf){return lexbuf[13] + lexbuf[6] | 0;}
   function lexeme_end(lexbuf){return lexbuf[7] + lexbuf[5] | 0;}
   function lexeme_bytes_end(lexbuf){return lexbuf[8] + lexbuf[6] | 0;}
   function loc(lexbuf){
    return [0, lexbuf[12] + lexbuf[5] | 0, lexbuf[7] + lexbuf[5] | 0];
   }
   function bytes_loc(lexbuf){
    return [0, lexbuf[13] + lexbuf[6] | 0, lexbuf[8] + lexbuf[6] | 0];
   }
   function lexeme_length(lexbuf){return lexbuf[7] - lexbuf[12] | 0;}
   function lexeme_bytes_length(lexbuf){return lexbuf[8] - lexbuf[13] | 0;}
   function sub_lexeme(lexbuf, pos, len){
    return caml_call3(Stdlib_Array[6], lexbuf[3], lexbuf[12] + pos | 0, len);
   }
   function lexeme(lexbuf){
    return caml_call3
            (Stdlib_Array[6],
             lexbuf[3],
             lexbuf[12],
             lexbuf[7] - lexbuf[12] | 0);
   }
   function lexeme_char(lexbuf, pos){
    var a = lexbuf[12] + pos | 0;
    return caml_check_bound(lexbuf[3], a)[a + 1];
   }
   function lexing_position_start(lexbuf){
    return [0, lexbuf[23], lexbuf[16], lexbuf[14], lexbuf[12] + lexbuf[5] | 0];
   }
   function lexing_position_curr(lexbuf){
    return [0, lexbuf[23], lexbuf[11], lexbuf[9], lexbuf[7] + lexbuf[5] | 0];
   }
   function lexing_positions(lexbuf){
    var
     start_p = lexing_position_start(lexbuf),
     curr_p = lexing_position_curr(lexbuf);
    return [0, start_p, curr_p];
   }
   function lexing_bytes_position_start(lexbuf){
    return [0, lexbuf[23], lexbuf[16], lexbuf[15], lexbuf[13] + lexbuf[6] | 0];
   }
   function lexing_bytes_position_curr(lexbuf){
    return [0, lexbuf[23], lexbuf[11], lexbuf[10], lexbuf[8] + lexbuf[6] | 0];
   }
   function lexing_bytes_positions(lexbuf){
    var
     start_p = lexing_bytes_position_start(lexbuf),
     curr_p = lexing_bytes_position_curr(lexbuf);
    return [0, start_p, curr_p];
   }
   function with_tokenizer(lexer, lexbuf){
    function lexer$0(param){
     var
      token = caml_call1(lexer, lexbuf),
      match = lexing_positions(lexbuf),
      curr_p = match[2],
      start_p = match[1];
     return [0, token, start_p, curr_p];
    }
    return lexer$0;
   }
   var
    Missing_input = [248, "Sedlexing.Chan.Missing_input", caml_fresh_oo_id(0)],
    min_buffer_size = 64,
    cst_Sedlexing_Chan_ensure = "Sedlexing.Chan.ensure",
    cst_advance = "advance",
    b = [0, cst_src_lib_sedlexing_ml, 501, 15];
   function available(t){return t[3] - t[4] | 0;}
   function ensure_bytes_available(t, can_refill, n){
    var a = n <= 0 ? 1 : 0, b = a || (64 < n ? 1 : 0);
    if(b) caml_call1(Stdlib[1], cst_Sedlexing_Chan_ensure);
    for(;;){
     if(n <= available(t)) return;
     if(! can_refill) throw caml_maybe_attach_backtrace(Missing_input, 1);
     var len = t[3] - t[4] | 0;
     if(0 < len) caml_call5(Stdlib_Bytes[11], t[1], t[4], t[1], 0, len);
     var
      read =
        caml_call4
         (Stdlib[84],
          t[2],
          t[1],
          len,
          runtime.caml_ml_bytes_length(t[1]) - len | 0);
     t[3] = len + read | 0;
     t[4] = 0;
     if(read === 0) throw caml_maybe_attach_backtrace(Missing_input, 1);
    }
   }
   function get(t, i){return runtime.caml_bytes_get(t[1], t[4] + i | 0);}
   function advance(t, n){
    if(t[3] < (t[4] + n | 0)) caml_call1(Stdlib[1], cst_advance);
    t[4] = t[4] + n | 0;
   }
   function make_from_channel
   (bytes_per_char, ic, max_bytes_per_uchar, min_bytes_per_uchar, read_uchar){
    var
     len$0 = 512 * max_bytes_per_uchar | 0,
     len = caml_call2(Stdlib[17], len$0, min_buffer_size),
     t = [0, caml_create_bytes(len), ic, 0, 0],
     malformed = [0, 0];
    function refill(buf, pos, len){
     var i = 0;
     for(;;){
      if(malformed[1]) throw caml_maybe_attach_backtrace(MalFormed, 1);
      if(i === len) return i;
      try{
       var can_refill = i === 0 ? 1 : 0;
       ensure_bytes_available(t, can_refill, min_bytes_per_uchar);
       var c = caml_call2(read_uchar, can_refill, t);
      }
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(exn === MalFormed && 0 !== i){malformed[1] = 1; return i;}
       if(exn !== Missing_input) throw caml_maybe_attach_backtrace(exn, 0);
       var b = i === 0 ? 1 : 0, d = b ? 0 < available(t) ? 1 : 0 : b;
       if(d) throw caml_maybe_attach_backtrace(MalFormed, 1);
       return i;
      }
      var a = pos + i | 0;
      caml_check_bound(buf, a)[a + 1] = c;
      var i$0 = i + 1 | 0;
      i = i$0;
     }
    }
    return create(bytes_per_char, refill);
   }
   function from_gen$0(s){
    return from_gen
            ([0, function(param){return 1;}], caml_call2(Gen[21], of_char, s));
   }
   function from_string(s){
    var
     len = caml_ml_string_length(s),
     init = empty_lexbuf(function(param){return 1;}),
     a = init[23],
     b = init[22],
     c = init[21],
     d = init[20],
     e = init[19],
     f = init[18],
     g = init[17],
     h = init[16],
     i = init[15],
     j = init[14],
     k = init[13],
     l = init[12],
     m = init[11],
     n = init[10],
     o = init[9],
     p = init[8],
     q = init[7],
     r = init[6],
     t = init[5],
     u =
       caml_call2
        (Stdlib_Array[1],
         len,
         function(i){return caml_call1(of_char, caml_string_get(s, i));});
    return [0,
            init[1],
            init[2],
            u,
            len,
            t,
            r,
            q,
            p,
            o,
            n,
            m,
            l,
            k,
            j,
            i,
            h,
            g,
            f,
            e,
            d,
            c,
            b,
            a,
            1];
   }
   function from_channel(ic){
    return make_from_channel
            ([0, function(param){return 1;}],
             ic,
             1,
             1,
             function(param, t){
              var c = get(t, 0);
              advance(t, 1);
              return caml_call1(of_char, c);
             });
   }
   function to_latin1(c){
    if(caml_call1(is_char, c)) return caml_call1(to_char, c);
    throw caml_maybe_attach_backtrace
           ([0, InvalidCodepoint, caml_call1(to_int, c)], 1);
   }
   function lexeme_char$0(lexbuf, pos){
    return to_latin1(lexeme_char(lexbuf, pos));
   }
   function sub_lexeme$0(lexbuf, pos, len){
    var s = caml_create_bytes(len), a = len - 1 | 0, c = 0;
    if(a >= 0){
     var i = c;
     for(;;){
      var b = (lexbuf[12] + pos | 0) + i | 0;
      runtime.caml_bytes_set
       (s, i, to_latin1(caml_check_bound(lexbuf[3], b)[b + 1]));
      var d = i + 1 | 0;
      if(a === i) break;
      i = d;
     }
    }
    return caml_call1(Stdlib_Bytes[6], s);
   }
   function lexeme$0(lexbuf){
    return sub_lexeme$0(lexbuf, 0, lexbuf[7] - lexbuf[12] | 0);
   }
   function width(param){
    if(192 <= param){
     if(240 > param) return 224 <= param ? 3 : 2;
     if(248 > param) return 4;
    }
    else if(128 > param) return 1;
    throw caml_maybe_attach_backtrace(MalFormed, 1);
   }
   function check_two(n1, n2){
    var a = n1 < 194 ? 1 : 0, b = a || (223 < n1 ? 1 : 0);
    if(b) throw caml_maybe_attach_backtrace(MalFormed, 1);
    var c = n2 < 128 ? 1 : 0, d = c || (191 < n2 ? 1 : 0);
    if(d) throw caml_maybe_attach_backtrace(MalFormed, 1);
    if(2 !== (n2 >>> 6 | 0)) throw caml_maybe_attach_backtrace(MalFormed, 1);
    return (n1 & 31) << 6 | n2 & 63;
   }
   function check_three(n1, n2, n3){
    if(n1 === 224){
     var b = n2 < 160 ? 1 : 0, c = b || (191 < n2 ? 1 : 0);
     if(c) throw caml_maybe_attach_backtrace(MalFormed, 1);
     var d = n3 < 128 ? 1 : 0, e = d || (191 < n3 ? 1 : 0);
     if(e) throw caml_maybe_attach_backtrace(MalFormed, 1);
    }
    else{
     var i = n1 < 225 ? 1 : 0, j = i || (239 < n1 ? 1 : 0);
     if(j) throw caml_maybe_attach_backtrace(MalFormed, 1);
     var k = n2 < 128 ? 1 : 0, l = k || (191 < n2 ? 1 : 0);
     if(l) throw caml_maybe_attach_backtrace(MalFormed, 1);
     var m = n3 < 128 ? 1 : 0, n = m || (191 < n3 ? 1 : 0);
     if(n) throw caml_maybe_attach_backtrace(MalFormed, 1);
    }
    var
     f = 2 !== (n2 >>> 6 | 0) ? 1 : 0,
     g = f || (2 !== (n3 >>> 6 | 0) ? 1 : 0);
    if(g) throw caml_maybe_attach_backtrace(MalFormed, 1);
    var
     p = (n1 & 15) << 12 | (n2 & 63) << 6 | n3 & 63,
     a = 55296 <= p ? 1 : 0,
     h = a ? p <= 57088 ? 1 : 0 : a;
    if(h) throw caml_maybe_attach_backtrace(MalFormed, 1);
    return p;
   }
   function check_four(n1, n2, n3, n4){
    if(n1 === 240){
     var c = n2 < 144 ? 1 : 0, d = c || (191 < n2 ? 1 : 0);
     if(d) throw caml_maybe_attach_backtrace(MalFormed, 1);
     var e = n3 < 128 ? 1 : 0, f = e || (191 < n3 ? 1 : 0);
     if(f) throw caml_maybe_attach_backtrace(MalFormed, 1);
     var g = n4 < 128 ? 1 : 0, h = g || (191 < n4 ? 1 : 0);
     if(h) throw caml_maybe_attach_backtrace(MalFormed, 1);
    }
    else if(n1 === 244){
     var j = n2 < 128 ? 1 : 0, k = j || (143 < n2 ? 1 : 0);
     if(k) throw caml_maybe_attach_backtrace(MalFormed, 1);
     var l = n3 < 128 ? 1 : 0, m = l || (191 < n3 ? 1 : 0);
     if(m) throw caml_maybe_attach_backtrace(MalFormed, 1);
     var n = n4 < 128 ? 1 : 0, o = n || (191 < n4 ? 1 : 0);
     if(o) throw caml_maybe_attach_backtrace(MalFormed, 1);
    }
    else{
     var p = n1 < 241 ? 1 : 0, q = p || (243 < n1 ? 1 : 0);
     if(q) throw caml_maybe_attach_backtrace(MalFormed, 1);
     var r = n2 < 128 ? 1 : 0, s = r || (191 < n2 ? 1 : 0);
     if(s) throw caml_maybe_attach_backtrace(MalFormed, 1);
     var t = n3 < 128 ? 1 : 0, u = t || (191 < n3 ? 1 : 0);
     if(u) throw caml_maybe_attach_backtrace(MalFormed, 1);
     var v = n4 < 128 ? 1 : 0, w = v || (191 < n4 ? 1 : 0);
     if(w) throw caml_maybe_attach_backtrace(MalFormed, 1);
    }
    var a = 2 !== (n2 >>> 6 | 0) ? 1 : 0;
    if(a)
     var b = a;
    else
     var
      i = 2 !== (n3 >>> 6 | 0) ? 1 : 0,
      b = i || (2 !== (n4 >>> 6 | 0) ? 1 : 0);
    if(b) throw caml_maybe_attach_backtrace(MalFormed, 1);
    return (n1 & 7) << 18 | (n2 & 63) << 12 | (n3 & 63) << 6 | n4 & 63;
   }
   function from_channel$0(ic){
    return make_from_channel
            ([0, utf_8_byte_length],
             ic,
             4,
             1,
             function(can_refill, t){
              var w = width(get(t, 0));
              ensure_bytes_available(t, can_refill, w);
              var
               i = t[4],
               s = caml_call1(Stdlib_Bytes[44], t[1]),
               c1 = caml_string_get(s, i),
               switcher = width(c1) - 1 | 0;
              if(3 < switcher >>> 0)
               throw caml_maybe_attach_backtrace([0, Assert_failure, b], 1);
              switch(switcher){
                case 1:
                 var
                  n2 = caml_string_get(s, i + 1 | 0),
                  c = check_two(c1, n2);
                 break;
                case 2:
                 var
                  n2$0 = caml_string_get(s, i + 1 | 0),
                  n3 = caml_string_get(s, i + 2 | 0),
                  c = check_three(c1, n2$0, n3);
                 break;
                case 3:
                 var
                  n2$1 = caml_string_get(s, i + 1 | 0),
                  n3$0 = caml_string_get(s, i + 2 | 0),
                  n4 = caml_string_get(s, i + 3 | 0),
                  c = check_four(c1, n2$1, n3$0, n4);
                 break;
                default: var c = c1;
              }
              advance(t, w);
              return of_int(c);
             });
   }
   function from_gen$1(s){
    function next_or_fail(param){
     var match = caml_call1(Gen[2], s);
     if(! match) throw caml_maybe_attach_backtrace(MalFormed, 1);
     var x = match[1];
     return x;
    }
    return from_gen
            ([0, utf_8_byte_length],
             function(param){
              var o = caml_call1(Gen[2], s);
              if(! o) return 0;
              var c1 = o[1], switcher = width(c1) - 1 | 0;
              if(3 < switcher >>> 0)
               throw caml_maybe_attach_backtrace(MalFormed, 1);
              switch(switcher){
                case 0:
                 var a = caml_call1(of_char, c1); break;
                case 1:
                 var n2 = next_or_fail(0), a = of_int(check_two(c1, n2));
                 break;
                case 2:
                 var
                  n2$0 = next_or_fail(0),
                  n3 = next_or_fail(0),
                  a = of_int(check_three(c1, n2$0, n3));
                 break;
                default:
                 var
                  n2$1 = next_or_fail(0),
                  n3$0 = next_or_fail(0),
                  n4 = next_or_fail(0),
                  a = of_int(check_four(c1, n2$1, n3$0, n4));
              }
              return [0, a];
             });
   }
   function from_string$0(s){
    return from_gen$1
            (caml_call2
              (Gen[12],
               [0, caml_ml_string_length(s)],
               function(i){return caml_string_get(s, i);}));
   }
   function sub_lexeme$1(lexbuf, pos, len){
    var
     buf = caml_call1(Stdlib_Buffer[1], len * 4 | 0),
     apos = lexbuf[12] + pos | 0,
     a = lexbuf[3],
     b = (apos + len | 0) - 1 | 0;
    if(b >= apos){
     var i = apos;
     for(;;){
      var c = caml_check_bound(a, i)[i + 1];
      caml_call2(Stdlib_Buffer[13], buf, c);
      var d = i + 1 | 0;
      if(b === i) break;
      i = d;
     }
    }
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function lexeme$1(lexbuf){
    return sub_lexeme$1(lexbuf, 0, lexbuf[7] - lexbuf[12] | 0);
   }
   function number_of_pair(bo, c1, c2){
    return bo ? (c1 << 8) + c2 | 0 : (c2 << 8) + c1 | 0;
   }
   function get_bo(bo, c1, c2){
    var match = bo[1];
    if(match){var o = match[1]; return o;}
    a:
    {if(255 === c1 && 254 === c2){var o$0 = 0; break a;} var o$0 = 1;}
    bo[1] = [0, o$0];
    return o$0;
   }
   function from_channel$1(ic, opt_bo){
    var bo = [0, opt_bo];
    return make_from_channel
            ([0, utf_16_byte_length],
             ic,
             4,
             2,
             function(can_refill, t){
              var
               n1 = get(t, 0),
               n2 = get(t, 1),
               o = get_bo(bo, n1, n2),
               w1 = number_of_pair(o, n1, n2);
              if(w1 === 65534)
               throw caml_maybe_attach_backtrace([0, InvalidCodepoint, w1], 1);
              if(55296 <= w1 && 57343 >= w1){
               if(56319 < w1) throw caml_maybe_attach_backtrace(MalFormed, 1);
               ensure_bytes_available(t, can_refill, 4);
               var
                n3 = get(t, 2),
                n4 = get(t, 3),
                w2 = number_of_pair(o, n3, n4),
                a = w2 < 56320 ? 1 : 0,
                b = a || (57343 < w2 ? 1 : 0);
               if(b) throw caml_maybe_attach_backtrace(MalFormed, 1);
               var upper10 = (w1 & 1023) << 10, lower10 = w2 & 1023;
               advance(t, 4);
               return of_int((65536 + upper10 | 0) + lower10 | 0);
              }
              advance(t, 2);
              return of_int(w1);
             });
   }
   function from_gen$2(s, opt_bo){
    function next_or_fail(param){
     var match = caml_call1(Gen[2], s);
     if(! match) throw caml_maybe_attach_backtrace(MalFormed, 1);
     var x = match[1];
     return x;
    }
    var bo = [0, opt_bo];
    return from_gen
            ([0, utf_16_byte_length],
             function(param){
              var o$0 = caml_call1(Gen[2], s);
              if(! o$0) return 0;
              var
               c1 = o$0[1],
               n2 = next_or_fail(0),
               o = get_bo(bo, c1, n2),
               w1 = number_of_pair(o, c1, n2);
              if(w1 === 65534)
               throw caml_maybe_attach_backtrace([0, InvalidCodepoint, w1], 1);
              a:
              {
               if(55296 <= w1 && 57343 >= w1){
                if(56319 < w1)
                 throw caml_maybe_attach_backtrace(MalFormed, 1);
                var
                 n3 = next_or_fail(0),
                 n4 = next_or_fail(0),
                 w2 = number_of_pair(o, n3, n4),
                 b = w2 < 56320 ? 1 : 0,
                 c = b || (57343 < w2 ? 1 : 0);
                if(c) throw caml_maybe_attach_backtrace(MalFormed, 1);
                var
                 upper10 = (w1 & 1023) << 10,
                 lower10 = w2 & 1023,
                 a = of_int((65536 + upper10 | 0) + lower10 | 0);
                break a;
               }
               var a = of_int(w1);
              }
              return [0, a];
             });
   }
   function from_string$1(s){
    var
     a =
       caml_call2
        (Gen[12],
         [0, caml_ml_string_length(s)],
         function(i){return caml_string_get(s, i);});
    return function(b){return from_gen$2(a, b);};
   }
   function sub_lexeme$2(lb, pos, len, bo, bom){
    var
     buf = caml_call1(Stdlib_Buffer[1], (len * 4 | 0) + 2 | 0),
     apos = lb[12] + pos | 0,
     a = lb[3],
     store =
       bo
        ? caml_call1(Stdlib_Buffer[15], buf)
        : caml_call1(Stdlib_Buffer[14], buf);
    if(bom) caml_call1(store, of_int(65279));
    var b = (apos + len | 0) - 1 | 0;
    if(b >= apos){
     var i = apos;
     for(;;){
      caml_call1(store, caml_check_bound(a, i)[i + 1]);
      var c = i + 1 | 0;
      if(b === i) break;
      i = c;
     }
    }
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function lexeme$2(lb, bo, bom){
    return sub_lexeme$2(lb, 0, lb[7] - lb[12] | 0, bo, bom);
   }
   var
    Sedlexing =
      [0,
       InvalidCodepoint,
       MalFormed,
       create,
       set_position,
       set_filename,
       from_gen,
       from_int_array,
       from_uchar_array,
       lexeme_start,
       lexeme_bytes_start,
       lexeme_end,
       lexeme_bytes_end,
       loc,
       bytes_loc,
       lexeme_length,
       lexeme_bytes_length,
       lexing_positions,
       lexing_position_start,
       lexing_position_curr,
       lexing_bytes_positions,
       lexing_bytes_position_start,
       lexing_bytes_position_curr,
       new_line,
       lexeme,
       lexeme_char,
       sub_lexeme,
       rollback,
       start,
       next,
       private_next_int,
       mark,
       backtrack,
       with_tokenizer,
       [0,
        from_gen$0,
        from_channel,
        from_string,
        lexeme$0,
        sub_lexeme$0,
        lexeme_char$0],
       [0,
        from_gen$1,
        from_channel$0,
        from_string$0,
        lexeme$1,
        sub_lexeme$1,
        [0, width, check_two, check_three, check_four]],
       [0, from_gen$2, from_channel$1, from_string$1, lexeme$2, sub_lexeme$2]];
   runtime.caml_register_global(20, Sedlexing, "Sedlexing");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VkbGV4LmNtYS5qcyIsInNlY3Rpb25zIjpbeyJvZmZzZXQiOnsibGluZSI6MTAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VkbGV4LmNtYS5qcyIsInNvdXJjZXMiOlsiL2J1aWx0aW4vYmxhY2tib3gubWwiLCIvVXNlcnMvZmFiaWFuLy5vcGFtL2RlZmF1bHQvbGliL3NlZGxleC9zZWRsZXhpbmcubWwiXSwic291cmNlc0NvbnRlbnQiOlsiKCogZ2VuZXJhdGVkIGNvZGUgKikiLCIoKiBUaGUgcGFja2FnZSBzZWRsZXggaXMgcmVsZWFzZWQgdW5kZXIgdGhlIHRlcm1zIG9mIGFuIE1JVC1saWtlIGxpY2Vuc2UuICopXG4oKiBTZWUgdGhlIGF0dGFjaGVkIExJQ0VOU0UgZmlsZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiBDb3B5cmlnaHQgMjAwNSwgMjAxMyBieSBBbGFpbiBGcmlzY2ggYW5kIExleGlGaS4gICAgICAgICAgICAgICAgICAgICAgICopXG5cbmV4Y2VwdGlvbiBJbnZhbGlkQ29kZXBvaW50IG9mIGludFxuZXhjZXB0aW9uIE1hbEZvcm1lZFxuXG5tb2R1bGUgVWNoYXIgPSBzdHJ1Y3RcbiAgKCogVGhpcyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG9jYW1sIDwgNC4xNC4wICopXG4gIGxldCB1dGZfOF9ieXRlX2xlbmd0aCB1ID1cbiAgICBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gICAgICB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgdSB3aGVuIHUgPD0gMHgwMDdGIC0+IDFcbiAgICAgIHwgdSB3aGVuIHUgPD0gMHgwN0ZGIC0+IDJcbiAgICAgIHwgdSB3aGVuIHUgPD0gMHhGRkZGIC0+IDNcbiAgICAgIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT4gNFxuICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIGxldCB1dGZfMTZfYnl0ZV9sZW5ndGggdSA9XG4gICAgbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuICAgICAgfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPiAyXG4gICAgICB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+IDRcbiAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICBsZXQgKCkgPVxuICAgIGlnbm9yZSB1dGZfOF9ieXRlX2xlbmd0aDtcbiAgICBpZ25vcmUgdXRmXzE2X2J5dGVfbGVuZ3RoXG5cbiAgaW5jbHVkZSBVY2hhclxuXG4gIGxldCBvZl9pbnQgeCA9XG4gICAgaWYgVWNoYXIuaXNfdmFsaWQgeCB0aGVuIFVjaGFyLnVuc2FmZV9vZl9pbnQgeCBlbHNlIHJhaXNlIE1hbEZvcm1lZFxuZW5kXG5cbigqIHNoYWRvdyBwb2x5bW9ycGhpYyBlcXVhbCAqKVxubGV0ICggPSApIChhIDogaW50KSBiID0gYSA9IGJcbmxldCAoID4+fCApIG8gZiA9IG1hdGNoIG8gd2l0aCBTb21lIHggLT4gU29tZSAoZiB4KSB8IE5vbmUgLT4gTm9uZVxuXG4oKiBBYnNvbHV0ZSBwb3NpdGlvbiBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmVhbSAqKVxudHlwZSBhcG9zID0gaW50XG5cbnR5cGUgbGV4YnVmID0ge1xuICByZWZpbGwgOiBVY2hhci50IGFycmF5IC0+IGludCAtPiBpbnQgLT4gaW50O1xuICBieXRlc19wZXJfY2hhciA6IFVjaGFyLnQgLT4gaW50O1xuICBtdXRhYmxlIGJ1ZiA6IFVjaGFyLnQgYXJyYXk7XG4gIG11dGFibGUgbGVuIDogaW50O1xuICAoKiBOdW1iZXIgb2YgbWVhbmluZ2Z1bCB1Y2hhciBpbiBidWZmZXIgKilcbiAgbXV0YWJsZSBvZmZzZXQgOiBhcG9zO1xuICAoKiBOdW1iZXIgb2YgbWVhbmluZ2Z1bCBieXRlcyBpbiBidWZmZXIgKilcbiAgbXV0YWJsZSBieXRlc19vZmZzZXQgOiBhcG9zO1xuICAoKiBQb3NpdGlvbiBvZiB0aGUgZmlyc3QgdWNoYXIgaW4gYnVmZmVyXG4gICAgICBpbiB0aGUgaW5wdXQgc3RyZWFtICopXG4gIG11dGFibGUgcG9zIDogaW50O1xuICAoKiBQb3NpdGlvbiBvZiB0aGUgZmlyc3QgYnl0ZSBpbiBidWZmZXJcbiAgICAgIGluIHRoZSBpbnB1dCBzdHJlYW0gKilcbiAgbXV0YWJsZSBieXRlc19wb3MgOiBpbnQ7XG4gICgqIFBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmUgaW4gdGhlIGJ1ZmZlciwgaW4gdWNoYXIgKilcbiAgbXV0YWJsZSBjdXJyX2JvbCA6IGludDtcbiAgKCogUG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgbGluZSBpbiB0aGUgYnVmZmVyLCBpbiBieXRlcyAqKVxuICBtdXRhYmxlIGN1cnJfYnl0ZXNfYm9sIDogaW50O1xuICAoKiBJbmRleCBvZiB0aGUgY3VycmVudCBsaW5lIGluIHRoZSBpbnB1dCBzdHJlYW0uICopXG4gIG11dGFibGUgY3Vycl9saW5lIDogaW50O1xuICAoKiBzdGFydGluZyBwb3NpdGlvbiwgaW4gdWNoYXIuICopXG4gIG11dGFibGUgc3RhcnRfcG9zIDogaW50O1xuICAoKiBzdGFydGluZyBwb3NpdGlvbiwgaW4gYnl0ZXMuICopXG4gIG11dGFibGUgc3RhcnRfYnl0ZXNfcG9zIDogaW50O1xuICAoKiBGaXJzdCB1Y2hhciB3ZSBuZWVkIHRvIGtlZXAgdmlzaWJsZSAqKVxuICBtdXRhYmxlIHN0YXJ0X2JvbCA6IGludDtcbiAgKCogRmlyc3QgYnl0ZSB3ZSBuZWVkIHRvIGtlZXAgdmlzaWJsZSAqKVxuICBtdXRhYmxlIHN0YXJ0X2J5dGVzX2JvbCA6IGludDtcbiAgKCogc3RhcnQgZnJvbSAxICopXG4gIG11dGFibGUgc3RhcnRfbGluZSA6IGludDtcbiAgbXV0YWJsZSBtYXJrZWRfcG9zIDogaW50O1xuICBtdXRhYmxlIG1hcmtlZF9ieXRlc19wb3MgOiBpbnQ7XG4gIG11dGFibGUgbWFya2VkX2JvbCA6IGludDtcbiAgbXV0YWJsZSBtYXJrZWRfYnl0ZXNfYm9sIDogaW50O1xuICBtdXRhYmxlIG1hcmtlZF9saW5lIDogaW50O1xuICBtdXRhYmxlIG1hcmtlZF92YWwgOiBpbnQ7XG4gIG11dGFibGUgZmlsZW5hbWUgOiBzdHJpbmc7XG4gIG11dGFibGUgZmluaXNoZWQgOiBib29sO1xufVxuXG5sZXQgY2h1bmtfc2l6ZSA9IDUxMlxuXG5sZXQgZW1wdHlfbGV4YnVmIGJ5dGVzX3Blcl9jaGFyID1cbiAge1xuICAgIHJlZmlsbCA9IChmdW4gXyBfIF8gLT4gYXNzZXJ0IGZhbHNlKTtcbiAgICBieXRlc19wZXJfY2hhcjtcbiAgICBidWYgPSBbfHxdO1xuICAgIGxlbiA9IDA7XG4gICAgb2Zmc2V0ID0gMDtcbiAgICBieXRlc19vZmZzZXQgPSAwO1xuICAgIHBvcyA9IDA7XG4gICAgYnl0ZXNfcG9zID0gMDtcbiAgICBjdXJyX2JvbCA9IDA7XG4gICAgY3Vycl9ieXRlc19ib2wgPSAwO1xuICAgIGN1cnJfbGluZSA9IDE7XG4gICAgc3RhcnRfcG9zID0gMDtcbiAgICBzdGFydF9ieXRlc19wb3MgPSAwO1xuICAgIHN0YXJ0X2JvbCA9IDA7XG4gICAgc3RhcnRfYnl0ZXNfYm9sID0gMDtcbiAgICBzdGFydF9saW5lID0gMDtcbiAgICBtYXJrZWRfcG9zID0gMDtcbiAgICBtYXJrZWRfYnl0ZXNfcG9zID0gMDtcbiAgICBtYXJrZWRfYm9sID0gMDtcbiAgICBtYXJrZWRfYnl0ZXNfYm9sID0gMDtcbiAgICBtYXJrZWRfbGluZSA9IDA7XG4gICAgbWFya2VkX3ZhbCA9IDA7XG4gICAgZmlsZW5hbWUgPSBcIlwiO1xuICAgIGZpbmlzaGVkID0gZmFsc2U7XG4gIH1cblxubGV0IGR1bW15X3VjaGFyID0gVWNoYXIub2ZfaW50IDBcbmxldCBubF91Y2hhciA9IFVjaGFyLm9mX2ludCAxMFxuXG5sZXQgY3JlYXRlID8oYnl0ZXNfcGVyX2NoYXIgPSBmdW4gXyAtPiAxKSByZWZpbGwgPVxuICB7XG4gICAgKGVtcHR5X2xleGJ1ZiBieXRlc19wZXJfY2hhcikgd2l0aFxuICAgIHJlZmlsbDtcbiAgICBidWYgPSBBcnJheS5tYWtlIGNodW5rX3NpemUgZHVtbXlfdWNoYXI7XG4gIH1cblxubGV0IHNldF9wb3NpdGlvbiA/Ynl0ZXNfcG9zaXRpb24gbGV4YnVmIHBvc2l0aW9uID1cbiAgbGV4YnVmLm9mZnNldCA8LSBwb3NpdGlvbi5MZXhpbmcucG9zX2NudW0gLSBsZXhidWYucG9zO1xuICBsZXhidWYuY3Vycl9ib2wgPC0gcG9zaXRpb24uTGV4aW5nLnBvc19ib2w7XG4gIGxleGJ1Zi5jdXJyX2xpbmUgPC0gcG9zaXRpb24uTGV4aW5nLnBvc19sbnVtO1xuICBsZXQgYnl0ZXNfcG9zaXRpb24gPSBPcHRpb24udmFsdWUgfmRlZmF1bHQ6cG9zaXRpb24gYnl0ZXNfcG9zaXRpb24gaW5cbiAgbGV4YnVmLmJ5dGVzX29mZnNldCA8LSBieXRlc19wb3NpdGlvbi5MZXhpbmcucG9zX2NudW0gLSBsZXhidWYuYnl0ZXNfcG9zO1xuICBsZXhidWYuY3Vycl9ieXRlc19ib2wgPC0gYnl0ZXNfcG9zaXRpb24uTGV4aW5nLnBvc19ib2xcblxubGV0IHNldF9maWxlbmFtZSBsZXhidWYgZm5hbWUgPSBsZXhidWYuZmlsZW5hbWUgPC0gZm5hbWVcblxubGV0IGZyb21fZ2VuID9ieXRlc19wZXJfY2hhciBnZW4gPVxuICBsZXQgbWFsZm9ybWVkID0gcmVmIGZhbHNlIGluXG4gIGxldCByZWZpbGwgYnVmIHBvcyBsZW4gPVxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmICFtYWxmb3JtZWQgdGhlbiByYWlzZSBNYWxGb3JtZWQ7XG4gICAgICBpZiBpID49IGxlbiB0aGVuIGxlblxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIGdlbiAoKSB3aXRoXG4gICAgICAgICAgfCBTb21lIGMgLT5cbiAgICAgICAgICAgICAgYnVmLihwb3MgKyBpKSA8LSBjO1xuICAgICAgICAgICAgICBsb29wIChpICsgMSlcbiAgICAgICAgICB8IE5vbmUgLT4gaVxuICAgICAgICAgIHwgZXhjZXB0aW9uIE1hbEZvcm1lZCB3aGVuIGkgPD4gMCAtPlxuICAgICAgICAgICAgICBtYWxmb3JtZWQgOj0gdHJ1ZTtcbiAgICAgICAgICAgICAgaSlcbiAgICBpblxuICAgIGxvb3AgMFxuICBpblxuICBjcmVhdGUgP2J5dGVzX3Blcl9jaGFyIHJlZmlsbFxuXG5sZXQgZnJvbV9pbnRfYXJyYXkgP2J5dGVzX3Blcl9jaGFyIGEgPVxuICBmcm9tX2dlbiA/Ynl0ZXNfcGVyX2NoYXJcbiAgICAoR2VuLmluaXQgfmxpbWl0OihBcnJheS5sZW5ndGggYSkgKGZ1biBpIC0+IFVjaGFyLm9mX2ludCBhLihpKSkpXG5cbmxldCBmcm9tX3VjaGFyX2FycmF5ID8oYnl0ZXNfcGVyX2NoYXIgPSBmdW4gXyAtPiAxKSBhID1cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBhIGluXG4gIHtcbiAgICAoZW1wdHlfbGV4YnVmIGJ5dGVzX3Blcl9jaGFyKSB3aXRoXG4gICAgYnVmID0gQXJyYXkuaW5pdCBsZW4gKGZ1biBpIC0+IGEuKGkpKTtcbiAgICBsZW47XG4gICAgZmluaXNoZWQgPSB0cnVlO1xuICB9XG5cbmxldCByZWZpbGwgbGV4YnVmID1cbiAgaWYgbGV4YnVmLmxlbiArIGNodW5rX3NpemUgPiBBcnJheS5sZW5ndGggbGV4YnVmLmJ1ZiB0aGVuIGJlZ2luXG4gICAgbGV0IHMgPSBsZXhidWYuc3RhcnRfcG9zIGluXG4gICAgbGV0IHNfYnl0ZXMgPSBsZXhidWYuc3RhcnRfYnl0ZXNfcG9zIGluXG4gICAgbGV0IGxzID0gbGV4YnVmLmxlbiAtIHMgaW5cbiAgICBpZiBscyArIGNodW5rX3NpemUgPD0gQXJyYXkubGVuZ3RoIGxleGJ1Zi5idWYgdGhlblxuICAgICAgQXJyYXkuYmxpdCBsZXhidWYuYnVmIHMgbGV4YnVmLmJ1ZiAwIGxzXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IG5ld2xlbiA9IChBcnJheS5sZW5ndGggbGV4YnVmLmJ1ZiArIGNodW5rX3NpemUpICogMiBpblxuICAgICAgbGV0IG5ld2J1ZiA9IEFycmF5Lm1ha2UgbmV3bGVuIGR1bW15X3VjaGFyIGluXG4gICAgICBBcnJheS5ibGl0IGxleGJ1Zi5idWYgcyBuZXdidWYgMCBscztcbiAgICAgIGxleGJ1Zi5idWYgPC0gbmV3YnVmXG4gICAgZW5kO1xuICAgIGxleGJ1Zi5sZW4gPC0gbHM7XG4gICAgbGV4YnVmLm9mZnNldCA8LSBsZXhidWYub2Zmc2V0ICsgcztcbiAgICBsZXhidWYuYnl0ZXNfb2Zmc2V0IDwtIGxleGJ1Zi5ieXRlc19vZmZzZXQgKyBzX2J5dGVzO1xuICAgIGxleGJ1Zi5wb3MgPC0gbGV4YnVmLnBvcyAtIHM7XG4gICAgbGV4YnVmLmJ5dGVzX3BvcyA8LSBsZXhidWYuYnl0ZXNfcG9zIC0gc19ieXRlcztcbiAgICBsZXhidWYubWFya2VkX3BvcyA8LSBsZXhidWYubWFya2VkX3BvcyAtIHM7XG4gICAgbGV4YnVmLm1hcmtlZF9ieXRlc19wb3MgPC0gbGV4YnVmLm1hcmtlZF9ieXRlc19wb3MgLSBzX2J5dGVzO1xuICAgIGxleGJ1Zi5zdGFydF9wb3MgPC0gMDtcbiAgICBsZXhidWYuc3RhcnRfYnl0ZXNfcG9zIDwtIDBcbiAgZW5kO1xuICBsZXQgbiA9IGxleGJ1Zi5yZWZpbGwgbGV4YnVmLmJ1ZiBsZXhidWYucG9zIGNodW5rX3NpemUgaW5cbiAgaWYgbiA9IDAgdGhlbiBsZXhidWYuZmluaXNoZWQgPC0gdHJ1ZSBlbHNlIGxleGJ1Zi5sZW4gPC0gbGV4YnVmLmxlbiArIG5cblxubGV0IG5ld19saW5lIGxleGJ1ZiA9XG4gIGxleGJ1Zi5jdXJyX2xpbmUgPC0gbGV4YnVmLmN1cnJfbGluZSArIDE7XG4gIGxleGJ1Zi5jdXJyX2JvbCA8LSBsZXhidWYucG9zICsgbGV4YnVmLm9mZnNldDtcbiAgbGV4YnVmLmN1cnJfYnl0ZXNfYm9sIDwtIGxleGJ1Zi5ieXRlc19wb3MgKyBsZXhidWYuYnl0ZXNfb2Zmc2V0XG5cbmxldFtAaW5saW5lIGFsd2F5c10gbmV4dF9hdXggc29tZSBub25lIGxleGJ1ZiA9XG4gIGlmIChub3QgbGV4YnVmLmZpbmlzaGVkKSAmJiBsZXhidWYucG9zID0gbGV4YnVmLmxlbiB0aGVuIHJlZmlsbCBsZXhidWY7XG4gIGlmIGxleGJ1Zi5maW5pc2hlZCAmJiBsZXhidWYucG9zID0gbGV4YnVmLmxlbiB0aGVuIG5vbmVcbiAgZWxzZSBiZWdpblxuICAgIGxldCByZXQgPSBsZXhidWYuYnVmLihsZXhidWYucG9zKSBpblxuICAgIGxleGJ1Zi5wb3MgPC0gbGV4YnVmLnBvcyArIDE7XG4gICAgbGV4YnVmLmJ5dGVzX3BvcyA8LSBsZXhidWYuYnl0ZXNfcG9zICsgbGV4YnVmLmJ5dGVzX3Blcl9jaGFyIHJldDtcbiAgICBpZiBVY2hhci5lcXVhbCByZXQgbmxfdWNoYXIgdGhlbiBuZXdfbGluZSBsZXhidWY7XG4gICAgc29tZSByZXRcbiAgZW5kXG5cbmxldCBuZXh0IGxleGJ1ZiA9IChuZXh0X2F1eCBbQGlubGluZWRdKSAoZnVuIHggLT4gU29tZSB4KSBOb25lIGxleGJ1ZlxubGV0IF9fcHJpdmF0ZV9fbmV4dF9pbnQgbGV4YnVmID0gKG5leHRfYXV4IFtAaW5saW5lZF0pIFVjaGFyLnRvX2ludCAoLTEpIGxleGJ1ZlxuXG5sZXQgbWFyayBsZXhidWYgaSA9XG4gIGxleGJ1Zi5tYXJrZWRfcG9zIDwtIGxleGJ1Zi5wb3M7XG4gIGxleGJ1Zi5tYXJrZWRfYnl0ZXNfcG9zIDwtIGxleGJ1Zi5ieXRlc19wb3M7XG4gIGxleGJ1Zi5tYXJrZWRfYm9sIDwtIGxleGJ1Zi5jdXJyX2JvbDtcbiAgbGV4YnVmLm1hcmtlZF9ieXRlc19ib2wgPC0gbGV4YnVmLmN1cnJfYnl0ZXNfYm9sO1xuICBsZXhidWYubWFya2VkX2xpbmUgPC0gbGV4YnVmLmN1cnJfbGluZTtcbiAgbGV4YnVmLm1hcmtlZF92YWwgPC0gaVxuXG5sZXQgc3RhcnQgbGV4YnVmID1cbiAgbGV4YnVmLnN0YXJ0X3BvcyA8LSBsZXhidWYucG9zO1xuICBsZXhidWYuc3RhcnRfYnl0ZXNfcG9zIDwtIGxleGJ1Zi5ieXRlc19wb3M7XG4gIGxleGJ1Zi5zdGFydF9ib2wgPC0gbGV4YnVmLmN1cnJfYm9sO1xuICBsZXhidWYuc3RhcnRfYnl0ZXNfYm9sIDwtIGxleGJ1Zi5jdXJyX2J5dGVzX2JvbDtcbiAgbGV4YnVmLnN0YXJ0X2xpbmUgPC0gbGV4YnVmLmN1cnJfbGluZTtcbiAgbWFyayBsZXhidWYgKC0xKVxuXG5sZXQgYmFja3RyYWNrIGxleGJ1ZiA9XG4gIGxleGJ1Zi5wb3MgPC0gbGV4YnVmLm1hcmtlZF9wb3M7XG4gIGxleGJ1Zi5ieXRlc19wb3MgPC0gbGV4YnVmLm1hcmtlZF9ieXRlc19wb3M7XG4gIGxleGJ1Zi5jdXJyX2JvbCA8LSBsZXhidWYubWFya2VkX2JvbDtcbiAgbGV4YnVmLmN1cnJfYnl0ZXNfYm9sIDwtIGxleGJ1Zi5tYXJrZWRfYnl0ZXNfYm9sO1xuICBsZXhidWYuY3Vycl9saW5lIDwtIGxleGJ1Zi5tYXJrZWRfbGluZTtcbiAgbGV4YnVmLm1hcmtlZF92YWxcblxubGV0IHJvbGxiYWNrIGxleGJ1ZiA9XG4gIGxleGJ1Zi5wb3MgPC0gbGV4YnVmLnN0YXJ0X3BvcztcbiAgbGV4YnVmLmJ5dGVzX3BvcyA8LSBsZXhidWYuc3RhcnRfYnl0ZXNfcG9zO1xuICBsZXhidWYuY3Vycl9ib2wgPC0gbGV4YnVmLnN0YXJ0X2JvbDtcbiAgbGV4YnVmLmN1cnJfYnl0ZXNfYm9sIDwtIGxleGJ1Zi5zdGFydF9ieXRlc19ib2w7XG4gIGxleGJ1Zi5jdXJyX2xpbmUgPC0gbGV4YnVmLnN0YXJ0X2xpbmVcblxubGV0IGxleGVtZV9zdGFydCBsZXhidWYgPSBsZXhidWYuc3RhcnRfcG9zICsgbGV4YnVmLm9mZnNldFxubGV0IGxleGVtZV9ieXRlc19zdGFydCBsZXhidWYgPSBsZXhidWYuc3RhcnRfYnl0ZXNfcG9zICsgbGV4YnVmLmJ5dGVzX29mZnNldFxubGV0IGxleGVtZV9lbmQgbGV4YnVmID0gbGV4YnVmLnBvcyArIGxleGJ1Zi5vZmZzZXRcbmxldCBsZXhlbWVfYnl0ZXNfZW5kIGxleGJ1ZiA9IGxleGJ1Zi5ieXRlc19wb3MgKyBsZXhidWYuYnl0ZXNfb2Zmc2V0XG5sZXQgbG9jIGxleGJ1ZiA9IChsZXhidWYuc3RhcnRfcG9zICsgbGV4YnVmLm9mZnNldCwgbGV4YnVmLnBvcyArIGxleGJ1Zi5vZmZzZXQpXG5cbmxldCBieXRlc19sb2MgbGV4YnVmID1cbiAgKCBsZXhidWYuc3RhcnRfYnl0ZXNfcG9zICsgbGV4YnVmLmJ5dGVzX29mZnNldCxcbiAgICBsZXhidWYuYnl0ZXNfcG9zICsgbGV4YnVmLmJ5dGVzX29mZnNldCApXG5cbmxldCBsZXhlbWVfbGVuZ3RoIGxleGJ1ZiA9IGxleGJ1Zi5wb3MgLSBsZXhidWYuc3RhcnRfcG9zXG5sZXQgbGV4ZW1lX2J5dGVzX2xlbmd0aCBsZXhidWYgPSBsZXhidWYuYnl0ZXNfcG9zIC0gbGV4YnVmLnN0YXJ0X2J5dGVzX3Bvc1xuXG5sZXQgc3ViX2xleGVtZSBsZXhidWYgcG9zIGxlbiA9XG4gIEFycmF5LnN1YiBsZXhidWYuYnVmIChsZXhidWYuc3RhcnRfcG9zICsgcG9zKSBsZW5cblxubGV0IGxleGVtZSBsZXhidWYgPVxuICBBcnJheS5zdWIgbGV4YnVmLmJ1ZiBsZXhidWYuc3RhcnRfcG9zIChsZXhidWYucG9zIC0gbGV4YnVmLnN0YXJ0X3BvcylcblxubGV0IGxleGVtZV9jaGFyIGxleGJ1ZiBwb3MgPSBsZXhidWYuYnVmLihsZXhidWYuc3RhcnRfcG9zICsgcG9zKVxuXG5sZXQgbGV4aW5nX3Bvc2l0aW9uX3N0YXJ0IGxleGJ1ZiA9XG4gIHtcbiAgICBMZXhpbmcucG9zX2ZuYW1lID0gbGV4YnVmLmZpbGVuYW1lO1xuICAgIHBvc19sbnVtID0gbGV4YnVmLnN0YXJ0X2xpbmU7XG4gICAgcG9zX2NudW0gPSBsZXhidWYuc3RhcnRfcG9zICsgbGV4YnVmLm9mZnNldDtcbiAgICBwb3NfYm9sID0gbGV4YnVmLnN0YXJ0X2JvbDtcbiAgfVxuXG5sZXQgbGV4aW5nX3Bvc2l0aW9uX2N1cnIgbGV4YnVmID1cbiAge1xuICAgIExleGluZy5wb3NfZm5hbWUgPSBsZXhidWYuZmlsZW5hbWU7XG4gICAgcG9zX2xudW0gPSBsZXhidWYuY3Vycl9saW5lO1xuICAgIHBvc19jbnVtID0gbGV4YnVmLnBvcyArIGxleGJ1Zi5vZmZzZXQ7XG4gICAgcG9zX2JvbCA9IGxleGJ1Zi5jdXJyX2JvbDtcbiAgfVxuXG5sZXQgbGV4aW5nX3Bvc2l0aW9ucyBsZXhidWYgPVxuICBsZXQgc3RhcnRfcCA9IGxleGluZ19wb3NpdGlvbl9zdGFydCBsZXhidWZcbiAgYW5kIGN1cnJfcCA9IGxleGluZ19wb3NpdGlvbl9jdXJyIGxleGJ1ZiBpblxuICAoc3RhcnRfcCwgY3Vycl9wKVxuXG5sZXQgbGV4aW5nX2J5dGVzX3Bvc2l0aW9uX3N0YXJ0IGxleGJ1ZiA9XG4gIHtcbiAgICBMZXhpbmcucG9zX2ZuYW1lID0gbGV4YnVmLmZpbGVuYW1lO1xuICAgIHBvc19sbnVtID0gbGV4YnVmLnN0YXJ0X2xpbmU7XG4gICAgcG9zX2NudW0gPSBsZXhidWYuc3RhcnRfYnl0ZXNfcG9zICsgbGV4YnVmLmJ5dGVzX29mZnNldDtcbiAgICBwb3NfYm9sID0gbGV4YnVmLnN0YXJ0X2J5dGVzX2JvbDtcbiAgfVxuXG5sZXQgbGV4aW5nX2J5dGVzX3Bvc2l0aW9uX2N1cnIgbGV4YnVmID1cbiAge1xuICAgIExleGluZy5wb3NfZm5hbWUgPSBsZXhidWYuZmlsZW5hbWU7XG4gICAgcG9zX2xudW0gPSBsZXhidWYuY3Vycl9saW5lO1xuICAgIHBvc19jbnVtID0gbGV4YnVmLmJ5dGVzX3BvcyArIGxleGJ1Zi5ieXRlc19vZmZzZXQ7XG4gICAgcG9zX2JvbCA9IGxleGJ1Zi5jdXJyX2J5dGVzX2JvbDtcbiAgfVxuXG5sZXQgbGV4aW5nX2J5dGVzX3Bvc2l0aW9ucyBsZXhidWYgPVxuICBsZXQgc3RhcnRfcCA9IGxleGluZ19ieXRlc19wb3NpdGlvbl9zdGFydCBsZXhidWZcbiAgYW5kIGN1cnJfcCA9IGxleGluZ19ieXRlc19wb3NpdGlvbl9jdXJyIGxleGJ1ZiBpblxuICAoc3RhcnRfcCwgY3Vycl9wKVxuXG5sZXQgd2l0aF90b2tlbml6ZXIgbGV4ZXInIGxleGJ1ZiA9XG4gIGxldCBsZXhlciAoKSA9XG4gICAgbGV0IHRva2VuID0gbGV4ZXInIGxleGJ1ZiBpblxuICAgIGxldCBzdGFydF9wLCBjdXJyX3AgPSBsZXhpbmdfcG9zaXRpb25zIGxleGJ1ZiBpblxuICAgICh0b2tlbiwgc3RhcnRfcCwgY3Vycl9wKVxuICBpblxuICBsZXhlclxuXG5tb2R1bGUgQ2hhbiA9IHN0cnVjdFxuICBleGNlcHRpb24gTWlzc2luZ19pbnB1dFxuXG4gIHR5cGUgdCA9IHtcbiAgICBiIDogQnl0ZXMudDtcbiAgICBpYyA6IGluX2NoYW5uZWw7XG4gICAgbXV0YWJsZSBsZW4gOiBpbnQ7XG4gICAgbXV0YWJsZSBwb3MgOiBpbnQ7XG4gIH1cblxuICBsZXQgbWluX2J1ZmZlcl9zaXplID0gNjRcblxuICBsZXQgY3JlYXRlIGljIGxlbiA6IHQgPVxuICAgIGxldCBsZW4gPSBtYXggbGVuIG1pbl9idWZmZXJfc2l6ZSBpblxuICAgIHsgYiA9IEJ5dGVzLmNyZWF0ZSBsZW47IGljOyBsZW4gPSAwOyBwb3MgPSAwIH1cblxuICBsZXQgYXZhaWxhYmxlICh0IDogdCkgPSB0LmxlbiAtIHQucG9zXG5cbiAgbGV0IHJlYyBlbnN1cmVfYnl0ZXNfYXZhaWxhYmxlICh0IDogdCkgfmNhbl9yZWZpbGwgbiA9XG4gICAgaWYgYXZhaWxhYmxlIHQgPj0gbiB0aGVuICgpXG4gICAgZWxzZSBpZiBjYW5fcmVmaWxsIHRoZW4gKFxuICAgICAgbGV0IGxlbiA9IHQubGVuIC0gdC5wb3MgaW5cbiAgICAgIGlmIGxlbiA+IDAgdGhlbiBCeXRlcy5ibGl0IHQuYiB0LnBvcyB0LmIgMCBsZW47XG4gICAgICBsZXQgcmVhZCA9IGlucHV0IHQuaWMgdC5iIGxlbiAoQnl0ZXMubGVuZ3RoIHQuYiAtIGxlbikgaW5cbiAgICAgIHQubGVuIDwtIGxlbiArIHJlYWQ7XG4gICAgICB0LnBvcyA8LSAwO1xuICAgICAgaWYgcmVhZCA9IDAgdGhlbiByYWlzZSBNaXNzaW5nX2lucHV0XG4gICAgICBlbHNlIGVuc3VyZV9ieXRlc19hdmFpbGFibGUgdCB+Y2FuX3JlZmlsbCBuKVxuICAgIGVsc2UgcmFpc2UgTWlzc2luZ19pbnB1dFxuXG4gIGxldCBlbnN1cmVfYnl0ZXNfYXZhaWxhYmxlIHQgfmNhbl9yZWZpbGwgbiA9XG4gICAgKCogW25dIHNob3VsZCBub3QgZXhjZWVkIHRoZSBzaXplIG9mIHRoZSBidWZmZXIuIEhlcmUgd2UgYXJlXG4gICAgICAgY29uc2VydmF0aXZlIGFuZCBtYWtlIHN1cmUgaXQgZG9lc24ndCBleGNlZWQgdGhlIG1pbmludW0gc2l6ZVxuICAgICAgIGZvciB0aGUgYnVmZmVyLiAqKVxuICAgIGlmIG4gPD0gMCB8fCBuID4gbWluX2J1ZmZlcl9zaXplIHRoZW4gaW52YWxpZF9hcmcgXCJTZWRsZXhpbmcuQ2hhbi5lbnN1cmVcIjtcbiAgICBlbnN1cmVfYnl0ZXNfYXZhaWxhYmxlIHQgfmNhbl9yZWZpbGwgblxuXG4gIGxldCBnZXQgKHQgOiB0KSBpID0gQnl0ZXMuZ2V0IHQuYiAodC5wb3MgKyBpKVxuXG4gIGxldCBhZHZhbmNlICh0IDogdCkgbiA9XG4gICAgaWYgdC5wb3MgKyBuID4gdC5sZW4gdGhlbiBpbnZhbGlkX2FyZyBcImFkdmFuY2VcIjtcbiAgICB0LnBvcyA8LSB0LnBvcyArIG5cblxuICBsZXQgcmF3X2J1ZiAodCA6IHQpID0gdC5iXG4gIGxldCByYXdfcG9zICh0IDogdCkgPSB0LnBvc1xuZW5kXG5cbmxldCBtYWtlX2Zyb21fY2hhbm5lbCA/Ynl0ZXNfcGVyX2NoYXIgaWMgfm1heF9ieXRlc19wZXJfdWNoYXJcbiAgICB+bWluX2J5dGVzX3Blcl91Y2hhciB+cmVhZF91Y2hhciA9XG4gIGxldCB0ID0gQ2hhbi5jcmVhdGUgaWMgKGNodW5rX3NpemUgKiBtYXhfYnl0ZXNfcGVyX3VjaGFyKSBpblxuICBsZXQgbWFsZm9ybWVkID0gcmVmIGZhbHNlIGluXG4gIGxldCByZWZpbGwgYnVmIHBvcyBsZW4gPVxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmICFtYWxmb3JtZWQgdGhlbiByYWlzZSBNYWxGb3JtZWQ7XG4gICAgICBpZiBpID0gbGVuIHRoZW4gaVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoXG4gICAgICAgICAgKCogd2UgcmVmaWxsIG91ciBieXRlcyBidWZmZXIgb25seSBpZiB3ZSBoYXZlbid0IHJlZmlsbGVkIGFueSB1Y2hhciB5ZXQuICopXG4gICAgICAgICAgbGV0IGNhbl9yZWZpbGwgPSBpID0gMCBpblxuICAgICAgICAgIENoYW4uZW5zdXJlX2J5dGVzX2F2YWlsYWJsZSB0IH5jYW5fcmVmaWxsIG1pbl9ieXRlc19wZXJfdWNoYXI7XG4gICAgICAgICAgcmVhZF91Y2hhciB+Y2FuX3JlZmlsbCB0XG4gICAgICAgIHdpdGhcbiAgICAgICAgICB8IGMgLT5cbiAgICAgICAgICAgICAgYnVmLihwb3MgKyBpKSA8LSBjO1xuICAgICAgICAgICAgICBsb29wIChpICsgMSlcbiAgICAgICAgICB8IGV4Y2VwdGlvbiBNYWxGb3JtZWQgd2hlbiBpIDw+IDAgLT5cbiAgICAgICAgICAgICAgbWFsZm9ybWVkIDo9IHRydWU7XG4gICAgICAgICAgICAgIGlcbiAgICAgICAgICB8IGV4Y2VwdGlvbiBDaGFuLk1pc3NpbmdfaW5wdXQgLT5cbiAgICAgICAgICAgICAgaWYgaSA9IDAgJiYgQ2hhbi5hdmFpbGFibGUgdCA+IDAgdGhlbiByYWlzZSBNYWxGb3JtZWQ7XG4gICAgICAgICAgICAgIGkpXG4gICAgaW5cbiAgICBsb29wIDBcbiAgaW5cbiAgY3JlYXRlID9ieXRlc19wZXJfY2hhciByZWZpbGxcblxubW9kdWxlIExhdGluMSA9IHN0cnVjdFxuICBsZXQgZnJvbV9nZW4gcyA9XG4gICAgZnJvbV9nZW4gfmJ5dGVzX3Blcl9jaGFyOihmdW4gXyAtPiAxKSAoR2VuLm1hcCBVY2hhci5vZl9jaGFyIHMpXG5cbiAgbGV0IGZyb21fc3RyaW5nIHMgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICB7XG4gICAgICAoZW1wdHlfbGV4YnVmIChmdW4gXyAtPiAxKSkgd2l0aFxuICAgICAgYnVmID0gQXJyYXkuaW5pdCBsZW4gKGZ1biBpIC0+IFVjaGFyLm9mX2NoYXIgcy5baV0pO1xuICAgICAgbGVuO1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgIH1cblxuICBsZXQgZnJvbV9jaGFubmVsIGljID1cbiAgICBtYWtlX2Zyb21fY2hhbm5lbCBpY1xuICAgICAgfmJ5dGVzX3Blcl9jaGFyOihmdW4gXyAtPiAxKVxuICAgICAgfm1pbl9ieXRlc19wZXJfdWNoYXI6MSB+bWF4X2J5dGVzX3Blcl91Y2hhcjoxXG4gICAgICB+cmVhZF91Y2hhcjooZnVuIH5jYW5fcmVmaWxsOl8gdCAtPlxuICAgICAgICBsZXQgYyA9IENoYW4uZ2V0IHQgMCBpblxuICAgICAgICBDaGFuLmFkdmFuY2UgdCAxO1xuICAgICAgICBVY2hhci5vZl9jaGFyIGMpXG5cbiAgbGV0IHRvX2xhdGluMSBjID1cbiAgICBpZiBVY2hhci5pc19jaGFyIGMgdGhlbiBVY2hhci50b19jaGFyIGNcbiAgICBlbHNlIHJhaXNlIChJbnZhbGlkQ29kZXBvaW50IChVY2hhci50b19pbnQgYykpXG5cbiAgbGV0IGxleGVtZV9jaGFyIGxleGJ1ZiBwb3MgPSB0b19sYXRpbjEgKGxleGVtZV9jaGFyIGxleGJ1ZiBwb3MpXG5cbiAgbGV0IHN1Yl9sZXhlbWUgbGV4YnVmIHBvcyBsZW4gPVxuICAgIGxldCBzID0gQnl0ZXMuY3JlYXRlIGxlbiBpblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICBCeXRlcy5zZXQgcyBpICh0b19sYXRpbjEgbGV4YnVmLmJ1Zi4obGV4YnVmLnN0YXJ0X3BvcyArIHBvcyArIGkpKVxuICAgIGRvbmU7XG4gICAgQnl0ZXMudG9fc3RyaW5nIHNcblxuICBsZXQgbGV4ZW1lIGxleGJ1ZiA9IHN1Yl9sZXhlbWUgbGV4YnVmIDAgKGxleGJ1Zi5wb3MgLSBsZXhidWYuc3RhcnRfcG9zKVxuZW5kXG5cbm1vZHVsZSBVdGY4ID0gc3RydWN0XG4gIG1vZHVsZSBIZWxwZXIgPSBzdHJ1Y3RcbiAgICAoKiBodHRwOi8vd3d3LmZhcXMub3JnL3JmY3MvcmZjMzYyOS5odG1sICopXG5cbiAgICBsZXQgd2lkdGggPSBmdW5jdGlvblxuICAgICAgfCAnXFwwMDAnIC4uICdcXDEyNycgLT4gMVxuICAgICAgfCAnXFwxOTInIC4uICdcXDIyMycgLT4gMlxuICAgICAgfCAnXFwyMjQnIC4uICdcXDIzOScgLT4gM1xuICAgICAgfCAnXFwyNDAnIC4uICdcXDI0NycgLT4gNFxuICAgICAgfCBfIC0+IHJhaXNlIE1hbEZvcm1lZFxuXG4gICAgKCogaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvdmVyc2lvbnMvY29ycmlnZW5kdW0xLmh0bWwgKilcbiAgICBsZXQgY2hlY2tfdHdvIG4xIG4yID1cbiAgICAgIGlmIG4xIDwgMHhjMiB8fCAweGRmIDwgbjEgdGhlbiByYWlzZSBNYWxGb3JtZWQ7XG4gICAgICBpZiBuMiA8IDB4ODAgfHwgMHhiZiA8IG4yIHRoZW4gcmFpc2UgTWFsRm9ybWVkO1xuICAgICAgaWYgbjIgbHNyIDYgIT0gMGIxMCB0aGVuIHJhaXNlIE1hbEZvcm1lZDtcbiAgICAgICgobjEgbGFuZCAweDFmKSBsc2wgNikgbG9yIChuMiBsYW5kIDB4M2YpXG5cbiAgICBsZXQgY2hlY2tfdGhyZWUgbjEgbjIgbjMgPVxuICAgICAgaWYgbjEgPSAweGUwIHRoZW4gKFxuICAgICAgICBpZiBuMiA8IDB4YTAgfHwgMHhiZiA8IG4yIHRoZW4gcmFpc2UgTWFsRm9ybWVkO1xuICAgICAgICBpZiBuMyA8IDB4ODAgfHwgMHhiZiA8IG4zIHRoZW4gcmFpc2UgTWFsRm9ybWVkKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGlmIG4xIDwgMHhlMSB8fCAweGVmIDwgbjEgdGhlbiByYWlzZSBNYWxGb3JtZWQ7XG4gICAgICAgIGlmIG4yIDwgMHg4MCB8fCAweGJmIDwgbjIgdGhlbiByYWlzZSBNYWxGb3JtZWQ7XG4gICAgICAgIGlmIG4zIDwgMHg4MCB8fCAweGJmIDwgbjMgdGhlbiByYWlzZSBNYWxGb3JtZWQpO1xuICAgICAgaWYgbjIgbHNyIDYgIT0gMGIxMCB8fCBuMyBsc3IgNiAhPSAwYjEwIHRoZW4gcmFpc2UgTWFsRm9ybWVkO1xuICAgICAgbGV0IHAgPVxuICAgICAgICAoKG4xIGxhbmQgMHgwZikgbHNsIDEyKSBsb3IgKChuMiBsYW5kIDB4M2YpIGxzbCA2KSBsb3IgKG4zIGxhbmQgMHgzZilcbiAgICAgIGluXG4gICAgICBpZiBwID49IDB4ZDgwMCAmJiBwIDw9IDB4ZGYwMCB0aGVuIHJhaXNlIE1hbEZvcm1lZDtcbiAgICAgIHBcblxuICAgIGxldCBjaGVja19mb3VyIG4xIG4yIG4zIG40ID1cbiAgICAgIGlmIG4xID0gMHhmMCB0aGVuIChcbiAgICAgICAgaWYgbjIgPCAweDkwIHx8IDB4YmYgPCBuMiB0aGVuIHJhaXNlIE1hbEZvcm1lZDtcbiAgICAgICAgaWYgbjMgPCAweDgwIHx8IDB4YmYgPCBuMyB0aGVuIHJhaXNlIE1hbEZvcm1lZDtcbiAgICAgICAgaWYgbjQgPCAweDgwIHx8IDB4YmYgPCBuNCB0aGVuIHJhaXNlIE1hbEZvcm1lZClcbiAgICAgIGVsc2UgaWYgbjEgPSAweGY0IHRoZW4gKFxuICAgICAgICBpZiBuMiA8IDB4ODAgfHwgMHg4ZiA8IG4yIHRoZW4gcmFpc2UgTWFsRm9ybWVkO1xuICAgICAgICBpZiBuMyA8IDB4ODAgfHwgMHhiZiA8IG4zIHRoZW4gcmFpc2UgTWFsRm9ybWVkO1xuICAgICAgICBpZiBuNCA8IDB4ODAgfHwgMHhiZiA8IG40IHRoZW4gcmFpc2UgTWFsRm9ybWVkKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGlmIG4xIDwgMHhmMSB8fCAweGYzIDwgbjEgdGhlbiByYWlzZSBNYWxGb3JtZWQ7XG4gICAgICAgIGlmIG4yIDwgMHg4MCB8fCAweGJmIDwgbjIgdGhlbiByYWlzZSBNYWxGb3JtZWQ7XG4gICAgICAgIGlmIG4zIDwgMHg4MCB8fCAweGJmIDwgbjMgdGhlbiByYWlzZSBNYWxGb3JtZWQ7XG4gICAgICAgIGlmIG40IDwgMHg4MCB8fCAweGJmIDwgbjQgdGhlbiByYWlzZSBNYWxGb3JtZWQpO1xuICAgICAgaWYgbjIgbHNyIDYgIT0gMGIxMCB8fCBuMyBsc3IgNiAhPSAwYjEwIHx8IG40IGxzciA2ICE9IDBiMTAgdGhlblxuICAgICAgICByYWlzZSBNYWxGb3JtZWQ7XG4gICAgICAoKG4xIGxhbmQgMHgwNykgbHNsIDE4KVxuICAgICAgbG9yICgobjIgbGFuZCAweDNmKSBsc2wgMTIpXG4gICAgICBsb3IgKChuMyBsYW5kIDB4M2YpIGxzbCA2KVxuICAgICAgbG9yIChuNCBsYW5kIDB4M2YpXG5cbiAgICBsZXQgbmV4dCBzIGkgPVxuICAgICAgbGV0IGMxID0gcy5baV0gaW5cbiAgICAgIG1hdGNoIHdpZHRoIGMxIHdpdGhcbiAgICAgICAgfCAxIC0+IENoYXIuY29kZSBjMVxuICAgICAgICB8IDIgLT5cbiAgICAgICAgICAgIGxldCBuMSA9IENoYXIuY29kZSBjMSBpblxuICAgICAgICAgICAgbGV0IG4yID0gQ2hhci5jb2RlIHMuW2kgKyAxXSBpblxuICAgICAgICAgICAgY2hlY2tfdHdvIG4xIG4yXG4gICAgICAgIHwgMyAtPlxuICAgICAgICAgICAgbGV0IG4xID0gQ2hhci5jb2RlIGMxIGluXG4gICAgICAgICAgICBsZXQgbjIgPSBDaGFyLmNvZGUgcy5baSArIDFdIGluXG4gICAgICAgICAgICBsZXQgbjMgPSBDaGFyLmNvZGUgcy5baSArIDJdIGluXG4gICAgICAgICAgICBjaGVja190aHJlZSBuMSBuMiBuM1xuICAgICAgICB8IDQgLT5cbiAgICAgICAgICAgIGxldCBuMSA9IENoYXIuY29kZSBjMSBpblxuICAgICAgICAgICAgbGV0IG4yID0gQ2hhci5jb2RlIHMuW2kgKyAxXSBpblxuICAgICAgICAgICAgbGV0IG4zID0gQ2hhci5jb2RlIHMuW2kgKyAyXSBpblxuICAgICAgICAgICAgbGV0IG40ID0gQ2hhci5jb2RlIHMuW2kgKyAzXSBpblxuICAgICAgICAgICAgY2hlY2tfZm91ciBuMSBuMiBuMyBuNFxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgICBsZXQgZ2VuX2Zyb21fY2hhcl9nZW4gcyA9XG4gICAgICBsZXQgbmV4dF9vcl9mYWlsICgpID1cbiAgICAgICAgbWF0Y2ggR2VuLm5leHQgcyB3aXRoIE5vbmUgLT4gcmFpc2UgTWFsRm9ybWVkIHwgU29tZSB4IC0+IENoYXIuY29kZSB4XG4gICAgICBpblxuICAgICAgZnVuICgpIC0+XG4gICAgICAgIEdlbi5uZXh0IHMgPj58IGZ1biBjMSAtPlxuICAgICAgICBtYXRjaCB3aWR0aCBjMSB3aXRoXG4gICAgICAgICAgfCAxIC0+IFVjaGFyLm9mX2NoYXIgYzFcbiAgICAgICAgICB8IDIgLT5cbiAgICAgICAgICAgICAgbGV0IG4xID0gQ2hhci5jb2RlIGMxIGluXG4gICAgICAgICAgICAgIGxldCBuMiA9IG5leHRfb3JfZmFpbCAoKSBpblxuICAgICAgICAgICAgICBVY2hhci5vZl9pbnQgKGNoZWNrX3R3byBuMSBuMilcbiAgICAgICAgICB8IDMgLT5cbiAgICAgICAgICAgICAgbGV0IG4xID0gQ2hhci5jb2RlIGMxIGluXG4gICAgICAgICAgICAgIGxldCBuMiA9IG5leHRfb3JfZmFpbCAoKSBpblxuICAgICAgICAgICAgICBsZXQgbjMgPSBuZXh0X29yX2ZhaWwgKCkgaW5cbiAgICAgICAgICAgICAgVWNoYXIub2ZfaW50IChjaGVja190aHJlZSBuMSBuMiBuMylcbiAgICAgICAgICB8IDQgLT5cbiAgICAgICAgICAgICAgbGV0IG4xID0gQ2hhci5jb2RlIGMxIGluXG4gICAgICAgICAgICAgIGxldCBuMiA9IG5leHRfb3JfZmFpbCAoKSBpblxuICAgICAgICAgICAgICBsZXQgbjMgPSBuZXh0X29yX2ZhaWwgKCkgaW5cbiAgICAgICAgICAgICAgbGV0IG40ID0gbmV4dF9vcl9mYWlsICgpIGluXG4gICAgICAgICAgICAgIFVjaGFyLm9mX2ludCAoY2hlY2tfZm91ciBuMSBuMiBuMyBuNClcbiAgICAgICAgICB8IF8gLT4gcmFpc2UgTWFsRm9ybWVkXG5cbiAgICAoKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbiAgICBsZXQgdG9fYnVmZmVyIGEgYXBvcyBsZW4gYiA9XG4gICAgICBmb3IgaSA9IGFwb3MgdG8gYXBvcyArIGxlbiAtIDEgZG9cbiAgICAgICAgQnVmZmVyLmFkZF91dGZfOF91Y2hhciBiIGEuKGkpXG4gICAgICBkb25lXG4gIGVuZFxuXG4gIGxldCBmcm9tX2NoYW5uZWwgaWMgPVxuICAgIG1ha2VfZnJvbV9jaGFubmVsIGljIH5ieXRlc19wZXJfY2hhcjpVY2hhci51dGZfOF9ieXRlX2xlbmd0aFxuICAgICAgfm1pbl9ieXRlc19wZXJfdWNoYXI6MSB+bWF4X2J5dGVzX3Blcl91Y2hhcjo0XG4gICAgICB+cmVhZF91Y2hhcjooZnVuIH5jYW5fcmVmaWxsIHQgLT5cbiAgICAgICAgbGV0IHcgPSBIZWxwZXIud2lkdGggKENoYW4uZ2V0IHQgMCkgaW5cbiAgICAgICAgQ2hhbi5lbnN1cmVfYnl0ZXNfYXZhaWxhYmxlIHQgfmNhbl9yZWZpbGwgdztcbiAgICAgICAgbGV0IGMgPVxuICAgICAgICAgIEhlbHBlci5uZXh0IChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIChDaGFuLnJhd19idWYgdCkpIChDaGFuLnJhd19wb3MgdClcbiAgICAgICAgaW5cbiAgICAgICAgQ2hhbi5hZHZhbmNlIHQgdztcbiAgICAgICAgVWNoYXIub2ZfaW50IGMpXG5cbiAgbGV0IGZyb21fZ2VuIHMgPVxuICAgIGZyb21fZ2VuIH5ieXRlc19wZXJfY2hhcjpVY2hhci51dGZfOF9ieXRlX2xlbmd0aFxuICAgICAgKEhlbHBlci5nZW5fZnJvbV9jaGFyX2dlbiBzKVxuXG4gIGxldCBmcm9tX3N0cmluZyBzID1cbiAgICBmcm9tX2dlbiAoR2VuLmluaXQgfmxpbWl0OihTdHJpbmcubGVuZ3RoIHMpIChmdW4gaSAtPiBTdHJpbmcuZ2V0IHMgaSkpXG5cbiAgbGV0IHN1Yl9sZXhlbWUgbGV4YnVmIHBvcyBsZW4gPVxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIChsZW4gKiA0KSBpblxuICAgIEhlbHBlci50b19idWZmZXIgbGV4YnVmLmJ1ZiAobGV4YnVmLnN0YXJ0X3BvcyArIHBvcykgbGVuIGJ1ZjtcbiAgICBCdWZmZXIuY29udGVudHMgYnVmXG5cbiAgbGV0IGxleGVtZSBsZXhidWYgPSBzdWJfbGV4ZW1lIGxleGJ1ZiAwIChsZXhidWYucG9zIC0gbGV4YnVmLnN0YXJ0X3BvcylcbmVuZFxuXG5tb2R1bGUgVXRmMTYgPSBzdHJ1Y3RcbiAgdHlwZSBieXRlX29yZGVyID0gTGl0dGxlX2VuZGlhbiB8IEJpZ19lbmRpYW5cblxuICBtb2R1bGUgSGVscGVyID0gc3RydWN0XG4gICAgKCogaHR0cDovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMjc4MS50eHQgKilcblxuICAgIGxldCBudW1iZXJfb2ZfcGFpciBibyBjMSBjMiA9XG4gICAgICBtYXRjaCBibyB3aXRoXG4gICAgICAgIHwgTGl0dGxlX2VuZGlhbiAtPiAoYzIgbHNsIDgpICsgYzFcbiAgICAgICAgfCBCaWdfZW5kaWFuIC0+IChjMSBsc2wgOCkgKyBjMlxuXG4gICAgbGV0IGdldF9ibyBibyBjMSBjMiA9XG4gICAgICBtYXRjaCAhYm8gd2l0aFxuICAgICAgICB8IFNvbWUgbyAtPiBvXG4gICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgbGV0IG8gPVxuICAgICAgICAgICAgICBtYXRjaCAoYzEsIGMyKSB3aXRoXG4gICAgICAgICAgICAgICAgfCAweGZmLCAweGZlIC0+IExpdHRsZV9lbmRpYW5cbiAgICAgICAgICAgICAgICB8IF8gLT4gQmlnX2VuZGlhblxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIGJvIDo9IFNvbWUgbztcbiAgICAgICAgICAgIG9cblxuICAgIGxldCBnZW5fZnJvbV9jaGFyX2dlbiBvcHRfYm8gcyA9XG4gICAgICBsZXQgbmV4dF9vcl9mYWlsICgpID1cbiAgICAgICAgbWF0Y2ggR2VuLm5leHQgcyB3aXRoIE5vbmUgLT4gcmFpc2UgTWFsRm9ybWVkIHwgU29tZSB4IC0+IENoYXIuY29kZSB4XG4gICAgICBpblxuICAgICAgbGV0IGJvID0gcmVmIG9wdF9ibyBpblxuICAgICAgZnVuICgpIC0+XG4gICAgICAgIEdlbi5uZXh0IHMgPj58IGZ1biBjMSAtPlxuICAgICAgICBsZXQgbjEgPSBDaGFyLmNvZGUgYzEgaW5cbiAgICAgICAgbGV0IG4yID0gbmV4dF9vcl9mYWlsICgpIGluXG4gICAgICAgIGxldCBvID0gZ2V0X2JvIGJvIG4xIG4yIGluXG4gICAgICAgIGxldCB3MSA9IG51bWJlcl9vZl9wYWlyIG8gbjEgbjIgaW5cbiAgICAgICAgaWYgdzEgPSAweGZmZmUgdGhlbiByYWlzZSAoSW52YWxpZENvZGVwb2ludCB3MSk7XG4gICAgICAgIGlmIHcxIDwgMHhkODAwIHx8IDB4ZGZmZiA8IHcxIHRoZW4gVWNoYXIub2ZfaW50IHcxXG4gICAgICAgIGVsc2UgaWYgdzEgPD0gMHhkYmZmIHRoZW4gKFxuICAgICAgICAgIGxldCBuMyA9IG5leHRfb3JfZmFpbCAoKSBpblxuICAgICAgICAgIGxldCBuNCA9IG5leHRfb3JfZmFpbCAoKSBpblxuICAgICAgICAgIGxldCB3MiA9IG51bWJlcl9vZl9wYWlyIG8gbjMgbjQgaW5cbiAgICAgICAgICBpZiB3MiA8IDB4ZGMwMCB8fCB3MiA+IDB4ZGZmZiB0aGVuIHJhaXNlIE1hbEZvcm1lZDtcbiAgICAgICAgICBsZXQgdXBwZXIxMCA9ICh3MSBsYW5kIDB4M2ZmKSBsc2wgMTAgYW5kIGxvd2VyMTAgPSB3MiBsYW5kIDB4M2ZmIGluXG4gICAgICAgICAgVWNoYXIub2ZfaW50ICgweDEwMDAwICsgdXBwZXIxMCArIGxvd2VyMTApKVxuICAgICAgICBlbHNlIHJhaXNlIE1hbEZvcm1lZFxuXG4gICAgbGV0IHRvX2J1ZmZlciBibyBhIGFwb3MgbGVuIGJvbSBiID1cbiAgICAgIGxldCBzdG9yZSA9XG4gICAgICAgIG1hdGNoIGJvIHdpdGhcbiAgICAgICAgICB8IEJpZ19lbmRpYW4gLT4gQnVmZmVyLmFkZF91dGZfMTZiZV91Y2hhciBiXG4gICAgICAgICAgfCBMaXR0bGVfZW5kaWFuIC0+IEJ1ZmZlci5hZGRfdXRmXzE2bGVfdWNoYXIgYlxuICAgICAgaW5cbiAgICAgIGlmIGJvbSB0aGVuIHN0b3JlIChVY2hhci5vZl9pbnQgMHhmZWZmKTtcbiAgICAgICgqIGZpcnN0LCBzdG9yZSB0aGUgQk9NICopXG4gICAgICBmb3IgaSA9IGFwb3MgdG8gYXBvcyArIGxlbiAtIDEgZG9cbiAgICAgICAgc3RvcmUgYS4oaSlcbiAgICAgIGRvbmVcbiAgZW5kXG5cbiAgbGV0IGZyb21fY2hhbm5lbCBpYyBvcHRfYm8gPVxuICAgIGxldCBibyA9IHJlZiBvcHRfYm8gaW5cbiAgICBtYWtlX2Zyb21fY2hhbm5lbCBpYyB+Ynl0ZXNfcGVyX2NoYXI6VWNoYXIudXRmXzE2X2J5dGVfbGVuZ3RoXG4gICAgICB+bWluX2J5dGVzX3Blcl91Y2hhcjoyIH5tYXhfYnl0ZXNfcGVyX3VjaGFyOjRcbiAgICAgIH5yZWFkX3VjaGFyOihmdW4gfmNhbl9yZWZpbGwgdCAtPlxuICAgICAgICBsZXQgbjEgPSBDaGFyLmNvZGUgKENoYW4uZ2V0IHQgMCkgaW5cbiAgICAgICAgbGV0IG4yID0gQ2hhci5jb2RlIChDaGFuLmdldCB0IDEpIGluXG4gICAgICAgIGxldCBvID0gSGVscGVyLmdldF9ibyBibyBuMSBuMiBpblxuICAgICAgICBsZXQgdzEgPSBIZWxwZXIubnVtYmVyX29mX3BhaXIgbyBuMSBuMiBpblxuICAgICAgICBpZiB3MSA9IDB4ZmZmZSB0aGVuIHJhaXNlIChJbnZhbGlkQ29kZXBvaW50IHcxKTtcbiAgICAgICAgaWYgdzEgPCAweGQ4MDAgfHwgMHhkZmZmIDwgdzEgdGhlbiAoXG4gICAgICAgICAgQ2hhbi5hZHZhbmNlIHQgMjtcbiAgICAgICAgICBVY2hhci5vZl9pbnQgdzEpXG4gICAgICAgIGVsc2UgaWYgdzEgPD0gMHhkYmZmIHRoZW4gKFxuICAgICAgICAgIENoYW4uZW5zdXJlX2J5dGVzX2F2YWlsYWJsZSB0IH5jYW5fcmVmaWxsIDQ7XG4gICAgICAgICAgbGV0IG4zID0gQ2hhci5jb2RlIChDaGFuLmdldCB0IDIpIGluXG4gICAgICAgICAgbGV0IG40ID0gQ2hhci5jb2RlIChDaGFuLmdldCB0IDMpIGluXG4gICAgICAgICAgbGV0IHcyID0gSGVscGVyLm51bWJlcl9vZl9wYWlyIG8gbjMgbjQgaW5cbiAgICAgICAgICBpZiB3MiA8IDB4ZGMwMCB8fCB3MiA+IDB4ZGZmZiB0aGVuIHJhaXNlIE1hbEZvcm1lZDtcbiAgICAgICAgICBsZXQgdXBwZXIxMCA9ICh3MSBsYW5kIDB4M2ZmKSBsc2wgMTAgYW5kIGxvd2VyMTAgPSB3MiBsYW5kIDB4M2ZmIGluXG4gICAgICAgICAgQ2hhbi5hZHZhbmNlIHQgNDtcbiAgICAgICAgICBVY2hhci5vZl9pbnQgKDB4MTAwMDAgKyB1cHBlcjEwICsgbG93ZXIxMCkpXG4gICAgICAgIGVsc2UgcmFpc2UgTWFsRm9ybWVkKVxuXG4gIGxldCBmcm9tX2dlbiBzIG9wdF9ibyA9XG4gICAgZnJvbV9nZW4gfmJ5dGVzX3Blcl9jaGFyOlVjaGFyLnV0Zl8xNl9ieXRlX2xlbmd0aFxuICAgICAgKEhlbHBlci5nZW5fZnJvbV9jaGFyX2dlbiBvcHRfYm8gcylcblxuICBsZXQgZnJvbV9zdHJpbmcgcyA9XG4gICAgZnJvbV9nZW4gKEdlbi5pbml0IH5saW1pdDooU3RyaW5nLmxlbmd0aCBzKSAoZnVuIGkgLT4gU3RyaW5nLmdldCBzIGkpKVxuXG4gIGxldCBzdWJfbGV4ZW1lIGxiIHBvcyBsZW4gYm8gYm9tID1cbiAgICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAoKGxlbiAqIDQpICsgMikgaW5cbiAgICAoKiArMiBmb3IgdGhlIEJPTSAqKVxuICAgIEhlbHBlci50b19idWZmZXIgYm8gbGIuYnVmIChsYi5zdGFydF9wb3MgKyBwb3MpIGxlbiBib20gYnVmO1xuICAgIEJ1ZmZlci5jb250ZW50cyBidWZcblxuICBsZXQgbGV4ZW1lIGxiIGJvIGJvbSA9IHN1Yl9sZXhlbWUgbGIgMCAobGIucG9zIC0gbGIuc3RhcnRfcG9zKSBibyBib21cbmVuZFxuIl0sIm5hbWVzIjpbInJ1bnRpbWUiLCJjc3Rfc3JjX2xpYl9zZWRsZXhpbmdfbWwiLCJjYW1sX2FycmF5X21ha2UiLCJjYW1sX2NoZWNrX2JvdW5kIiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9tYXliZV9hdHRhY2hfYmFja3RyYWNlIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfZ2V0IiwiY2FtbF93cmFwX2V4Y2VwdGlvbiIsImNhbWxfY2FsbDEiLCJmIiwiYTAiLCJjYW1sX2NhbGwyIiwiYTEiLCJjYW1sX2NhbGwzIiwiYTIiLCJjYW1sX2NhbGw0IiwiYTMiLCJjYW1sX2NhbGw1IiwiYTQiLCJkdW1teSIsImdsb2JhbF9kYXRhIiwiY3N0IiwiU3RkbGliX0J1ZmZlciIsIkdlbiIsIlN0ZGxpYl9CeXRlcyIsIkFzc2VydF9mYWlsdXJlIiwiU3RkbGliX0FycmF5IiwiU3RkbGliIiwiU3RkbGliX09wdGlvbiIsIlN0ZGxpYl9VY2hhciIsIkludmFsaWRDb2RlcG9pbnQiLCJNYWxGb3JtZWQiLCJ0b19pbnQiLCJpc19jaGFyIiwib2ZfY2hhciIsInRvX2NoYXIiLCJlcXVhbCIsInV0Zl84X2J5dGVfbGVuZ3RoIiwidXRmXzE2X2J5dGVfbGVuZ3RoIiwib2ZfaW50IiwieCIsImVtcHR5X2xleGJ1ZiIsImJ5dGVzX3Blcl9jaGFyIiwicGFyYW0iLCJkdW1teV91Y2hhciIsIm5sX3VjaGFyIiwiY2h1bmtfc2l6ZSIsImNyZWF0ZSIsIm9wdCIsInJlZmlsbCIsImluaXQiLCJzZXRfcG9zaXRpb24iLCJieXRlc19wb3NpdGlvbiIsImxleGJ1ZiIsInBvc2l0aW9uIiwic2V0X2ZpbGVuYW1lIiwiZm5hbWUiLCJmcm9tX2dlbiIsImdlbiIsIm1hbGZvcm1lZCIsImJ1ZiIsInBvcyIsImxlbiIsImkiLCJ2YWwiLCJleG4iLCJjIiwiZnJvbV9pbnRfYXJyYXkiLCJhIiwiZnJvbV91Y2hhcl9hcnJheSIsIm5ld19saW5lIiwibmV4dF9hdXgiLCJzb21lIiwibm9uZSIsImIiLCJzIiwic19ieXRlcyIsImxzIiwibmV3bGVuIiwibmV3YnVmIiwibiIsInJldCIsIm5leHQiLCJwcml2YXRlX25leHRfaW50IiwibWFyayIsInN0YXJ0IiwiYmFja3RyYWNrIiwicm9sbGJhY2siLCJsZXhlbWVfc3RhcnQiLCJsZXhlbWVfYnl0ZXNfc3RhcnQiLCJsZXhlbWVfZW5kIiwibGV4ZW1lX2J5dGVzX2VuZCIsImxvYyIsImJ5dGVzX2xvYyIsImxleGVtZV9sZW5ndGgiLCJsZXhlbWVfYnl0ZXNfbGVuZ3RoIiwic3ViX2xleGVtZSIsImxleGVtZSIsImxleGVtZV9jaGFyIiwibGV4aW5nX3Bvc2l0aW9uX3N0YXJ0IiwibGV4aW5nX3Bvc2l0aW9uX2N1cnIiLCJsZXhpbmdfcG9zaXRpb25zIiwic3RhcnRfcCIsImN1cnJfcCIsImxleGluZ19ieXRlc19wb3NpdGlvbl9zdGFydCIsImxleGluZ19ieXRlc19wb3NpdGlvbl9jdXJyIiwibGV4aW5nX2J5dGVzX3Bvc2l0aW9ucyIsIndpdGhfdG9rZW5pemVyIiwibGV4ZXIiLCJ0b2tlbiIsIm1hdGNoIiwiTWlzc2luZ19pbnB1dCIsIm1pbl9idWZmZXJfc2l6ZSIsImNzdF9TZWRsZXhpbmdfQ2hhbl9lbnN1cmUiLCJjc3RfYWR2YW5jZSIsImF2YWlsYWJsZSIsInQiLCJlbnN1cmVfYnl0ZXNfYXZhaWxhYmxlIiwiY2FuX3JlZmlsbCIsInJlYWQiLCJnZXQiLCJhZHZhbmNlIiwibWFrZV9mcm9tX2NoYW5uZWwiLCJpYyIsIm1heF9ieXRlc19wZXJfdWNoYXIiLCJtaW5fYnl0ZXNfcGVyX3VjaGFyIiwicmVhZF91Y2hhciIsImZyb21fc3RyaW5nIiwiZnJvbV9jaGFubmVsIiwidG9fbGF0aW4xIiwid2lkdGgiLCJjaGVja190d28iLCJuMSIsIm4yIiwiY2hlY2tfdGhyZWUiLCJuMyIsInAiLCJjaGVja19mb3VyIiwibjQiLCJ3IiwiYzEiLCJzd2l0Y2hlciIsIm5leHRfb3JfZmFpbCIsIm8iLCJhcG9zIiwibnVtYmVyX29mX3BhaXIiLCJibyIsImMyIiwiZ2V0X2JvIiwib3B0X2JvIiwidzEiLCJ3MiIsInVwcGVyMTAiLCJsb3dlcjEwIiwibGIiLCJib20iLCJzdG9yZSIsIlNlZGxleGluZyJdLCJtYXBwaW5ncyI6IklBQUFBLFVBQUE7QUFBQSxJQUFBQywyQkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsbUJBQUE7QUFBQSxJQUFBQyxvQkFBQTtBQUFBLElBQUFDLG1CQUFBO0FBQUEsSUFBQUMsOEJBQUE7QUFBQSxJQUFBQyx3QkFBQTtBQUFBLElBQUFDLGtCQUFBO0FBQUEsSUFBQUMsc0JBQUE7QUFBQSxZQUFBQyxXQUFBQyxHQUFBQztBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQUYsR0FBQUMsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFlBQUFDLFdBQUFKLEdBQUFDLElBQUFFLElBQUFFO0FBQUFBLElBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUFBQyxXQUFBTixHQUFBQyxJQUFBRSxJQUFBRSxJQUFBRTtBQUFBQSxJQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFBQUMsV0FBQVIsR0FBQUMsSUFBQUUsSUFBQUUsSUFBQUUsSUFBQUU7QUFBQUEsSUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUMsUUFBQTtBQUFBLElBQUFDLGNBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsZ0JBQUE7QUFBQSxJQUFBQyxNQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLGlCQUFBO0FBQUEsSUFBQUMsZUFBQTtBQUFBLElBQUFDLFNBQUE7QUFBQSxJQUFBQyxnQkFBQTtBQUFBLElBQUFDLGVBQUE7QUFBQSxJQUFBQztBQUFBQSxNQUFBO0FBQUEsSUFBQUMsWUFBQTtBQUFBLElBQUFDLFNDMkJJO0FBQUEsSUFBQUMsVUFBQTtBQUFBLElBQUFD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
